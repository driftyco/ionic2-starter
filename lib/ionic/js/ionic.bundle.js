System.register('ionic/components', ['ionic/components/app/app', 'ionic/components/action-menu/action-menu', 'ionic/components/aside/aside', 'ionic/components/button/button', 'ionic/components/card/card', 'ionic/components/checkbox/checkbox', 'ionic/components/content/content', 'ionic/components/icon/icon', 'ionic/components/item/item', 'ionic/components/item/item-group', 'ionic/components/form/input', 'ionic/components/form/text-input', 'ionic/components/form/tap-input', 'ionic/components/form/label', 'ionic/components/list/list', 'ionic/components/show-hide-when/show-hide-when', 'ionic/components/material/button', 'ionic/components/material/ripple', 'ionic/components/modal/modal', 'ionic/components/nav/nav', 'ionic/components/nav/nav-controller', 'ionic/components/nav/nav-push', 'ionic/components/nav-bar/nav-bar', 'ionic/components/popup/popup', 'ionic/components/slides/slides', 'ionic/components/radio/radio', 'ionic/components/scroll/scroll', 'ionic/components/scroll/pull-to-refresh', 'ionic/components/search-bar/search-bar', 'ionic/components/segment/segment', 'ionic/components/switch/switch', 'ionic/components/tabs/tabs', 'ionic/components/tabs/tab', 'ionic/components/toolbar/toolbar'], function (_export) {
  'use strict';

  // Material components/effects
  return {
    setters: [function (_ionicComponentsAppApp) {
      for (var _key in _ionicComponentsAppApp) {
        _export(_key, _ionicComponentsAppApp[_key]);
      }
    }, function (_ionicComponentsActionMenuActionMenu) {
      for (var _key2 in _ionicComponentsActionMenuActionMenu) {
        _export(_key2, _ionicComponentsActionMenuActionMenu[_key2]);
      }
    }, function (_ionicComponentsAsideAside) {
      for (var _key3 in _ionicComponentsAsideAside) {
        _export(_key3, _ionicComponentsAsideAside[_key3]);
      }
    }, function (_ionicComponentsButtonButton) {
      for (var _key4 in _ionicComponentsButtonButton) {
        _export(_key4, _ionicComponentsButtonButton[_key4]);
      }
    }, function (_ionicComponentsCardCard) {
      for (var _key5 in _ionicComponentsCardCard) {
        _export(_key5, _ionicComponentsCardCard[_key5]);
      }
    }, function (_ionicComponentsCheckboxCheckbox) {
      for (var _key6 in _ionicComponentsCheckboxCheckbox) {
        _export(_key6, _ionicComponentsCheckboxCheckbox[_key6]);
      }
    }, function (_ionicComponentsContentContent) {
      for (var _key7 in _ionicComponentsContentContent) {
        _export(_key7, _ionicComponentsContentContent[_key7]);
      }
    }, function (_ionicComponentsIconIcon) {
      for (var _key8 in _ionicComponentsIconIcon) {
        _export(_key8, _ionicComponentsIconIcon[_key8]);
      }
    }, function (_ionicComponentsItemItem) {
      for (var _key9 in _ionicComponentsItemItem) {
        _export(_key9, _ionicComponentsItemItem[_key9]);
      }
    }, function (_ionicComponentsItemItemGroup) {
      for (var _key10 in _ionicComponentsItemItemGroup) {
        _export(_key10, _ionicComponentsItemItemGroup[_key10]);
      }
    }, function (_ionicComponentsFormInput) {
      for (var _key11 in _ionicComponentsFormInput) {
        _export(_key11, _ionicComponentsFormInput[_key11]);
      }
    }, function (_ionicComponentsFormTextInput) {
      for (var _key12 in _ionicComponentsFormTextInput) {
        _export(_key12, _ionicComponentsFormTextInput[_key12]);
      }
    }, function (_ionicComponentsFormTapInput) {
      for (var _key13 in _ionicComponentsFormTapInput) {
        _export(_key13, _ionicComponentsFormTapInput[_key13]);
      }
    }, function (_ionicComponentsFormLabel) {
      for (var _key14 in _ionicComponentsFormLabel) {
        _export(_key14, _ionicComponentsFormLabel[_key14]);
      }
    }, function (_ionicComponentsListList) {
      for (var _key15 in _ionicComponentsListList) {
        _export(_key15, _ionicComponentsListList[_key15]);
      }
    }, function (_ionicComponentsShowHideWhenShowHideWhen) {
      for (var _key16 in _ionicComponentsShowHideWhenShowHideWhen) {
        _export(_key16, _ionicComponentsShowHideWhenShowHideWhen[_key16]);
      }
    }, function (_ionicComponentsMaterialButton) {
      for (var _key17 in _ionicComponentsMaterialButton) {
        _export(_key17, _ionicComponentsMaterialButton[_key17]);
      }
    }, function (_ionicComponentsMaterialRipple) {
      for (var _key18 in _ionicComponentsMaterialRipple) {
        _export(_key18, _ionicComponentsMaterialRipple[_key18]);
      }
    }, function (_ionicComponentsModalModal) {
      for (var _key19 in _ionicComponentsModalModal) {
        _export(_key19, _ionicComponentsModalModal[_key19]);
      }
    }, function (_ionicComponentsNavNav) {
      for (var _key20 in _ionicComponentsNavNav) {
        _export(_key20, _ionicComponentsNavNav[_key20]);
      }
    }, function (_ionicComponentsNavNavController) {
      for (var _key21 in _ionicComponentsNavNavController) {
        _export(_key21, _ionicComponentsNavNavController[_key21]);
      }
    }, function (_ionicComponentsNavNavPush) {
      for (var _key22 in _ionicComponentsNavNavPush) {
        _export(_key22, _ionicComponentsNavNavPush[_key22]);
      }
    }, function (_ionicComponentsNavBarNavBar) {
      for (var _key23 in _ionicComponentsNavBarNavBar) {
        _export(_key23, _ionicComponentsNavBarNavBar[_key23]);
      }
    }, function (_ionicComponentsPopupPopup) {
      for (var _key24 in _ionicComponentsPopupPopup) {
        _export(_key24, _ionicComponentsPopupPopup[_key24]);
      }
    }, function (_ionicComponentsSlidesSlides) {
      for (var _key25 in _ionicComponentsSlidesSlides) {
        _export(_key25, _ionicComponentsSlidesSlides[_key25]);
      }
    }, function (_ionicComponentsRadioRadio) {
      for (var _key26 in _ionicComponentsRadioRadio) {
        _export(_key26, _ionicComponentsRadioRadio[_key26]);
      }
    }, function (_ionicComponentsScrollScroll) {
      for (var _key27 in _ionicComponentsScrollScroll) {
        _export(_key27, _ionicComponentsScrollScroll[_key27]);
      }
    }, function (_ionicComponentsScrollPullToRefresh) {
      for (var _key28 in _ionicComponentsScrollPullToRefresh) {
        _export(_key28, _ionicComponentsScrollPullToRefresh[_key28]);
      }
    }, function (_ionicComponentsSearchBarSearchBar) {
      for (var _key29 in _ionicComponentsSearchBarSearchBar) {
        _export(_key29, _ionicComponentsSearchBarSearchBar[_key29]);
      }
    }, function (_ionicComponentsSegmentSegment) {
      for (var _key30 in _ionicComponentsSegmentSegment) {
        _export(_key30, _ionicComponentsSegmentSegment[_key30]);
      }
    }, function (_ionicComponentsSwitchSwitch) {
      for (var _key31 in _ionicComponentsSwitchSwitch) {
        _export(_key31, _ionicComponentsSwitchSwitch[_key31]);
      }
    }, function (_ionicComponentsTabsTabs) {
      for (var _key32 in _ionicComponentsTabsTabs) {
        _export(_key32, _ionicComponentsTabsTabs[_key32]);
      }
    }, function (_ionicComponentsTabsTab) {
      for (var _key33 in _ionicComponentsTabsTab) {
        _export(_key33, _ionicComponentsTabsTab[_key33]);
      }
    }, function (_ionicComponentsToolbarToolbar) {
      for (var _key34 in _ionicComponentsToolbarToolbar) {
        _export(_key34, _ionicComponentsToolbarToolbar[_key34]);
      }
    }],
    execute: function () {}
  };
});
System.register("ionic/index", [], function (_export) {
  "use strict";

  return {
    setters: [],
    execute: function () {}
  };
});
/*
 * export everything here
 */
System.register('ionic/ionic', ['ionic/config/config', 'ionic/config/annotations', 'ionic/net/http', 'ionic/registry', 'ionic/components', 'ionic/platform/platform', 'ionic/platform/registry', 'ionic/routing/router', 'ionic/routing/url-state', 'ionic/util/click-block', 'ionic/util/focus', 'ionic/animations/animation', 'ionic/animations/builtins', 'ionic/transitions/transition', 'ionic/transitions/ios-transition', 'ionic/transitions/md-transition'], function (_export) {
  'use strict';

  return {
    setters: [function (_ionicConfigConfig) {
      for (var _key in _ionicConfigConfig) {
        _export(_key, _ionicConfigConfig[_key]);
      }
    }, function (_ionicConfigAnnotations) {
      for (var _key2 in _ionicConfigAnnotations) {
        _export(_key2, _ionicConfigAnnotations[_key2]);
      }
    }, function (_ionicNetHttp) {
      for (var _key3 in _ionicNetHttp) {
        _export(_key3, _ionicNetHttp[_key3]);
      }
    }, function (_ionicRegistry) {
      for (var _key4 in _ionicRegistry) {
        _export(_key4, _ionicRegistry[_key4]);
      }
    }, function (_ionicComponents) {
      for (var _key5 in _ionicComponents) {
        _export(_key5, _ionicComponents[_key5]);
      }
    }, function (_ionicPlatformPlatform) {
      for (var _key6 in _ionicPlatformPlatform) {
        _export(_key6, _ionicPlatformPlatform[_key6]);
      }
    }, function (_ionicPlatformRegistry) {
      for (var _key7 in _ionicPlatformRegistry) {
        _export(_key7, _ionicPlatformRegistry[_key7]);
      }
    }, function (_ionicRoutingRouter) {
      for (var _key8 in _ionicRoutingRouter) {
        _export(_key8, _ionicRoutingRouter[_key8]);
      }
    }, function (_ionicRoutingUrlState) {
      for (var _key9 in _ionicRoutingUrlState) {
        _export(_key9, _ionicRoutingUrlState[_key9]);
      }
    }, function (_ionicUtilClickBlock) {
      for (var _key10 in _ionicUtilClickBlock) {
        _export(_key10, _ionicUtilClickBlock[_key10]);
      }
    }, function (_ionicUtilFocus) {
      for (var _key11 in _ionicUtilFocus) {
        _export(_key11, _ionicUtilFocus[_key11]);
      }
    }, function (_ionicAnimationsAnimation) {
      for (var _key12 in _ionicAnimationsAnimation) {
        _export(_key12, _ionicAnimationsAnimation[_key12]);
      }
    }, function (_ionicAnimationsBuiltins) {
      for (var _key13 in _ionicAnimationsBuiltins) {
        _export(_key13, _ionicAnimationsBuiltins[_key13]);
      }
    }, function (_ionicTransitionsTransition) {
      for (var _key14 in _ionicTransitionsTransition) {
        _export(_key14, _ionicTransitionsTransition[_key14]);
      }
    }, function (_ionicTransitionsIosTransition) {
      for (var _key15 in _ionicTransitionsIosTransition) {
        _export(_key15, _ionicTransitionsIosTransition[_key15]);
      }
    }, function (_ionicTransitionsMdTransition) {
      for (var _key16 in _ionicTransitionsMdTransition) {
        _export(_key16, _ionicTransitionsMdTransition[_key16]);
      }
    }],
    execute: function () {}
  };
});
System.register("ionic/registry", ["angular2/angular2", "ionic/ionic"], function (_export) {
    "use strict";

    var Directive, IonicApp, __decorate, __metadata, Register;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
        }, function (_ionicIonic) {
            IonicApp = _ionicIonic.IonicApp;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Register = (function () {
                var _class = function Register(app) {
                    _classCallCheck(this, _class);

                    this.app = app;
                };

                _createClass(_class, [{
                    key: "onInit",
                    value: function onInit() {
                        if (this.register && this.registerId) {
                            this.app.register(this.registerId, this.register);
                        }
                    }
                }]);

                return _class;
            })();

            _export("Register", Register);

            _export("Register", Register = __decorate([Directive({
                selector: "[register]",
                properties: ["register", "registerId: register-id"],
                host: {
                    "this.register-id": "registerId"
                }
            }), __metadata("design:paramtypes", [typeof IonicApp !== "undefined" && IonicApp || Object])], Register));
        }
    };
});
System.register('ionic/util', ['ionic/util/dom', 'ionic/util/util'], function (_export) {
  'use strict';

  var domUtil, dom;
  return {
    setters: [function (_ionicUtilDom) {
      domUtil = _ionicUtilDom;
    }, function (_ionicUtilUtil) {
      for (var _key in _ionicUtilUtil) {
        _export(_key, _ionicUtilUtil[_key]);
      }
    }],
    execute: function () {
      dom = domUtil;

      _export('dom', dom);
    }
  };
});
System.register('ionic/components/ion', ['ionic/util'], function (_export) {
    'use strict';

    var util, Ion;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            /**
             * Base class for all Ionic components. Exposes some common functionality
             * that all Ionic components need, such as accessing underlying native elements and
             * sending/receiving app-level events.
             */

            Ion = (function () {
                function Ion(elementRef, config) {
                    _classCallCheck(this, Ion);

                    this.elementRef = elementRef;
                    this.config = config;
                    this.clsMode = config.setting('mode');
                }

                _createClass(Ion, [{
                    key: 'onInit',
                    value: function onInit() {
                        var cls = this.constructor;
                        if (cls.defaultProperties && this.config) {
                            for (var prop in cls.defaultProperties) {
                                // Priority:
                                // ---------
                                // 1) Value set from within constructor
                                // 2) Value set from the host element's attribute
                                // 3) Value set by the users global config
                                // 4) Value set by the default mode/platform config
                                // 5) Value set from the component's default
                                if (this[prop]) {
                                    // this property has already been set on the instance
                                    // could be from the user setting the element's attribute
                                    // or from the user setting it within the constructor
                                    continue;
                                }
                                // get the property values from a global user/platform config
                                var configVal = this.config.setting(prop);
                                if (configVal) {
                                    this[prop] = configVal;
                                    continue;
                                }
                                // wasn't set yet, so go with property's default value
                                this[prop] = cls.defaultProperties[prop];
                            }
                        }
                        this.onIonInit && this.onIonInit();
                    }
                }, {
                    key: 'getDelegate',
                    value: function getDelegate(delegateName) {
                        var cls = this.constructor;
                        if (cls.delegates) {
                            var cases = cls.delegates[delegateName] || [];
                            for (var i = 0; i < cases.length; i++) {
                                var delegateCase = cases[i];
                                if (util.isArray(delegateCase)) {
                                    var _delegateCase = _slicedToArray(delegateCase, 2);

                                    var check = _delegateCase[0];
                                    var DelegateConstructor = _delegateCase[1];

                                    if (check(this)) {
                                        return new DelegateConstructor(this);
                                    }
                                } else {
                                    return new delegateCase(this);
                                }
                            }
                        }
                    }
                }, {
                    key: 'getElementRef',
                    value: function getElementRef() {
                        return this.elementRef;
                    }
                }, {
                    key: 'getNativeElement',
                    value: function getNativeElement() {
                        return this.elementRef.nativeElement;
                    }
                }, {
                    key: 'width',
                    value: function width() {
                        return this.getNativeElement().offsetWidth;
                    }
                }, {
                    key: 'height',
                    value: function height() {
                        return this.getNativeElement().offsetHeight;
                    }
                }]);

                return Ion;
            })();

            _export('Ion', Ion);
        }
    };
});
System.register('ionic/animations/animation', ['../util/dom'], function (_export) {
    'use strict';

    var CSS, RENDER_DELAY, AnimationRegistry, Animation, Animate, TRANSFORMS, ANIMATE_PROPERTIES, CUBIC_BEZIERS, EASING_FN;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function insertEffects(effects, fromEffect, toEffect, easingConfig) {
        easingConfig.opts = easingConfig.opts || {};
        var increment = easingConfig.opts.increment || 0.04;
        var easingFn = EASING_FN[easingConfig.name];
        var pos = undefined,
            tweenEffect = undefined,
            addEffect = undefined,
            property = undefined,
            toProperty = undefined,
            fromValue = undefined,
            diffValue = undefined;
        for (pos = increment; pos <= 1 - increment; pos += increment) {
            tweenEffect = {};
            addEffect = false;
            for (property in toEffect) {
                toProperty = toEffect[property];
                if (toProperty.tween) {
                    fromValue = fromEffect[property].num;
                    diffValue = toProperty.num - fromValue;
                    tweenEffect[property] = {
                        value: roundValue(easingFn(pos, easingConfig.opts) * diffValue + fromValue) + toProperty.unit
                    };
                    addEffect = true;
                }
            }
            if (addEffect) {
                effects.push(convertProperties(tweenEffect));
            }
        }
    }
    function parseEffect(inputEffect) {
        var val = undefined,
            r = undefined,
            num = undefined,
            property = undefined;
        var outputEffect = {};
        for (property in inputEffect) {
            val = inputEffect[property];
            r = val.toString().match(/(\d*\.?\d*)(.*)/);
            num = parseFloat(r[1]);
            outputEffect[property] = {
                value: val,
                num: num,
                unit: r[0] != r[2] ? r[2] : '',
                tween: !isNaN(num) && ANIMATE_PROPERTIES.indexOf(property) > -1
            };
        }
        return outputEffect;
    }
    function convertProperties(inputEffect) {
        var outputEffect = {};
        var transforms = [];
        var value = undefined,
            property = undefined;
        for (property in inputEffect) {
            value = inputEffect[property].value;
            if (TRANSFORMS.indexOf(property) > -1) {
                transforms.push(property + '(' + value + ')');
            } else {
                outputEffect[property] = value;
            }
        }
        if (transforms.length) {
            transforms.push('translateZ(0px)');
            outputEffect.transform = transforms.join(' ');
        }
        return outputEffect;
    }
    function inlineStyle(ele, effect) {
        if (ele && effect) {
            var transforms = [];
            var value = undefined,
                property = undefined;
            for (property in effect) {
                value = effect[property].value;
                if (TRANSFORMS.indexOf(property) > -1) {
                    transforms.push(property + '(' + value + ')');
                } else {
                    ele.style[property] = value;
                }
            }
            if (transforms.length) {
                transforms.push('translateZ(0px)');
                ele.style[CSS.transform] = transforms.join(' ');
            }
        }
    }
    function roundValue(val) {
        return Math.round(val * 10000) / 10000;
    }
    return {
        setters: [function (_utilDom) {
            CSS = _utilDom.CSS;
        }],
        execute: function () {
            RENDER_DELAY = 36;
            AnimationRegistry = {};

            /**
              Animation Steps/Process
              -----------------------
              1) Construct animation (doesn't start)
              2) Client play()'s animation, returns promise
              3) Add before classes to elements
              4) Remove before classes from elements
              5) Elements staged in "from" effect w/ inline styles
              6) Call onReady()
              7) Wait for RENDER_DELAY milliseconds (give browser time to render)
              8) Call onPlay()
              8) Run from/to animation on elements
              9) Animations finish async
             10) Set inline styles w/ the "to" effects on elements
             11) Add after classes to elements
             12) Remove after classes from elements
             13) Call onFinish()
             14) Resolve play()'s promise
            **/

            Animation = (function () {
                function Animation(ele) {
                    _classCallCheck(this, Animation);

                    this._el = [];
                    this._chld = [];
                    this._ani = [];
                    this._bfAdd = [];
                    this._bfSty = {};
                    this._bfRmv = [];
                    this._afAdd = [];
                    this._afRmv = [];
                    this._readys = [];
                    this._plays = [];
                    this._finishes = [];
                    this.elements(ele);
                }

                _createClass(Animation, [{
                    key: 'elements',
                    value: function elements(ele) {
                        if (ele) {
                            if (typeof ele === 'string') {
                                // string query selector
                                ele = document.querySelectorAll(ele);
                            }
                            if (ele.length) {
                                // array of elements
                                for (var i = 0; i < ele.length; i++) {
                                    this.addElement(ele[i]);
                                }
                            } else {
                                // single element
                                this.addElement(ele);
                            }
                        }
                        return this;
                    }
                }, {
                    key: 'addElement',
                    value: function addElement(ele) {
                        // ensure only HTML Element nodes
                        if (ele) {
                            if (ele.nativeElement) {
                                // angular ElementRef
                                ele = ele.nativeElement;
                            }
                            if (ele.nodeType === 1) {
                                this._el.push(ele);
                            }
                        }
                    }
                }, {
                    key: 'parent',
                    value: function parent(parentAnimation) {
                        this._parent = parentAnimation;
                        return this;
                    }
                }, {
                    key: 'add',
                    value: function add(childAnimations) {
                        childAnimations = Array.isArray(childAnimations) ? childAnimations : arguments;
                        for (var i = 0; i < childAnimations.length; i++) {
                            childAnimations[i].parent(this);
                            this._chld.push(childAnimations[i]);
                        }
                        return this;
                    }
                }, {
                    key: 'duration',
                    value: function duration(value) {
                        if (arguments.length) {
                            this._duration = value;
                            return this;
                        }
                        return this._duration || this._parent && this._parent.duration();
                    }
                }, {
                    key: 'easing',
                    value: function easing(name, opts) {
                        if (arguments.length) {
                            this._easing = {
                                name: name,
                                opts: opts
                            };
                            return this;
                        }
                        return this._easing || this._parent && this._parent.easing();
                    }
                }, {
                    key: 'playbackRate',
                    value: function playbackRate(value) {
                        if (arguments.length) {
                            this._rate = value;
                            var i = undefined;
                            for (i = 0; i < this._chld.length; i++) {
                                this._chld[i].playbackRate(value);
                            }
                            for (i = 0; i < this._ani.length; i++) {
                                this._ani[i].playbackRate(value);
                            }
                            return this;
                        }
                        return this._rate || this._parent && this._parent.playbackRate();
                    }
                }, {
                    key: 'from',
                    value: function from(property, value) {
                        if (!this._from) {
                            this._from = {};
                        }
                        this._from[property] = value;
                        return this;
                    }
                }, {
                    key: 'to',
                    value: function to(property, value) {
                        if (!this._to) {
                            this._to = {};
                        }
                        this._to[property] = value;
                        return this;
                    }
                }, {
                    key: 'fromTo',
                    value: function fromTo(property, from, to) {
                        return this.from(property, from).to(property, to);
                    }
                }, {
                    key: 'fadeIn',
                    value: function fadeIn() {
                        return this.fromTo('opacity', 0, 1);
                    }
                }, {
                    key: 'fadeOut',
                    value: function fadeOut() {
                        return this.fromTo('opacity', 1, 0);
                    }
                }, {
                    key: 'play',
                    value: function play() {
                        var _this = this;

                        var self = this;
                        var animations = self._ani;
                        var children = self._chld;
                        var promises = [];
                        var i = undefined,
                            l = undefined;
                        // the actual play() method which may or may not start async
                        function beginPlay() {
                            var i = undefined,
                                l = undefined;
                            var promises = [];
                            for (i = 0, l = children.length; i < l; i++) {
                                promises.push(children[i].play());
                            }
                            for (i = 0, l = animations.length; i < l; i++) {
                                promises.push(animations[i].play());
                            }
                            return Promise.all(promises);
                        }
                        if (!self._parent) {
                            var _ret = (function () {
                                var kickoff = function kickoff() {
                                    // synchronously call all onPlay()'s before play()
                                    self._onPlay();
                                    beginPlay().then(function () {
                                        self._onFinish();
                                        resolve();
                                    });
                                };

                                // this is the top level animation and is in full control
                                // of when the async play() should actually kick off
                                // stage all animations and child animations at their starting point
                                self.stage();
                                var resolve = undefined;
                                var promise = new Promise(function (res) {
                                    resolve = res;
                                });

                                if (_this._duration > RENDER_DELAY) {
                                    // begin each animation when everything is rendered in their starting point
                                    // give the browser some time to render everything in place before starting
                                    setTimeout(kickoff, RENDER_DELAY);
                                } else {
                                    // no need to render everything in there place before animating in
                                    // just kick it off immediately to render them in their "to" locations
                                    kickoff();
                                }
                                return {
                                    v: promise
                                };
                            })();

                            if (typeof _ret === 'object') return _ret.v;
                        }
                        // this is a child animation, it is told exactly when to
                        // start by the top level animation
                        return beginPlay();
                    }
                }, {
                    key: 'stage',
                    value: function stage() {
                        // before the RENDER_DELAY
                        // before the animations have started
                        if (!this._isStaged) {
                            this._isStaged = true;
                            var i = undefined,
                                p = undefined,
                                l = undefined,
                                j = undefined,
                                ele = undefined,
                                animation = undefined;
                            for (i = 0, l = this._chld.length; i < l; i++) {
                                this._chld[i].stage();
                            }
                            for (i = 0; i < this._el.length; i++) {
                                ele = this._el[i];
                                for (j = 0; j < this._bfAdd.length; j++) {
                                    ele.classList.add(this._bfAdd[j]);
                                }
                                for (p in this._bfSty) {
                                    ele.style[p] = this._bfSty[p];
                                }
                                for (j = 0; j < this._bfRmv.length; j++) {
                                    ele.classList.remove(this._bfRmv[j]);
                                }
                            }
                            if (this._to) {
                                // only animate the elements if there are defined "to" effects
                                for (i = 0; i < this._el.length; i++) {
                                    animation = new Animate(this._el[i], this._from, this._to, this.duration(), this.easing(), this.playbackRate());
                                    if (animation.shouldAnimate) {
                                        this._ani.push(animation);
                                    }
                                }
                            }
                            for (i = 0; i < this._readys.length; i++) {
                                this._readys[i](this);
                            }
                        }
                    }
                }, {
                    key: '_onPlay',
                    value: function _onPlay() {
                        // after the RENDER_DELAY
                        // before the animations have started
                        var i = undefined;
                        for (i = 0; i < this._chld.length; i++) {
                            this._chld[i]._onPlay();
                        }
                        for (i = 0; i < this._plays.length; i++) {
                            this._plays[i](this);
                        }
                    }
                }, {
                    key: '_onFinish',
                    value: function _onFinish() {
                        // after the animations have finished
                        if (!this._isFinished) {
                            this._isFinished = true;
                            var i = undefined,
                                j = undefined,
                                ele = undefined;
                            for (i = 0; i < this._chld.length; i++) {
                                this._chld[i]._onFinish();
                            }
                            if (this.playbackRate() < 0) {
                                // reverse direction
                                for (i = 0; i < this._el.length; i++) {
                                    ele = this._el[i];
                                    for (j = 0; j < this._bfAdd.length; j++) {
                                        ele.classList.remove(this._bfAdd[j]);
                                    }
                                    for (j = 0; j < this._bfRmv.length; j++) {
                                        ele.classList.add(this._bfRmv[j]);
                                    }
                                }
                            } else {
                                // normal direction
                                for (i = 0; i < this._el.length; i++) {
                                    ele = this._el[i];
                                    for (j = 0; j < this._afAdd.length; j++) {
                                        ele.classList.add(this._afAdd[j]);
                                    }
                                    for (j = 0; j < this._afRmv.length; j++) {
                                        ele.classList.remove(this._afRmv[j]);
                                    }
                                }
                            }
                            for (i = 0; i < this._finishes.length; i++) {
                                this._finishes[i](this);
                            }
                        }
                    }
                }, {
                    key: 'pause',
                    value: function pause() {
                        this._hasFinished = false;
                        var i = undefined;
                        for (i = 0; i < this._chld.length; i++) {
                            this._chld[i].pause();
                        }
                        for (i = 0; i < this._ani.length; i++) {
                            this._ani[i].pause();
                        }
                    }
                }, {
                    key: 'progress',
                    value: function progress(value) {
                        var i = undefined;
                        for (i = 0; i < this._chld.length; i++) {
                            this._chld[i].progress(value);
                        }
                        if (!this._initProgress) {
                            this._initProgress = true;
                            this.play();
                            this.pause();
                        }
                        for (i = 0; i < this._ani.length; i++) {
                            this._ani[i].progress(value);
                        }
                    }
                }, {
                    key: 'onReady',
                    value: function onReady(fn) {
                        this._readys.push(fn);
                    }
                }, {
                    key: 'onPlay',
                    value: function onPlay(fn) {
                        this._plays.push(fn);
                    }
                }, {
                    key: 'onFinish',
                    value: function onFinish(fn) {
                        this._finishes.push(fn);
                    }
                }, {
                    key: 'dispose',
                    value: function dispose() {
                        var i = undefined;
                        for (i = 0; i < this._chld.length; i++) {
                            this._chld[i].dispose();
                        }
                        for (i = 0; i < this._ani.length; i++) {
                            this._ani[i].dispose();
                        }
                        this._el = this._parent = this._chld = this._ani = this._readys = this._plays = this._finishes = null;
                    }
                }, {
                    key: 'before',
                    get: function get() {
                        var _this2 = this;

                        return {
                            addClass: function addClass(className) {
                                _this2._bfAdd.push(className);
                                return _this2;
                            },
                            removeClass: function removeClass(className) {
                                _this2._bfRmv.push(className);
                                return _this2;
                            },
                            setStyles: function setStyles(styles) {
                                _this2._bfSty = styles;
                            }
                        };
                    }
                }, {
                    key: 'after',
                    get: function get() {
                        var _this3 = this;

                        return {
                            addClass: function addClass(className) {
                                _this3._afAdd.push(className);
                                return _this3;
                            },
                            removeClass: function removeClass(className) {
                                _this3._afRmv.push(className);
                                return _this3;
                            }
                        };
                    }
                }], [{
                    key: 'create',

                    /*
                     STATIC CLASSES
                     */
                    value: function create(element, name) {
                        var AnimationClass = AnimationRegistry[name];
                        if (!AnimationClass) {
                            // couldn't find an animation by the given name
                            // fallback to just the base Animation class
                            AnimationClass = Animation;
                        }
                        return new AnimationClass(element);
                    }
                }, {
                    key: 'register',
                    value: function register(name, AnimationClass) {
                        AnimationRegistry[name] = AnimationClass;
                    }
                }]);

                return Animation;
            })();

            _export('Animation', Animation);

            Animate = (function () {
                function Animate(ele, fromEffect, toEffect, duration, easingConfig, playbackRate) {
                    var _this4 = this;

                    _classCallCheck(this, Animate);

                    // https://w3c.github.io/web-animations/
                    // not using the direct API methods because they're still in flux
                    // however, element.animate() seems locked in and uses the latest
                    // and correct API methods under the hood, so really doesn't matter
                    this.toEffect = parseEffect(toEffect);
                    this.shouldAnimate = duration > RENDER_DELAY;
                    if (!this.shouldAnimate) {
                        return inlineStyle(ele, this.toEffect);
                    }
                    this.ele = ele;
                    this.promise = new Promise(function (res) {
                        _this4.resolve = res;
                    });
                    // stage where the element will start from
                    fromEffect = parseEffect(fromEffect);
                    inlineStyle(ele, fromEffect);
                    this.duration = duration;
                    this.rate = playbackRate;
                    this.easing = easingConfig && easingConfig.name || 'linear';
                    this.effects = [convertProperties(fromEffect)];
                    if (this.easing in EASING_FN) {
                        insertEffects(this.effects, fromEffect, this.toEffect, easingConfig);
                    } else if (this.easing in CUBIC_BEZIERS) {
                        this.easing = 'cubic-bezier(' + CUBIC_BEZIERS[this.easing] + ')';
                    }
                    this.effects.push(convertProperties(this.toEffect));
                }

                _createClass(Animate, [{
                    key: 'play',
                    value: function play() {
                        var self = this;
                        if (self.player) {
                            self.player.play();
                        } else {
                            self.player = self.ele.animate(self.effects, {
                                duration: self.duration || 0,
                                easing: self.easing,
                                playbackRate: self.rate || 1
                            });
                            self.player.onfinish = function () {
                                // lock in where the element will stop at
                                // if the playbackRate is negative then it needs to return
                                // to its "from" effects
                                inlineStyle(self.ele, self.rate < 0 ? self.fromEffect : self.toEffect);
                                self.resolve();
                            };
                        }
                        return self.promise;
                    }
                }, {
                    key: 'pause',
                    value: function pause() {
                        this.player && this.player.pause();
                    }
                }, {
                    key: 'progress',
                    value: function progress(value) {
                        var player = this.player;
                        if (player) {
                            // passed a number between 0 and 1
                            value = Math.max(0, Math.min(1, value));
                            if (value >= 1) {
                                player.currentTime = this.duration * 0.999;
                                return player.play();
                            }
                            if (player.playState !== 'paused') {
                                player.pause();
                            }
                            player.currentTime = this.duration * value;
                        }
                    }
                }, {
                    key: 'playbackRate',
                    value: function playbackRate(value) {
                        this.rate = value;
                        if (this.player) {
                            this.player.playbackRate = value;
                        }
                    }
                }, {
                    key: 'dispose',
                    value: function dispose() {
                        this.ele = this.player = this.effects = this.toEffect = null;
                    }
                }]);

                return Animate;
            })();

            TRANSFORMS = ['translateX', 'translateY', 'translateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'skewX', 'skewY', 'perspective'];
            ANIMATE_PROPERTIES = TRANSFORMS.concat('opacity');

            // Robert Penner's Easing Functions
            // http://robertpenner.com/easing/
            CUBIC_BEZIERS = {
                // default browser suppored easing
                // ease
                // ease-in
                // ease-out
                // ease-in-out
                // Cubic
                'ease-in-cubic': '0.55,0.055,0.675,0.19',
                'ease-out-cubic': '0.215,0.61,0.355,1',
                'ease-in-Out-cubic': '0.645,0.045,0.355,1',
                // Circ
                'ease-in-circ': '0.6,0.04,0.98,0.335',
                'ease-out-circ': '0.075,0.82,0.165,1',
                'ease-in-out-circ': '0.785,0.135,0.15,0.86',
                // Expo
                'ease-in-expo': '0.95,0.05,0.795,0.035',
                'ease-out-expo': '0.19,1,0.22,1',
                'ease-in-out-expo': '1,0,0,1',
                // Quad
                'ease-in-quad': '0.55,0.085,0.68,0.53',
                'ease-out-quad': '0.25,0.46,0.45,0.94',
                'ease-in-out-quad': '0.455,0.03,0.515,0.955',
                // Quart
                'ease-in-quart': '0.895,0.03,0.685,0.22',
                'ease-out-quart': '0.165,0.84,0.44,1',
                'ease-in-out-quart': '0.77,0,0.175,1',
                // Quint
                'ease-in-quint': '0.755,0.05,0.855,0.06',
                'ease-out-quint': '0.23,1,0.32,1',
                'ease-in-out-quint': '0.86,0,0.07,1',
                // Sine
                'ease-in-sine': '0.47,0,0.745,0.715',
                'ease-out-sine': '0.39,0.575,0.565,1',
                'ease-in-out-sine': '0.445,0.05,0.55,0.95',
                // Back
                'ease-in-back': '0.6,-0.28,0.735,0.045',
                'ease-out-back': '0.175,0.885,0.32,1.275',
                'ease-in-out-back': '0.68,-0.55,0.265,1.55'
            };
            EASING_FN = {
                'elastic': function elastic(pos) {
                    return -1 * Math.pow(4, -8 * pos) * Math.sin((pos * 6 - 1) * (2 * Math.PI) / 2) + 1;
                },
                'swing-from-to': function swingFromTo(pos, opts) {
                    var s = opts.s || 1.70158;
                    return (pos /= 0.5) < 1 ? 0.5 * (pos * pos * (((s *= 1.525) + 1) * pos - s)) : 0.5 * ((pos -= 2) * pos * (((s *= 1.525) + 1) * pos + s) + 2);
                },
                'swing-from': function swingFrom(pos, opts) {
                    var s = opts.s || 1.70158;
                    return pos * pos * ((s + 1) * pos - s);
                },
                'swing-to': function swingTo(pos, opts) {
                    var s = opts.s || 1.70158;
                    return (pos -= 1) * pos * ((s + 1) * pos + s) + 1;
                },
                'bounce': function bounce(pos) {
                    if (pos < 1 / 2.75) {
                        return 7.5625 * pos * pos;
                    } else if (pos < 2 / 2.75) {
                        return 7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75;
                    } else if (pos < 2.5 / 2.75) {
                        return 7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375;
                    }
                    return 7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375;
                },
                'bounce-past': function bouncePast(pos) {
                    if (pos < 1 / 2.75) {
                        return 7.5625 * pos * pos;
                    } else if (pos < 2 / 2.75) {
                        return 2 - (7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75);
                    } else if (pos < 2.5 / 2.75) {
                        return 2 - (7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375);
                    }
                    return 2 - (7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375);
                },
                'ease-out-bounce': function easeOutBounce(pos) {
                    if (pos < 1 / 2.75) {
                        return 7.5625 * pos * pos;
                    } else if (pos < 2 / 2.75) {
                        return 7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75;
                    } else if (pos < 2.5 / 2.75) {
                        return 7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375;
                    }
                    return 7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375;
                },
                'ease-from-to': function easeFromTo(pos) {
                    if ((pos /= 0.5) < 1) return 0.5 * Math.pow(pos, 4);
                    return -0.5 * ((pos -= 2) * Math.pow(pos, 3) - 2);
                },
                'ease-from': function easeFrom(pos, opts) {
                    return Math.pow(pos, opts.s || 4);
                },
                'ease-to': function easeTo(pos, opts) {
                    return Math.pow(pos, opts.s || 0.25);
                },
                /*
                 * scripty2, Thomas Fuchs (MIT Licence)
                 * https://raw.github.com/madrobby/scripty2/master/src/effects/transitions/transitions.js
                 */
                'spring': function spring(pos, opts) {
                    var damping = opts.damping || 4.5;
                    var elasticity = opts.elasticity || 6;
                    return 1 - Math.cos(pos * damping * Math.PI) * Math.exp(-pos * elasticity);
                },
                'sinusoidal': function sinusoidal(pos) {
                    return -Math.cos(pos * Math.PI) / 2 + 0.5;
                }
            };
        }
    };
});
System.register('ionic/animations/builtins', ['./animation'], function (_export) {
    'use strict';

    var Animation, SlideIn, SlideOut, FadeIn, FadeOut;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_animation) {
            Animation = _animation.Animation;
        }],
        execute: function () {
            SlideIn = (function (_Animation) {
                function SlideIn(element) {
                    _classCallCheck(this, SlideIn);

                    _get(Object.getPrototypeOf(SlideIn.prototype), 'constructor', this).call(this, element);
                    this.easing('cubic-bezier(0.1,0.7,0.1,1)').duration(400).fromTo('translateY', '100%', '0%');
                }

                _inherits(SlideIn, _Animation);

                return SlideIn;
            })(Animation);

            Animation.register('slide-in', SlideIn);

            SlideOut = (function (_Animation2) {
                function SlideOut(element) {
                    _classCallCheck(this, SlideOut);

                    _get(Object.getPrototypeOf(SlideOut.prototype), 'constructor', this).call(this, element);
                    this.easing('ease-out').duration(250).fromTo('translateY', '0%', '100%');
                }

                _inherits(SlideOut, _Animation2);

                return SlideOut;
            })(Animation);

            Animation.register('slide-out', SlideOut);

            FadeIn = (function (_Animation3) {
                function FadeIn(element) {
                    _classCallCheck(this, FadeIn);

                    _get(Object.getPrototypeOf(FadeIn.prototype), 'constructor', this).call(this, element);
                    this.easing('ease-in').duration(400).fadeIn();
                }

                _inherits(FadeIn, _Animation3);

                return FadeIn;
            })(Animation);

            Animation.register('fade-in', FadeIn);

            FadeOut = (function (_Animation4) {
                function FadeOut(element) {
                    _classCallCheck(this, FadeOut);

                    _get(Object.getPrototypeOf(FadeOut.prototype), 'constructor', this).call(this, element);
                    this.easing('ease-out').duration(250).fadeOut();
                }

                _inherits(FadeOut, _Animation4);

                return FadeOut;
            })(Animation);

            Animation.register('fade-out', FadeOut);
        }
    };
});
System.register('ionic/animations/scroll-to', ['../util/dom'], function (_export) {
    'use strict';

    var raf, ScrollTo;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_utilDom) {
            raf = _utilDom.raf;
        }],
        execute: function () {
            ScrollTo = (function () {
                function ScrollTo(ele, x, y, duration) {
                    _classCallCheck(this, ScrollTo);

                    if (typeof ele === 'string') {
                        // string query selector
                        ele = document.querySelector(ele);
                    }
                    if (ele) {
                        if (ele.nativeElement) {
                            // angular ElementRef
                            ele = ele.nativeElement;
                        }
                        if (ele.nodeType === 1) {
                            this._el = ele;
                        }
                    }
                }

                _createClass(ScrollTo, [{
                    key: 'start',
                    value: function start(x, y, duration, tolerance) {
                        // scroll animation loop w/ easing
                        // credit https://gist.github.com/dezinezync/5487119
                        var self = this;
                        if (!self._el) {
                            // invalid element
                            return Promise.resolve();
                        }
                        x = x || 0;
                        y = y || 0;
                        tolerance = tolerance || 0;
                        var ele = self._el;
                        var fromY = ele.scrollTop;
                        var fromX = ele.scrollLeft;
                        var xDistance = Math.abs(x - fromX);
                        var yDistance = Math.abs(y - fromY);
                        if (yDistance <= tolerance && xDistance <= tolerance) {
                            // prevent scrolling if already close to there
                            this._el = ele = null;
                            return Promise.resolve();
                        }
                        return new Promise(function (resolve, reject) {
                            var start = Date.now();
                            // start scroll loop
                            self.isPlaying = true;
                            raf(step);
                            // decelerating to zero velocity
                            function easeOutCubic(t) {
                                return --t * t * t + 1;
                            }
                            // scroll loop
                            function step() {
                                var time = Math.min(1, (Date.now() - start) / duration);
                                // where .5 would be 50% of time on a linear scale easedT gives a
                                // fraction based on the easing method
                                var easedT = easeOutCubic(time);
                                if (fromY != y) {
                                    ele.scrollTop = parseInt(easedT * (y - fromY) + fromY, 10);
                                }
                                if (fromX != x) {
                                    ele.scrollLeft = parseInt(easedT * (x - fromX) + fromX, 10);
                                }
                                if (time < 1 && self.isPlaying) {
                                    raf(step);
                                } else if (!self.isPlaying) {
                                    // stopped
                                    this._el = ele = null;
                                    reject();
                                } else {
                                    // done
                                    this._el = ele = null;
                                    resolve();
                                }
                            }
                        });
                    }
                }, {
                    key: 'stop',
                    value: function stop() {
                        this.isPlaying = false;
                    }
                }, {
                    key: 'dispose',
                    value: function dispose() {
                        this.stop();
                        this._el = null;
                    }
                }]);

                return ScrollTo;
            })();

            _export('ScrollTo', ScrollTo);
        }
    };
});
System.register('ionic/config/annotations', ['angular2/angular2', 'ionic/util', '../components/app/app', '../ionic'], function (_export) {
    'use strict';

    var coreDirectives, formDirectives, Component, Directive, View, forwardRef, util, ionicBootstrap, Aside, Button, Content, Scroll, Refresher, Slides, Slide, SlidePager, Tabs, Tab, Card, List, Item, ItemGroup, ItemGroupTitle, Toolbar, Icon, IconDirective, Checkbox, TapInput, Switch, Input, TextInput, Label, Segment, SegmentButton, SegmentControlValueAccessor, RadioGroup, RadioButton, Nav, NavbarTemplate, Navbar, NavPush, NavPop, TapClick, TapDisabled, Register, ShowWhen, HideWhen, MaterialButton, IonicDirectives, IonicViewImpl;

    var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    _export('IonicView', IonicView);

    _export('IonicDirective', IonicDirective);

    _export('IonicComponent', IonicComponent);

    _export('App', App);

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    function IonicView(args) {
        return function (cls) {
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            annotations.push(new IonicViewImpl(args));
            Reflect.defineMetadata('annotations', annotations, cls);
            return cls;
        };
    }

    function IonicDirective(config) {
        return function (cls) {
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            annotations.push(new Directive(appendConfig(cls, config)));
            Reflect.defineMetadata('annotations', annotations, cls);
            return cls;
        };
    }

    function IonicComponent(config) {
        return function (cls) {
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            annotations.push(new Component(appendConfig(cls, config)));
            Reflect.defineMetadata('annotations', annotations, cls);
            return cls;
        };
    }

    function appendConfig(cls, config) {
        config.host = config.host || {};
        cls.defaultProperties = config.defaultProperties || {};
        config.properties = config.properties || [];
        for (var prop in cls.defaultProperties) {
            // add the property to the component "properties"
            config.properties.push(prop);
            // set the component "hostProperties", so the instance's
            // property value will be used to set the element's attribute
            config.host['[attr.' + util.pascalCaseToDashCase(prop) + ']'] = prop;
        }
        cls.delegates = config.delegates;
        var componentId = config.classId || config.selector && config.selector.replace('ion-', '');
        config.host['class'] = ((config.host['class'] || '') + ' ' + componentId).trim();
        // the mode will get figured out when the component is constructed
        config.host['[attr.mode]'] = 'clsMode';
        return config;
    }

    function App() {
        var args = arguments[0] === undefined ? {} : arguments[0];

        return function (cls) {
            // get current annotations
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            // create @Component
            args.selector = args.selector || 'ion-app';
            annotations.push(new Component(args));
            // create @View
            // if no template was provided, default so it has a root ion-nav
            if (!args.templateUrl && !args.template) {
                args.template = '<ion-nav></ion-nav>';
            }
            annotations.push(new IonicViewImpl(args));
            // redefine with added annotations
            Reflect.defineMetadata('annotations', annotations, cls);
            ionicBootstrap(cls, args.config, args.routes);
            return cls;
        };
    }

    return {
        setters: [function (_angular2Angular2) {
            coreDirectives = _angular2Angular2.coreDirectives;
            formDirectives = _angular2Angular2.formDirectives;
            Component = _angular2Angular2.Component;
            Directive = _angular2Angular2.Directive;
            View = _angular2Angular2.View;
            forwardRef = _angular2Angular2.forwardRef;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_componentsAppApp) {
            ionicBootstrap = _componentsAppApp.ionicBootstrap;
        }, function (_ionic) {
            Aside = _ionic.Aside;
            Button = _ionic.Button;
            Content = _ionic.Content;
            Scroll = _ionic.Scroll;
            Refresher = _ionic.Refresher;
            Slides = _ionic.Slides;
            Slide = _ionic.Slide;
            SlidePager = _ionic.SlidePager;
            Tabs = _ionic.Tabs;
            Tab = _ionic.Tab;
            Card = _ionic.Card;
            List = _ionic.List;
            Item = _ionic.Item;
            ItemGroup = _ionic.ItemGroup;
            ItemGroupTitle = _ionic.ItemGroupTitle;
            Toolbar = _ionic.Toolbar;
            Icon = _ionic.Icon;
            IconDirective = _ionic.IconDirective;
            Checkbox = _ionic.Checkbox;
            TapInput = _ionic.TapInput;
            Switch = _ionic.Switch;
            Input = _ionic.Input;
            TextInput = _ionic.TextInput;
            Label = _ionic.Label;
            Segment = _ionic.Segment;
            SegmentButton = _ionic.SegmentButton;
            SegmentControlValueAccessor = _ionic.SegmentControlValueAccessor;
            RadioGroup = _ionic.RadioGroup;
            RadioButton = _ionic.RadioButton;
            Nav = _ionic.Nav;
            NavbarTemplate = _ionic.NavbarTemplate;
            Navbar = _ionic.Navbar;
            NavPush = _ionic.NavPush;
            NavPop = _ionic.NavPop;
            TapClick = _ionic.TapClick;
            TapDisabled = _ionic.TapDisabled;
            Register = _ionic.Register;
            ShowWhen = _ionic.ShowWhen;
            HideWhen = _ionic.HideWhen;
            MaterialButton = _ionic.MaterialButton;
        }],
        execute: function () {
            // TODO: Why is forwardRef() required when they're already imported above????
            IonicDirectives = [
            // Angular
            coreDirectives, formDirectives,
            // Content
            forwardRef(function () {
                return Aside;
            }), forwardRef(function () {
                return Button;
            }), forwardRef(function () {
                return Content;
            }), forwardRef(function () {
                return Scroll;
            }), forwardRef(function () {
                return Refresher;
            }),
            // Lists
            forwardRef(function () {
                return Card;
            }), forwardRef(function () {
                return List;
            }), forwardRef(function () {
                return Item;
            }), forwardRef(function () {
                return ItemGroup;
            }), forwardRef(function () {
                return ItemGroupTitle;
            }),
            // Slides
            forwardRef(function () {
                return Slides;
            }), forwardRef(function () {
                return Slide;
            }), forwardRef(function () {
                return SlidePager;
            }),
            // Tabs
            forwardRef(function () {
                return Tabs;
            }), forwardRef(function () {
                return Tab;
            }), forwardRef(function () {
                return Toolbar;
            }),
            // Media
            forwardRef(function () {
                return Icon;
            }), forwardRef(function () {
                return IconDirective;
            }),
            // Form
            forwardRef(function () {
                return Segment;
            }), forwardRef(function () {
                return SegmentButton;
            }), forwardRef(function () {
                return SegmentControlValueAccessor;
            }), forwardRef(function () {
                return Checkbox;
            }), forwardRef(function () {
                return RadioGroup;
            }), forwardRef(function () {
                return RadioButton;
            }), forwardRef(function () {
                return Switch;
            }),
            //SearchBar,
            // Input
            forwardRef(function () {
                return Input;
            }), forwardRef(function () {
                return TextInput;
            }), forwardRef(function () {
                return TapInput;
            }), forwardRef(function () {
                return Label;
            }),
            // Nav
            forwardRef(function () {
                return Nav;
            }), forwardRef(function () {
                return NavbarTemplate;
            }), forwardRef(function () {
                return Navbar;
            }), forwardRef(function () {
                return NavPush;
            }), forwardRef(function () {
                return NavPop;
            }), forwardRef(function () {
                return Register;
            }), forwardRef(function () {
                return ShowWhen;
            }), forwardRef(function () {
                return HideWhen;
            }),
            // Gestures
            forwardRef(function () {
                return TapClick;
            }), forwardRef(function () {
                return TapDisabled;
            }),
            // Material
            forwardRef(function () {
                return MaterialButton;
            })];

            _export('IonicDirectives', IonicDirectives);

            IonicViewImpl = (function (_View) {
                function IonicViewImpl() {
                    var args = arguments[0] === undefined ? {} : arguments[0];

                    _classCallCheck(this, IonicViewImpl);

                    args.directives = (args.directives || []).concat(IonicDirectives);
                    _get(Object.getPrototypeOf(IonicViewImpl.prototype), 'constructor', this).call(this, args);
                }

                _inherits(IonicViewImpl, _View);

                return IonicViewImpl;
            })(View);
        }
    };
});
System.register('ionic/config/config', ['../util/util'], function (_export) {
    'use strict';

    var isObject, isDefined, isFunction, extend, IonicConfig, globalConfig;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_utilUtil) {
            isObject = _utilUtil.isObject;
            isDefined = _utilUtil.isDefined;
            isFunction = _utilUtil.isFunction;
            extend = _utilUtil.extend;
        }],
        execute: function () {
            /**
            * This is the Ionic Config
            * @usage this is what you do to use it
            */

            IonicConfig = (function () {
                function IonicConfig(settings) {
                    _classCallCheck(this, IonicConfig);

                    // defaults
                    this._settings = {};
                    // override defaults w/ user config
                    if (settings) {
                        extend(this._settings, settings);
                    }
                }

                _createClass(IonicConfig, [{
                    key: 'setting',

                    /**
                    * @description The settings description
                    */
                    value: function setting() {
                        var args = arguments;
                        var arg0 = args[0];
                        var arg1 = args[1];
                        var settings = this._settings;
                        switch (args.length) {
                            case 0:
                                // setting() = get settings object
                                return settings;
                            case 1:
                                // setting({...}) = set settings object
                                // setting('key') = get value
                                if (isObject(arg0)) {
                                    // setting({...}) = set settings object
                                    // arg0 = setting object
                                    this._settings = arg0;
                                    return this;
                                }
                                // time for the big show, get the value
                                // setting('key') = get value
                                // arg0 = key
                                if (!isDefined(settings[arg0])) {
                                    // if the value was already set this will all be skipped
                                    // if there was no user config then it'll check each of
                                    // the user config's platforms, which already contains
                                    // settings from default platform configs
                                    settings[arg0] = null;
                                    // check the platform settings object for this value
                                    // loop though each of the active platforms
                                    var activePlatformKeys = this._platforms;
                                    var platformSettings = settings.platforms;
                                    var platformObj = null;
                                    if (platformSettings) {
                                        var platformValue = undefined;
                                        for (var i = 0; i < activePlatformKeys.length; i++) {
                                            platformObj = platformSettings[activePlatformKeys[i]];
                                            if (platformObj && isDefined(platformObj[arg0])) {
                                                platformValue = platformObj[arg0];
                                            }
                                        }
                                        if (isDefined(platformValue)) {
                                            settings[arg0] = platformValue;
                                        }
                                    }
                                }
                                // return key's value
                                // either it came directly from the user config
                                // or it was from the users platform configs
                                // or it was from the default platform configs
                                // in that order
                                if (isFunction(settings[arg0])) {
                                    settings[arg0] = settings[arg0]();
                                }
                                return settings[arg0];
                            case 2:
                                // setting('ios', {...}) = set platform config object
                                // setting('key', 'value') = set key/value pair
                                if (isObject(arg1)) {
                                    // setting('ios', {...}) = set platform config object
                                    // arg0 = platform
                                    // arg1 = platform config object
                                    settings.platforms = settings.platforms || {};
                                    settings.platforms[arg0] = arg1;
                                } else {
                                    // setting('key', 'value') = set key/value pair
                                    // arg0 = key
                                    // arg1 = value
                                    settings[arg0] = arg1;
                                }
                                return this;
                            case 3:
                                // setting('ios', 'key', 'value') = set key/value pair for platform
                                // arg0 = platform
                                // arg1 = key
                                // arg2 = value
                                settings.platforms = settings.platforms || {};
                                settings.platforms[arg0] = settings.platforms[arg0] || {};
                                settings.platforms[arg0][arg1] = args[2];
                                return this;
                        }
                    }
                }, {
                    key: 'setPlatform',

                    /**
                     * The setPlatform description
                     */
                    value: function setPlatform(platform) {
                        // get the array of active platforms, which also knows the hierarchy,
                        // with the last one the most important
                        this._platforms = platform.platforms();
                        // copy default platform settings into the user config platform settings
                        // user config platform settings should override default platform settings
                        this._settings.platforms = extend(platform.settings(), this._settings.platforms || {});
                    }
                }], [{
                    key: 'global',
                    set: function set(config) {
                        globalConfig = config;
                    },
                    get: function get() {
                        return globalConfig;
                    }
                }]);

                return IonicConfig;
            })();

            _export('IonicConfig', IonicConfig);

            globalConfig = null;
        }
    };
});
System.register('ionic/gestures/drag-gesture', ['ionic/gestures/gesture', 'ionic/util'], function (_export) {
    'use strict';

    var Gesture, util, DragGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_ionicGesturesGesture) {
            Gesture = _ionicGesturesGesture.Gesture;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            //import Hammer from 'hammer';
            /*
             * BUG(ajoslin): HammerJS 2.x does not have an alternative to HammerJS 1.x's
             * dragLockToAxis, so a vertical and horizontal gesture can happen at the same time.
             */

            DragGesture = (function (_Gesture) {
                function DragGesture(element) {
                    var opts = arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, DragGesture);

                    util.defaults(opts, {});
                    _get(Object.getPrototypeOf(DragGesture.prototype), 'constructor', this).call(this, element, opts);
                }

                _inherits(DragGesture, _Gesture);

                _createClass(DragGesture, [{
                    key: 'listen',
                    value: function listen() {
                        var _this = this;

                        _get(Object.getPrototypeOf(DragGesture.prototype), 'listen', this).call(this);
                        this.on('panstart', function (ev) {
                            if (_this.onDragStart(ev) !== false) {
                                _this.dragging = true;
                            }
                            // ev.stopPropagation();
                        });
                        this.on('panmove', function (ev) {
                            if (!_this.dragging) return;
                            if (_this.onDrag(ev) === false) {
                                _this.dragging = false;
                            }
                            // ev.stopPropagation()
                        });
                        this.on('panend', function (ev) {
                            if (!_this.dragging) return;
                            _this.onDragEnd(ev);
                            _this.dragging = false;
                            // ev.stopPropagation()
                        });
                    }
                }, {
                    key: 'onDrag',
                    value: function onDrag() {}
                }, {
                    key: 'onDragStart',
                    value: function onDragStart() {}
                }, {
                    key: 'onDragEnd',
                    value: function onDragEnd() {}
                }]);

                return DragGesture;
            })(Gesture);

            _export('DragGesture', DragGesture);
        }
    };
});
System.register('ionic/gestures/gesture', ['ionic/util', 'ionic/gestures/hammer'], function (_export) {
    'use strict';

    var util, Hammer, Gesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_ionicGesturesHammer) {
            Hammer = _ionicGesturesHammer.Hammer;
        }],
        execute: function () {
            Gesture = (function () {
                function Gesture(element) {
                    var opts = arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, Gesture);

                    util.defaults(opts, {
                        domEvents: true
                    });
                    this.element = element;
                    // Map 'x' or 'y' string to hammerjs opts
                    this.direction = opts.direction || 'x';
                    opts.direction = this.direction === 'x' ? Hammer.DIRECTION_HORIZONTAL : Hammer.DIRECTION_VERTICAL;
                    this._options = opts;
                    this._callbacks = {};
                }

                _createClass(Gesture, [{
                    key: 'options',
                    value: function options() {
                        var opts = arguments[0] === undefined ? {} : arguments[0];

                        util.extend(this._options, opts);
                    }
                }, {
                    key: 'on',
                    value: function on(type, cb) {
                        this.hammertime.on(type, util.noop);
                        (this._callbacks[type] || (this._callbacks[type] = [])).push(cb);
                        this.element.addEventListener(type, cb);
                    }
                }, {
                    key: 'listen',
                    value: function listen() {
                        this.hammertime = Hammer(this.element, this._options);
                    }
                }, {
                    key: 'unlisten',
                    value: function unlisten() {
                        this.hammertime.destroy();
                        this.hammertime = null;
                        for (var type in this._callbacks) {
                            for (var i = 0; i < this._callbacks[type].length; i++) {
                                this.element.removeEventListener(type, this._callbacks[type][i]);
                            }
                        }
                        this._callbacks = {};
                    }
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        this.unlisten();
                    }
                }]);

                return Gesture;
            })();

            _export('Gesture', Gesture);
        }
    };
});
System.register('ionic/gestures/hammer', [], function (_export) {
    /*! Hammer.JS - v2.0.4 - 2014-09-28
     * http://hammerjs.github.io/
     *
     * Copyright (c) 2014 Jorik Tangelder;
     * Licensed under the MIT license */
    //(function(window, document, exportName, undefined) {
    //'use strict';
    'use strict';

    var VENDOR_PREFIXES, TEST_ELEMENT, TYPE_FUNCTION, round, abs, now, _uniqueId, MOBILE_REGEX, SUPPORT_TOUCH, SUPPORT_POINTER_EVENTS, SUPPORT_ONLY_TOUCH, INPUT_TYPE_TOUCH, INPUT_TYPE_PEN, INPUT_TYPE_MOUSE, INPUT_TYPE_KINECT, COMPUTE_INTERVAL, INPUT_START, INPUT_MOVE, INPUT_END, INPUT_CANCEL, DIRECTION_NONE, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_UP, DIRECTION_DOWN, DIRECTION_HORIZONTAL, DIRECTION_VERTICAL, DIRECTION_ALL, PROPS_XY, PROPS_CLIENT_XY, MOUSE_INPUT_MAP, MOUSE_ELEMENT_EVENTS, MOUSE_WINDOW_EVENTS, POINTER_INPUT_MAP, IE10_POINTER_TYPE_ENUM, POINTER_ELEMENT_EVENTS, POINTER_WINDOW_EVENTS, SINGLE_TOUCH_INPUT_MAP, SINGLE_TOUCH_TARGET_EVENTS, SINGLE_TOUCH_WINDOW_EVENTS, TOUCH_INPUT_MAP, TOUCH_TARGET_EVENTS, PREFIXED_TOUCH_ACTION, NATIVE_TOUCH_ACTION, TOUCH_ACTION_COMPUTE, TOUCH_ACTION_AUTO, TOUCH_ACTION_MANIPULATION, TOUCH_ACTION_NONE, TOUCH_ACTION_PAN_X, TOUCH_ACTION_PAN_Y, STATE_POSSIBLE, STATE_BEGAN, STATE_CHANGED, STATE_ENDED, STATE_RECOGNIZED, STATE_CANCELLED, STATE_FAILED, STOP, FORCED_STOP;

    /**
     * set a timeout with a given scope
     * @param {Function} fn
     * @param {Number} timeout
     * @param {Object} context
     * @returns {number}
     */
    function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
    }
    /**
     * if the argument is an array, we want to execute the fn on each entry
     * if it aint an array we don't want to do a thing.
     * this is used by all the methods that accept a single and array argument.
     * @param {*|Array} arg
     * @param {String} fn
     * @param {Object} [context]
     * @returns {Boolean}
     */
    function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
        }
        return false;
    }
    /**
     * walk objects and arrays
     * @param {Object} obj
     * @param {Function} iterator
     * @param {Object} context
     */
    function each(obj, iterator, context) {
        var i;
        if (!obj) {
            return;
        }
        if (obj.forEach) {
            obj.forEach(iterator, context);
        } else if (obj.length !== undefined) {
            i = 0;
            while (i < obj.length) {
                iterator.call(context, obj[i], i, obj);
                i++;
            }
        } else {
            for (i in obj) {
                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
            }
        }
    }
    /**
     * extend object.
     * means that properties in dest will be overwritten by the ones in src.
     * @param {Object} dest
     * @param {Object} src
     * @param {Boolean} [merge]
     * @returns {Object} dest
     */
    function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
            if (!merge || merge && dest[keys[i]] === undefined) {
                dest[keys[i]] = src[keys[i]];
            }
            i++;
        }
        return dest;
    }
    /**
     * merge the values from src in the dest.
     * means that properties that exist in dest will not be overwritten by src
     * @param {Object} dest
     * @param {Object} src
     * @returns {Object} dest
     */
    function merge(dest, src) {
        return extend(dest, src, true);
    }
    /**
     * simple class inheritance
     * @param {Function} child
     * @param {Function} base
     * @param {Object} [properties]
     */
    function inherit(child, base, properties) {
        var baseP = base.prototype,
            childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) {
            extend(childP, properties);
        }
    }
    /**
     * simple function bind
     * @param {Function} fn
     * @param {Object} context
     * @returns {Function}
     */
    function bindFn(fn, context) {
        return function boundFn() {
            return fn.apply(context, arguments);
        };
    }
    /**
     * let a boolean value also be a function that must return a boolean
     * this first item in args will be used as the context
     * @param {Boolean|Function} val
     * @param {Array} [args]
     * @returns {Boolean}
     */
    function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
            return val.apply(args ? args[0] || undefined : undefined, args);
        }
        return val;
    }
    /**
     * use the val2 when val1 is undefined
     * @param {*} val1
     * @param {*} val2
     * @returns {*}
     */
    function ifUndefined(val1, val2) {
        return val1 === undefined ? val2 : val1;
    }
    /**
     * addEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function addEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
            target.addEventListener(type, handler, false);
        });
    }
    /**
     * removeEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function removeEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
            target.removeEventListener(type, handler, false);
        });
    }
    /**
     * find if a node is in the given parent
     * @method hasParent
     * @param {HTMLElement} node
     * @param {HTMLElement} parent
     * @return {Boolean} found
     */
    function hasParent(node, parent) {
        while (node) {
            if (node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    }
    /**
     * small indexOf wrapper
     * @param {String} str
     * @param {String} find
     * @returns {Boolean} found
     */
    function inStr(str, find) {
        return str.indexOf(find) > -1;
    }
    /**
     * split string on whitespace
     * @param {String} str
     * @returns {Array} words
     */
    function splitStr(str) {
        return str.trim().split(/\s+/g);
    }
    /**
     * find if a array contains the object using indexOf or a simple polyFill
     * @param {Array} src
     * @param {String} find
     * @param {String} [findByKey]
     * @return {Boolean|Number} false when not found, or the index
     */
    function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
            return src.indexOf(find);
        } else {
            var i = 0;
            while (i < src.length) {
                if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
                    return i;
                }
                i++;
            }
            return -1;
        }
    }
    /**
     * convert array-like objects to real arrays
     * @param {Object} obj
     * @returns {Array}
     */
    function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
    }
    /**
     * unique array with objects based on a key (like 'id') or just by the array's value
     * @param {Array} src [{id:1},{id:2},{id:1}]
     * @param {String} [key]
     * @param {Boolean} [sort=False]
     * @returns {Array} [{id:1},{id:2}]
     */
    function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while (i < src.length) {
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) {
                results.push(src[i]);
            }
            values[i] = val;
            i++;
        }
        if (sort) {
            if (!key) {
                results = results.sort();
            } else {
                results = results.sort(function sortUniqueArray(a, b) {
                    return a[key] > b[key];
                });
            }
        }
        return results;
    }
    /**
     * get the prefixed property
     * @param {Object} obj
     * @param {String} property
     * @returns {String|Undefined} prefixed
     */
    function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i];
            prop = prefix ? prefix + camelProp : property;
            if (prop in obj) {
                return prop;
            }
            i++;
        }
        return undefined;
    }

    function uniqueId() {
        return _uniqueId++;
    }
    /**
     * get the window object of an element
     * @param {HTMLElement} element
     * @returns {DocumentView|Window}
     */
    function getWindowForElement(element) {
        var doc = element.ownerDocument;
        return doc.defaultView || doc.parentWindow;
    }

    /**
     * create new input type manager
     * @param {Manager} manager
     * @param {Function} callback
     * @returns {Input}
     * @constructor
     */
    function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.
        this.domHandler = function (ev) {
            if (boolOrFn(manager.options.enable, [manager])) {
                self.handler(ev);
            }
        };
        this.init();
    }

    /**
     * create new input type manager
     * called by the Manager constructor
     * @param {Hammer} manager
     * @returns {Input}
     */
    function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) {
            Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
            Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
            Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
            Type = MouseInput;
        } else {
            Type = TouchMouseInput;
        }
        return new Type(manager, inputHandler);
    }
    /**
     * handle input events
     * @param {Manager} manager
     * @param {String} eventType
     * @param {Object} input
     */
    function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) {
            manager.session = {};
        }
        // source event is the normalized value of the domEvents
        // like 'touchstart, mouseup, pointerdown'
        input.eventType = eventType;
        // compute scale, rotation etc
        computeInputData(manager, input);
        // emit secret event
        manager.emit('hammer.input', input);
        manager.recognize(input);
        manager.session.prevInput = input;
    }
    /**
     * extend the data with some usable properties like scale, rotate, velocity etc
     * @param {Object} manager
     * @param {Object} input
     */
    function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        // store the first input to calculate the distance and direction
        if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
        }
        // to compute scale and rotation we need to store the multiple touches
        if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
            session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        computeIntervalInputData(session, input);
        // find the correct target
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
            target = input.srcEvent.target;
        }
        input.target = target;
    }
    function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
                x: prevInput.deltaX || 0,
                y: prevInput.deltaY || 0
            };
            offset = session.offsetDelta = {
                x: center.x,
                y: center.y
            };
        }
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
    }
    /**
     * velocity is calculated every x ms
     * @param {Object} session
     * @param {Object} input
     */
    function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input,
            deltaTime = input.timeStamp - last.timeStamp,
            velocity,
            velocityX,
            velocityY,
            direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
            var deltaX = last.deltaX - input.deltaX;
            var deltaY = last.deltaY - input.deltaY;
            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);
            session.lastInterval = input;
        } else {
            // use latest velocity info if it doesn't overtake a minimum period
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
    }
    /**
     * create a simple clone from the input used for storage of firstInput and firstMultiple
     * @param {Object} input
     * @returns {Object} clonedInputData
     */
    function simpleCloneInputData(input) {
        // make a simple copy of the pointers because we will get a reference if we don't
        // we only need clientXY for the calculations
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
            pointers[i] = {
                clientX: round(input.pointers[i].clientX),
                clientY: round(input.pointers[i].clientY)
            };
            i++;
        }
        return {
            timeStamp: now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
        };
    }
    /**
     * get the center of all the pointers
     * @param {Array} pointers
     * @return {Object} center contains `x` and `y` properties
     */
    function getCenter(pointers) {
        var pointersLength = pointers.length;
        // no need to loop when only one touch
        if (pointersLength === 1) {
            return {
                x: round(pointers[0].clientX),
                y: round(pointers[0].clientY)
            };
        }
        var x = 0,
            y = 0,
            i = 0;
        while (i < pointersLength) {
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
        }
        return {
            x: round(x / pointersLength),
            y: round(y / pointersLength)
        };
    }
    /**
     * calculate the velocity between two points. unit is in px per ms.
     * @param {Number} deltaTime
     * @param {Number} x
     * @param {Number} y
     * @return {Object} velocity `x` and `y`
     */
    function getVelocity(deltaTime, x, y) {
        return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
        };
    }
    /**
     * get the direction between two points
     * @param {Number} x
     * @param {Number} y
     * @return {Number} direction
     */
    function getDirection(x, y) {
        if (x === y) {
            return DIRECTION_NONE;
        }
        if (abs(x) >= abs(y)) {
            return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
    }
    /**
     * calculate the absolute distance between two points
     * @param {Object} p1 {x, y}
     * @param {Object} p2 {x, y}
     * @param {Array} [props] containing x and y keys
     * @return {Number} distance
     */
    function getDistance(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
    }
    /**
     * calculate the angle between two coordinates
     * @param {Object} p1
     * @param {Object} p2
     * @param {Array} [props] containing x and y keys
     * @return {Number} angle
     */
    function getAngle(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
    }
    /**
     * calculate the rotation degrees between two pointersets
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} rotation
     */
    function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
    }
    /**
     * calculate the scale factor between two pointersets
     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} scale
     */
    function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    }

    /**
     * Mouse events input
     * @constructor
     * @extends Input
     */
    function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.allow = true; // used by Input.TouchMouse to disable mouse events
        this.pressed = false; // mousedown state
        Input.apply(this, arguments);
    }

    /**
     * Pointer events input
     * @constructor
     * @extends Input
     */
    function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
    }

    /**
     * Touch events input
     * @constructor
     * @extends Input
     */
    function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply(this, arguments);
    }

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END | INPUT_CANCEL)) {
            all = uniqueArray(all.concat(changed), 'identifier', true);
        }
        return [all, changed];
    }

    /**
     * Multi-user touch events input
     * @constructor
     * @extends Input
     */
    function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments);
    }

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;
        // when there is only one touch, the process can be simplified
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [allTouches, allTouches];
        }
        var i,
            targetTouches,
            changedTouches = toArray(ev.changedTouches),
            changedTargetTouches = [],
            target = this.target;
        // get target touches from touches
        targetTouches = allTouches.filter(function (touch) {
            return hasParent(touch.target, target);
        });
        // collect touches
        if (type === INPUT_START) {
            i = 0;
            while (i < targetTouches.length) {
                targetIds[targetTouches[i].identifier] = true;
                i++;
            }
        }
        // filter changed touches to only contain touches that exist in the collected target ids
        i = 0;
        while (i < changedTouches.length) {
            if (targetIds[changedTouches[i].identifier]) {
                changedTargetTouches.push(changedTouches[i]);
            }
            // cleanup removed touches
            if (type & (INPUT_END | INPUT_CANCEL)) {
                delete targetIds[changedTouches[i].identifier];
            }
            i++;
        }
        if (!changedTargetTouches.length) {
            return;
        }
        return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
    }
    /**
     * Combined touch and mouse input
     *
     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
     * This because touch devices also emit mouse events while doing a touch.
     *
     * @constructor
     * @extends Input
     */
    function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
    }

    /**
     * Touch Action
     * sets the touchAction property or uses the js alternative
     * @param {Manager} manager
     * @param {String} value
     * @constructor
     */
    function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
    }

    /**
     * when the touchActions are collected they are not a valid value, so we need to clean things up. *
     * @param {String} actions
     * @returns {*}
     */
    function cleanTouchActions(actions) {
        // none
        if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
        }
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        // pan-x and pan-y can be combined
        if (hasPanX && hasPanY) {
            return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
        }
        // pan-x OR pan-y
        if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }
        // manipulation
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
        }
        return TOUCH_ACTION_AUTO;
    }

    /**
     * Recognizer
     * Every recognizer needs to extend from this class.
     * @constructor
     * @param {Object} options
     */
    function Recognizer(options) {
        this.id = uniqueId();
        this.manager = null;
        this.options = merge(options || {}, this.defaults);
        // default is enable true
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
    }

    /**
     * get a usable string, used as event postfix
     * @param {Const} state
     * @returns {String} state
     */
    function stateStr(state) {
        if (state & STATE_CANCELLED) {
            return 'cancel';
        } else if (state & STATE_ENDED) {
            return 'end';
        } else if (state & STATE_CHANGED) {
            return 'move';
        } else if (state & STATE_BEGAN) {
            return 'start';
        }
        return '';
    }
    /**
     * direction cons to string
     * @param {Const} direction
     * @returns {String}
     */
    function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
            return 'down';
        } else if (direction == DIRECTION_UP) {
            return 'up';
        } else if (direction == DIRECTION_LEFT) {
            return 'left';
        } else if (direction == DIRECTION_RIGHT) {
            return 'right';
        }
        return '';
    }
    /**
     * get a recognizer by name if it is bound to a manager
     * @param {Recognizer|String} otherRecognizer
     * @param {Recognizer} recognizer
     * @returns {Recognizer}
     */
    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
            return manager.get(otherRecognizer);
        }
        return otherRecognizer;
    }
    /**
     * This recognizer is just used as a base for the simple attribute recognizers.
     * @constructor
     * @extends Recognizer
     */
    function AttrRecognizer() {
        Recognizer.apply(this, arguments);
    }

    /**
     * Pan
     * Recognized when the pointer is down and moved in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
    }

    /**
     * Pinch
     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
     * @constructor
     * @extends AttrRecognizer
     */
    function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    /**
     * Press
     * Recognized when the pointer is down for x ms without any movement.
     * @constructor
     * @extends Recognizer
     */
    function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
    }

    /**
     * Rotate
     * Recognized when two or more pointer are moving in a circular motion.
     * @constructor
     * @extends AttrRecognizer
     */
    function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    /**
     * Swipe
     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    /**
     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
     * between the given interval and position. The delay option can be used to recognize multi-taps without firing
     * a single tap.
     *
     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
     * multi-taps being recognized.
     * @constructor
     * @extends Recognizer
     */
    function TapRecognizer() {
        Recognizer.apply(this, arguments);
        // previous time and center,
        // used for tap counting
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
    }

    /**
     * Simple way to create an manager with a default set of recognizers.
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
    }

    /**
     * Manager
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Manager(element, options) {
        options = options || {};
        this.options = merge(options, Hammer.defaults);
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(options.recognizers, function (item) {
            var recognizer = this.add(new item[0](item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
        }, this);
    }

    /**
     * add/remove the css properties as defined in manager.options.cssProps
     * @param {Manager} manager
     * @param {Boolean} add
     */
    function toggleCssProps(manager, add) {
        var element = manager.element;
        each(manager.options.cssProps, function (value, name) {
            element.style[prefixed(element.style, name)] = add ? value : '';
        });
    }
    /**
     * trigger dom event
     * @param {String} event
     * @param {Object} data
     */
    function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent('Event');
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
    }
    return {
        setters: [],
        execute: function () {
            VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
            TEST_ELEMENT = document.createElement('div');
            TYPE_FUNCTION = 'function';
            round = Math.round;
            abs = Math.abs;
            now = Date.now;
            /**
             * get a unique id
             * @returns {number} uniqueId
             */
            _uniqueId = 1;
            MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
            SUPPORT_TOUCH = 'ontouchstart' in window;
            SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
            SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
            INPUT_TYPE_TOUCH = 'touch';
            INPUT_TYPE_PEN = 'pen';
            INPUT_TYPE_MOUSE = 'mouse';
            INPUT_TYPE_KINECT = 'kinect';
            COMPUTE_INTERVAL = 25;
            INPUT_START = 1;
            INPUT_MOVE = 2;
            INPUT_END = 4;
            INPUT_CANCEL = 8;
            DIRECTION_NONE = 1;
            DIRECTION_LEFT = 2;
            DIRECTION_RIGHT = 4;
            DIRECTION_UP = 8;
            DIRECTION_DOWN = 16;
            DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
            DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
            DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
            PROPS_XY = ['x', 'y'];
            PROPS_CLIENT_XY = ['clientX', 'clientY'];
            Input.prototype = {
                /**
                 * should handle the inputEvent data and trigger the callback
                 * @virtual
                 */
                handler: function handler() {},
                /**
                 * bind the events
                 */
                init: function init() {
                    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
                    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
                    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
                },
                /**
                 * unbind the events
                 */
                destroy: function destroy() {
                    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
                    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
                    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
                }
            };MOUSE_INPUT_MAP = {
                mousedown: INPUT_START,
                mousemove: INPUT_MOVE,
                mouseup: INPUT_END
            };
            MOUSE_ELEMENT_EVENTS = 'mousedown';
            MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
            inherit(MouseInput, Input, {
                /**
                 * handle mouse events
                 * @param {Object} ev
                 */
                handler: function MEhandler(ev) {
                    var eventType = MOUSE_INPUT_MAP[ev.type];
                    // on start we want to have the left mouse button down
                    if (eventType & INPUT_START && ev.button === 0) {
                        this.pressed = true;
                    }
                    if (eventType & INPUT_MOVE && ev.which !== 1) {
                        eventType = INPUT_END;
                    }
                    // mouse must be down, and mouse events are allowed (see the TouchMouse input)
                    if (!this.pressed || !this.allow) {
                        return;
                    }
                    if (eventType & INPUT_END) {
                        this.pressed = false;
                    }
                    this.callback(this.manager, eventType, {
                        pointers: [ev],
                        changedPointers: [ev],
                        pointerType: INPUT_TYPE_MOUSE,
                        srcEvent: ev
                    });
                }
            });
            POINTER_INPUT_MAP = {
                pointerdown: INPUT_START,
                pointermove: INPUT_MOVE,
                pointerup: INPUT_END,
                pointercancel: INPUT_CANCEL,
                pointerout: INPUT_CANCEL
            };

            // in IE10 the pointer types is defined as an enum
            IE10_POINTER_TYPE_ENUM = {
                2: INPUT_TYPE_TOUCH,
                3: INPUT_TYPE_PEN,
                4: INPUT_TYPE_MOUSE,
                5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
            };
            POINTER_ELEMENT_EVENTS = 'pointerdown';
            POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

            // IE10 has prefixed support, and case-sensitive
            if (window.MSPointerEvent) {
                POINTER_ELEMENT_EVENTS = 'MSPointerDown';
                POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
            }inherit(PointerEventInput, Input, {
                /**
                 * handle mouse events
                 * @param {Object} ev
                 */
                handler: function PEhandler(ev) {
                    var store = this.store;
                    var removePointer = false;
                    var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
                    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
                    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
                    var isTouch = pointerType == INPUT_TYPE_TOUCH;
                    // get index of the event in the store
                    var storeIndex = inArray(store, ev.pointerId, 'pointerId');
                    // start and mouse must be down
                    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                        if (storeIndex < 0) {
                            store.push(ev);
                            storeIndex = store.length - 1;
                        }
                    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                        removePointer = true;
                    }
                    // it not found, so the pointer hasn't been down (so it's probably a hover)
                    if (storeIndex < 0) {
                        return;
                    }
                    // update the event in the store
                    store[storeIndex] = ev;
                    this.callback(this.manager, eventType, {
                        pointers: store,
                        changedPointers: [ev],
                        pointerType: pointerType,
                        srcEvent: ev
                    });
                    if (removePointer) {
                        // remove from the store
                        store.splice(storeIndex, 1);
                    }
                }
            });
            SINGLE_TOUCH_INPUT_MAP = {
                touchstart: INPUT_START,
                touchmove: INPUT_MOVE,
                touchend: INPUT_END,
                touchcancel: INPUT_CANCEL
            };
            SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
            SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
            inherit(SingleTouchInput, Input, {
                handler: function TEhandler(ev) {
                    var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
                    // should we handle the touch events?
                    if (type === INPUT_START) {
                        this.started = true;
                    }
                    if (!this.started) {
                        return;
                    }
                    var touches = normalizeSingleTouches.call(this, ev, type);
                    // when done, reset the started state
                    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
                        this.started = false;
                    }
                    this.callback(this.manager, type, {
                        pointers: touches[0],
                        changedPointers: touches[1],
                        pointerType: INPUT_TYPE_TOUCH,
                        srcEvent: ev
                    });
                }
            });TOUCH_INPUT_MAP = {
                touchstart: INPUT_START,
                touchmove: INPUT_MOVE,
                touchend: INPUT_END,
                touchcancel: INPUT_CANCEL
            };
            TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
            inherit(TouchInput, Input, {
                handler: function MTEhandler(ev) {
                    var type = TOUCH_INPUT_MAP[ev.type];
                    var touches = getTouches.call(this, ev, type);
                    if (!touches) {
                        return;
                    }
                    this.callback(this.manager, type, {
                        pointers: touches[0],
                        changedPointers: touches[1],
                        pointerType: INPUT_TYPE_TOUCH,
                        srcEvent: ev
                    });
                }
            });inherit(TouchMouseInput, Input, {
                /**
                 * handle mouse and touch events
                 * @param {Hammer} manager
                 * @param {String} inputEvent
                 * @param {Object} inputData
                 */
                handler: function TMEhandler(manager, inputEvent, inputData) {
                    var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,
                        isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
                    // when we're in a touch event, so  block all upcoming mouse events
                    // most mobile browser also emit mouseevents, right after touchstart
                    if (isTouch) {
                        this.mouse.allow = false;
                    } else if (isMouse && !this.mouse.allow) {
                        return;
                    }
                    // reset the allowMouse when we're done
                    if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
                        this.mouse.allow = true;
                    }
                    this.callback(manager, inputEvent, inputData);
                },
                /**
                 * remove the event listeners
                 */
                destroy: function destroy() {
                    this.touch.destroy();
                    this.mouse.destroy();
                }
            });
            PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
            NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

            // magical touchAction value
            TOUCH_ACTION_COMPUTE = 'compute';
            TOUCH_ACTION_AUTO = 'auto';
            TOUCH_ACTION_MANIPULATION = 'manipulation';
            // not implemented
            TOUCH_ACTION_NONE = 'none';
            TOUCH_ACTION_PAN_X = 'pan-x';
            TOUCH_ACTION_PAN_Y = 'pan-y';
            TouchAction.prototype = {
                /**
                 * set the touchAction value on the element or enable the polyfill
                 * @param {String} value
                 */
                set: function set(value) {
                    // find out the touch-action by the event handlers
                    if (value == TOUCH_ACTION_COMPUTE) {
                        value = this.compute();
                    }
                    if (NATIVE_TOUCH_ACTION) {
                        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
                    }
                    this.actions = value.toLowerCase().trim();
                },
                /**
                 * just re-set the touchAction value
                 */
                update: function update() {
                    this.set(this.manager.options.touchAction);
                },
                /**
                 * compute the value for the touchAction property based on the recognizer's settings
                 * @returns {String} value
                 */
                compute: function compute() {
                    var actions = [];
                    each(this.manager.recognizers, function (recognizer) {
                        if (boolOrFn(recognizer.options.enable, [recognizer])) {
                            actions = actions.concat(recognizer.getTouchAction());
                        }
                    });
                    return cleanTouchActions(actions.join(' '));
                },
                /**
                 * this method is called on each input cycle and provides the preventing of the browser behavior
                 * @param {Object} input
                 */
                preventDefaults: function preventDefaults(input) {
                    // not needed with native support for the touchAction property
                    if (NATIVE_TOUCH_ACTION) {
                        return;
                    }
                    var srcEvent = input.srcEvent;
                    var direction = input.offsetDirection;
                    // if the touch action did prevented once this session
                    if (this.manager.session.prevented) {
                        srcEvent.preventDefault();
                        return;
                    }
                    var actions = this.actions;
                    var hasNone = inStr(actions, TOUCH_ACTION_NONE);
                    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
                    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
                    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
                        return this.preventSrc(srcEvent);
                    }
                },
                /**
                 * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
                 * @param {Object} srcEvent
                 */
                preventSrc: function preventSrc(srcEvent) {
                    this.manager.session.prevented = true;
                    srcEvent.preventDefault();
                }
            }; /**
                * Recognizer flow explained; *
                * All recognizers have the initial state of POSSIBLE when a input session starts.
                * The definition of a input session is from the first input until the last input, with all it's movement in it. *
                * Example session for mouse-input: mousedown -> mousemove -> mouseup
                *
                * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
                * which determines with state it should be.
                *
                * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
                * POSSIBLE to give it another change on the next cycle.
                *
                *               Possible
                *                  |
                *            +-----+---------------+
                *            |                     |
                *      +-----+-----+               |
                *      |           |               |
                *   Failed      Cancelled          |
                *                          +-------+------+
                *                          |              |
                *                      Recognized       Began
                *                                         |
                *                                      Changed
                *                                         |
                *                                  Ended/Recognized
                */
            STATE_POSSIBLE = 1;
            STATE_BEGAN = 2;
            STATE_CHANGED = 4;
            STATE_ENDED = 8;
            STATE_RECOGNIZED = STATE_ENDED;
            STATE_CANCELLED = 16;
            STATE_FAILED = 32;
            Recognizer.prototype = {
                /**
                 * @virtual
                 * @type {Object}
                 */
                defaults: {},
                /**
                 * set options
                 * @param {Object} options
                 * @return {Recognizer}
                 */
                set: function set(options) {
                    extend(this.options, options);
                    // also update the touchAction, in case something changed about the directions/enabled state
                    this.manager && this.manager.touchAction.update();
                    return this;
                },
                /**
                 * recognize simultaneous with an other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                recognizeWith: function recognizeWith(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
                        return this;
                    }
                    var simultaneous = this.simultaneous;
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    if (!simultaneous[otherRecognizer.id]) {
                        simultaneous[otherRecognizer.id] = otherRecognizer;
                        otherRecognizer.recognizeWith(this);
                    }
                    return this;
                },
                /**
                 * drop the simultaneous link. it doesnt remove the link on the other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
                        return this;
                    }
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    delete this.simultaneous[otherRecognizer.id];
                    return this;
                },
                /**
                 * recognizer can only run when an other is failing
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                requireFailure: function requireFailure(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
                        return this;
                    }
                    var requireFail = this.requireFail;
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    if (inArray(requireFail, otherRecognizer) === -1) {
                        requireFail.push(otherRecognizer);
                        otherRecognizer.requireFailure(this);
                    }
                    return this;
                },
                /**
                 * drop the requireFailure link. it does not remove the link on the other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                dropRequireFailure: function dropRequireFailure(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
                        return this;
                    }
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    var index = inArray(this.requireFail, otherRecognizer);
                    if (index > -1) {
                        this.requireFail.splice(index, 1);
                    }
                    return this;
                },
                /**
                 * has require failures boolean
                 * @returns {boolean}
                 */
                hasRequireFailures: function hasRequireFailures() {
                    return this.requireFail.length > 0;
                },
                /**
                 * if the recognizer can recognize simultaneous with an other recognizer
                 * @param {Recognizer} otherRecognizer
                 * @returns {Boolean}
                 */
                canRecognizeWith: function canRecognizeWith(otherRecognizer) {
                    return !!this.simultaneous[otherRecognizer.id];
                },
                /**
                 * You should use `tryEmit` instead of `emit` directly to check
                 * that all the needed recognizers has failed before emitting.
                 * @param {Object} input
                 */
                emit: function emit(input) {
                    var self = this;
                    var state = this.state;
                    function emit(withState) {
                        self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
                    }
                    // 'panstart' and 'panmove'
                    if (state < STATE_ENDED) {
                        emit(true);
                    }
                    emit(); // simple 'eventName' events
                    // panend and pancancel
                    if (state >= STATE_ENDED) {
                        emit(true);
                    }
                },
                /**
                 * Check that all the require failure recognizers has failed,
                 * if true, it emits a gesture event,
                 * otherwise, setup the state to FAILED.
                 * @param {Object} input
                 */
                tryEmit: function tryEmit(input) {
                    if (this.canEmit()) {
                        return this.emit(input);
                    }
                    // it's failing anyway
                    this.state = STATE_FAILED;
                },
                /**
                 * can we emit?
                 * @returns {boolean}
                 */
                canEmit: function canEmit() {
                    var i = 0;
                    while (i < this.requireFail.length) {
                        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                            return false;
                        }
                        i++;
                    }
                    return true;
                },
                /**
                 * update the recognizer
                 * @param {Object} inputData
                 */
                recognize: function recognize(inputData) {
                    // make a new copy of the inputData
                    // so we can change the inputData without messing up the other recognizers
                    var inputDataClone = extend({}, inputData);
                    // is is enabled and allow recognizing?
                    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
                        this.reset();
                        this.state = STATE_FAILED;
                        return;
                    }
                    // reset when we've reached the end
                    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                        this.state = STATE_POSSIBLE;
                    }
                    this.state = this.process(inputDataClone);
                    // the recognizer has recognized a gesture
                    // so trigger an event
                    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
                        this.tryEmit(inputDataClone);
                    }
                },
                /**
                 * return the state of the recognizer
                 * the actual recognizing happens in this method
                 * @virtual
                 * @param {Object} inputData
                 * @returns {Const} STATE
                 */
                process: function process(inputData) {},
                /**
                 * return the preferred touch-action
                 * @virtual
                 * @returns {Array}
                 */
                getTouchAction: function getTouchAction() {},
                /**
                 * called when the gesture isn't allowed to recognize
                 * like when another is being recognized or it is disabled
                 * @virtual
                 */
                reset: function reset() {}
            };inherit(AttrRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof AttrRecognizer
                 */
                defaults: {
                    /**
                     * @type {Number}
                     * @default 1
                     */
                    pointers: 1
                },
                /**
                 * Used to check if it the recognizer receives valid input, like input.distance > 10.
                 * @memberof AttrRecognizer
                 * @param {Object} input
                 * @returns {Boolean} recognized
                 */
                attrTest: function attrTest(input) {
                    var optionPointers = this.options.pointers;
                    return optionPointers === 0 || input.pointers.length === optionPointers;
                },
                /**
                 * Process the input and return the state for the recognizer
                 * @memberof AttrRecognizer
                 * @param {Object} input
                 * @returns {*} State
                 */
                process: function process(input) {
                    var state = this.state;
                    var eventType = input.eventType;
                    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
                    var isValid = this.attrTest(input);
                    // on cancel input and we've recognized before, return STATE_CANCELLED
                    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                        return state | STATE_CANCELLED;
                    } else if (isRecognized || isValid) {
                        if (eventType & INPUT_END) {
                            return state | STATE_ENDED;
                        } else if (!(state & STATE_BEGAN)) {
                            return STATE_BEGAN;
                        }
                        return state | STATE_CHANGED;
                    }
                    return STATE_FAILED;
                }
            });inherit(PanRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof PanRecognizer
                 */
                defaults: {
                    event: 'pan',
                    threshold: 10,
                    pointers: 1,
                    direction: DIRECTION_ALL
                },
                getTouchAction: function getTouchAction() {
                    var direction = this.options.direction;
                    var actions = [];
                    if (direction & DIRECTION_HORIZONTAL) {
                        actions.push(TOUCH_ACTION_PAN_Y);
                    }
                    if (direction & DIRECTION_VERTICAL) {
                        actions.push(TOUCH_ACTION_PAN_X);
                    }
                    return actions;
                },
                directionTest: function directionTest(input) {
                    var options = this.options;
                    var hasMoved = true;
                    var distance = input.distance;
                    var direction = input.direction;
                    var x = input.deltaX;
                    var y = input.deltaY;
                    // lock to axis?
                    if (!(direction & options.direction)) {
                        if (options.direction & DIRECTION_HORIZONTAL) {
                            direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                            hasMoved = x != this.pX;
                            distance = Math.abs(input.deltaX);
                        } else {
                            direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                            hasMoved = y != this.pY;
                            distance = Math.abs(input.deltaY);
                        }
                    }
                    input.direction = direction;
                    return hasMoved && distance > options.threshold && direction & options.direction;
                },
                attrTest: function attrTest(input) {
                    return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
                },
                emit: function emit(input) {
                    this.pX = input.deltaX;
                    this.pY = input.deltaY;
                    var direction = directionStr(input.direction);
                    if (direction) {
                        this.manager.emit(this.options.event + direction, input);
                    }
                    this._super.emit.call(this, input);
                }
            });inherit(PinchRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof PinchRecognizer
                 */
                defaults: {
                    event: 'pinch',
                    threshold: 0,
                    pointers: 2
                },
                getTouchAction: function getTouchAction() {
                    return [TOUCH_ACTION_NONE];
                },
                attrTest: function attrTest(input) {
                    return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
                },
                emit: function emit(input) {
                    this._super.emit.call(this, input);
                    if (input.scale !== 1) {
                        var inOut = input.scale < 1 ? 'in' : 'out';
                        this.manager.emit(this.options.event + inOut, input);
                    }
                }
            });inherit(PressRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof PressRecognizer
                 */
                defaults: {
                    event: 'press',
                    pointers: 1,
                    time: 500,
                    threshold: 5 // a minimal movement is ok, but keep it low
                },
                getTouchAction: function getTouchAction() {
                    return [TOUCH_ACTION_AUTO];
                },
                process: function process(input) {
                    var options = this.options;
                    var validPointers = input.pointers.length === options.pointers;
                    var validMovement = input.distance < options.threshold;
                    var validTime = input.deltaTime > options.time;
                    this._input = input;
                    // we only allow little movement
                    // and we've reached an end event, so a tap is possible
                    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
                        this.reset();
                    } else if (input.eventType & INPUT_START) {
                        this.reset();
                        this._timer = setTimeoutContext(function () {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.time, this);
                    } else if (input.eventType & INPUT_END) {
                        return STATE_RECOGNIZED;
                    }
                    return STATE_FAILED;
                },
                reset: function reset() {
                    clearTimeout(this._timer);
                },
                emit: function emit(input) {
                    if (this.state !== STATE_RECOGNIZED) {
                        return;
                    }
                    if (input && input.eventType & INPUT_END) {
                        this.manager.emit(this.options.event + 'up', input);
                    } else {
                        this._input.timeStamp = now();
                        this.manager.emit(this.options.event, this._input);
                    }
                }
            });inherit(RotateRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof RotateRecognizer
                 */
                defaults: {
                    event: 'rotate',
                    threshold: 0,
                    pointers: 2
                },
                getTouchAction: function getTouchAction() {
                    return [TOUCH_ACTION_NONE];
                },
                attrTest: function attrTest(input) {
                    return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
                }
            });inherit(SwipeRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof SwipeRecognizer
                 */
                defaults: {
                    event: 'swipe',
                    threshold: 10,
                    velocity: 0.65,
                    direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
                    pointers: 1
                },
                getTouchAction: function getTouchAction() {
                    return PanRecognizer.prototype.getTouchAction.call(this);
                },
                attrTest: function attrTest(input) {
                    var direction = this.options.direction;
                    var velocity;
                    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
                        velocity = input.velocity;
                    } else if (direction & DIRECTION_HORIZONTAL) {
                        velocity = input.velocityX;
                    } else if (direction & DIRECTION_VERTICAL) {
                        velocity = input.velocityY;
                    }
                    return this._super.attrTest.call(this, input) && direction & input.direction && input.distance > this.options.threshold && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
                },
                emit: function emit(input) {
                    var direction = directionStr(input.direction);
                    if (direction) {
                        this.manager.emit(this.options.event + direction, input);
                    }
                    this.manager.emit(this.options.event, input);
                }
            });inherit(TapRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof PinchRecognizer
                 */
                defaults: {
                    event: 'tap',
                    pointers: 1,
                    taps: 1,
                    interval: 300,
                    time: 250,
                    threshold: 2,
                    posThreshold: 10 // a multi-tap can be a bit off the initial position
                },
                getTouchAction: function getTouchAction() {
                    return [TOUCH_ACTION_MANIPULATION];
                },
                process: function process(input) {
                    var options = this.options;
                    var validPointers = input.pointers.length === options.pointers;
                    var validMovement = input.distance < options.threshold;
                    var validTouchTime = input.deltaTime < options.time;
                    this.reset();
                    if (input.eventType & INPUT_START && this.count === 0) {
                        return this.failTimeout();
                    }
                    // we only allow little movement
                    // and we've reached an end event, so a tap is possible
                    if (validMovement && validTouchTime && validPointers) {
                        if (input.eventType != INPUT_END) {
                            return this.failTimeout();
                        }
                        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
                        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
                        this.pTime = input.timeStamp;
                        this.pCenter = input.center;
                        if (!validMultiTap || !validInterval) {
                            this.count = 1;
                        } else {
                            this.count += 1;
                        }
                        this._input = input;
                        // if tap count matches we have recognized it,
                        // else it has began recognizing...
                        var tapCount = this.count % options.taps;
                        if (tapCount === 0) {
                            // no failing requirements, immediately trigger the tap event
                            // or wait as long as the multitap interval to trigger
                            if (!this.hasRequireFailures()) {
                                return STATE_RECOGNIZED;
                            } else {
                                this._timer = setTimeoutContext(function () {
                                    this.state = STATE_RECOGNIZED;
                                    this.tryEmit();
                                }, options.interval, this);
                                return STATE_BEGAN;
                            }
                        }
                    }
                    return STATE_FAILED;
                },
                failTimeout: function failTimeout() {
                    this._timer = setTimeoutContext(function () {
                        this.state = STATE_FAILED;
                    }, this.options.interval, this);
                    return STATE_FAILED;
                },
                reset: function reset() {
                    clearTimeout(this._timer);
                },
                emit: function emit() {
                    if (this.state == STATE_RECOGNIZED) {
                        this._input.tapCount = this.count;
                        this.manager.emit(this.options.event, this._input);
                    }
                }
            }); /**
                 * @const {string}
                 */
            Hammer.VERSION = '2.0.4';
            /**
             * default settings
             * @namespace
             */
            Hammer.defaults = {
                /**
                 * set if DOM events are being triggered.
                 * But this is slower and unused by simple implementations, so disabled by default.
                 * @type {Boolean}
                 * @default false
                 */
                domEvents: false,
                /**
                 * The value for the touchAction property/fallback.
                 * When set to `compute` it will magically set the correct value based on the added recognizers.
                 * @type {String}
                 * @default compute
                 */
                touchAction: TOUCH_ACTION_COMPUTE,
                /**
                 * @type {Boolean}
                 * @default true
                 */
                enable: true,
                /**
                 * EXPERIMENTAL FEATURE -- can be removed/changed
                 * Change the parent input target element.
                 * If Null, then it is being set the to main element.
                 * @type {Null|EventTarget}
                 * @default null
                 */
                inputTarget: null,
                /**
                 * force an input class
                 * @type {Null|Function}
                 * @default null
                 */
                inputClass: null,
                /**
                 * Default recognizer setup when calling `Hammer()`
                 * When creating a new Manager these will be skipped.
                 * @type {Array}
                 */
                preset: [
                // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
                [RotateRecognizer, { enable: false }], [PinchRecognizer, { enable: false }, ['rotate']], [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }], [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']], [TapRecognizer], [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']], [PressRecognizer]],
                /**
                 * Some CSS properties can be used to improve the working of Hammer.
                 * Add them to this method and they will be set when creating a new Manager.
                 * @namespace
                 */
                cssProps: {
                    /**
                     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
                     * @type {String}
                     * @default 'none'
                     */
                    userSelect: 'none',
                    /**
                     * Disable the Windows Phone grippers when pressing an element.
                     * @type {String}
                     * @default 'none'
                     */
                    touchSelect: 'none',
                    /**
                     * Disables the default callout shown when you touch and hold a touch target.
                     * On iOS, when you touch and hold a touch target such as a link, Safari displays
                     * a callout containing information about the link. This property allows you to disable that callout.
                     * @type {String}
                     * @default 'none'
                     */
                    touchCallout: 'none',
                    /**
                     * Specifies whether zooming is enabled. Used by IE10>
                     * @type {String}
                     * @default 'none'
                     */
                    contentZooming: 'none',
                    /**
                     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
                     * @type {String}
                     * @default 'none'
                     */
                    userDrag: 'none',
                    /**
                     * Overrides the highlight color shown when the user taps a link or a JavaScript
                     * clickable element in iOS. This property obeys the alpha value, if specified.
                     * @type {String}
                     * @default 'rgba(0,0,0,0)'
                     */
                    tapHighlightColor: 'rgba(0,0,0,0)'
                }
            };
            STOP = 1;
            FORCED_STOP = 2;
            Manager.prototype = {
                /**
                 * set options
                 * @param {Object} options
                 * @returns {Manager}
                 */
                set: function set(options) {
                    extend(this.options, options);
                    // Options that need a little more setup
                    if (options.touchAction) {
                        this.touchAction.update();
                    }
                    if (options.inputTarget) {
                        // Clean up existing event listeners and reinitialize
                        this.input.destroy();
                        this.input.target = options.inputTarget;
                        this.input.init();
                    }
                    return this;
                },
                /**
                 * stop recognizing for this session.
                 * This session will be discarded, when a new [input]start event is fired.
                 * When forced, the recognizer cycle is stopped immediately.
                 * @param {Boolean} [force]
                 */
                stop: function stop(force) {
                    this.session.stopped = force ? FORCED_STOP : STOP;
                },
                /**
                 * run the recognizers!
                 * called by the inputHandler function on every movement of the pointers (touches)
                 * it walks through all the recognizers and tries to detect the gesture that is being made
                 * @param {Object} inputData
                 */
                recognize: function recognize(inputData) {
                    var session = this.session;
                    if (session.stopped) {
                        return;
                    }
                    // run the touch-action polyfill
                    this.touchAction.preventDefaults(inputData);
                    var recognizer;
                    var recognizers = this.recognizers;
                    // this holds the recognizer that is being recognized.
                    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
                    // if no recognizer is detecting a thing, it is set to `null`
                    var curRecognizer = session.curRecognizer;
                    // reset when the last recognizer is recognized
                    // or when we're in a new session
                    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
                        curRecognizer = session.curRecognizer = null;
                    }
                    var i = 0;
                    while (i < recognizers.length) {
                        recognizer = recognizers[i];
                        // find out if we are allowed try to recognize the input for this one.
                        // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                        //      that is being recognized.
                        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                        //      this can be setup with the `recognizeWith()` method on the recognizer.
                        if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) {
                            recognizer.recognize(inputData);
                        } else {
                            recognizer.reset();
                        }
                        // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                        // current active recognizer. but only if we don't already have an active recognizer
                        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                            curRecognizer = session.curRecognizer = recognizer;
                        }
                        i++;
                    }
                },
                /**
                 * get a recognizer by its event name.
                 * @param {Recognizer|String} recognizer
                 * @returns {Recognizer|Null}
                 */
                get: function get(recognizer) {
                    if (recognizer instanceof Recognizer) {
                        return recognizer;
                    }
                    var recognizers = this.recognizers;
                    for (var i = 0; i < recognizers.length; i++) {
                        if (recognizers[i].options.event == recognizer) {
                            return recognizers[i];
                        }
                    }
                    return null;
                },
                /**
                 * add a recognizer to the manager
                 * existing recognizers with the same event name will be removed
                 * @param {Recognizer} recognizer
                 * @returns {Recognizer|Manager}
                 */
                add: function add(recognizer) {
                    if (invokeArrayArg(recognizer, 'add', this)) {
                        return this;
                    }
                    // remove existing
                    var existing = this.get(recognizer.options.event);
                    if (existing) {
                        this.remove(existing);
                    }
                    this.recognizers.push(recognizer);
                    recognizer.manager = this;
                    this.touchAction.update();
                    return recognizer;
                },
                /**
                 * remove a recognizer by name or instance
                 * @param {Recognizer|String} recognizer
                 * @returns {Manager}
                 */
                remove: function remove(recognizer) {
                    if (invokeArrayArg(recognizer, 'remove', this)) {
                        return this;
                    }
                    var recognizers = this.recognizers;
                    recognizer = this.get(recognizer);
                    recognizers.splice(inArray(recognizers, recognizer), 1);
                    this.touchAction.update();
                    return this;
                },
                /**
                 * bind event
                 * @param {String} events
                 * @param {Function} handler
                 * @returns {EventEmitter} this
                 */
                on: function on(events, handler) {
                    var handlers = this.handlers;
                    each(splitStr(events), function (event) {
                        handlers[event] = handlers[event] || [];
                        handlers[event].push(handler);
                    });
                    return this;
                },
                /**
                 * unbind event, leave emit blank to remove all handlers
                 * @param {String} events
                 * @param {Function} [handler]
                 * @returns {EventEmitter} this
                 */
                off: function off(events, handler) {
                    var handlers = this.handlers;
                    each(splitStr(events), function (event) {
                        if (!handler) {
                            delete handlers[event];
                        } else {
                            handlers[event].splice(inArray(handlers[event], handler), 1);
                        }
                    });
                    return this;
                },
                /**
                 * emit event to the listeners
                 * @param {String} event
                 * @param {Object} data
                 */
                emit: function emit(event, data) {
                    // we also want to trigger dom events
                    if (this.options.domEvents) {
                        triggerDomEvent(event, data);
                    }
                    // no handlers, so skip it all
                    var handlers = this.handlers[event] && this.handlers[event].slice();
                    if (!handlers || !handlers.length) {
                        return;
                    }
                    data.type = event;
                    data.preventDefault = function () {
                        data.srcEvent.preventDefault();
                    };
                    var i = 0;
                    while (i < handlers.length) {
                        handlers[i](data);
                        i++;
                    }
                },
                /**
                 * destroy the manager and unbinds all events
                 * it doesn't unbind dom events, that is the user own responsibility
                 */
                destroy: function destroy() {
                    this.element && toggleCssProps(this, false);
                    this.handlers = {};
                    this.session = {};
                    this.input.destroy();
                    this.element = null;
                }
            };extend(Hammer, {
                INPUT_START: INPUT_START,
                INPUT_MOVE: INPUT_MOVE,
                INPUT_END: INPUT_END,
                INPUT_CANCEL: INPUT_CANCEL,
                STATE_POSSIBLE: STATE_POSSIBLE,
                STATE_BEGAN: STATE_BEGAN,
                STATE_CHANGED: STATE_CHANGED,
                STATE_ENDED: STATE_ENDED,
                STATE_RECOGNIZED: STATE_RECOGNIZED,
                STATE_CANCELLED: STATE_CANCELLED,
                STATE_FAILED: STATE_FAILED,
                DIRECTION_NONE: DIRECTION_NONE,
                DIRECTION_LEFT: DIRECTION_LEFT,
                DIRECTION_RIGHT: DIRECTION_RIGHT,
                DIRECTION_UP: DIRECTION_UP,
                DIRECTION_DOWN: DIRECTION_DOWN,
                DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
                DIRECTION_VERTICAL: DIRECTION_VERTICAL,
                DIRECTION_ALL: DIRECTION_ALL,
                Manager: Manager,
                Input: Input,
                TouchAction: TouchAction,
                TouchInput: TouchInput,
                MouseInput: MouseInput,
                PointerEventInput: PointerEventInput,
                TouchMouseInput: TouchMouseInput,
                SingleTouchInput: SingleTouchInput,
                Recognizer: Recognizer,
                AttrRecognizer: AttrRecognizer,
                Tap: TapRecognizer,
                Pan: PanRecognizer,
                Swipe: SwipeRecognizer,
                Pinch: PinchRecognizer,
                Rotate: RotateRecognizer,
                Press: PressRecognizer,
                on: addEventListeners,
                off: removeEventListeners,
                each: each,
                merge: merge,
                extend: extend,
                inherit: inherit,
                bindFn: bindFn,
                prefixed: prefixed
            });
            /*
            if (typeof define == TYPE_FUNCTION && define.amd) {
                define(function() {
                    return Hammer;
                });
            } else if (typeof module != 'undefined' && module.exports) {
                module.exports = Hammer;
            } else {
                window[exportName] = Hammer;
            }
            */

            _export('Hammer', Hammer);

            //})(window, document, 'Hammer');
        }
    };
});
System.register('ionic/gestures/slide-edge-gesture', ['ionic/gestures/slide-gesture', 'ionic/util'], function (_export) {
    'use strict';

    var SlideGesture, util, SlideEdgeGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_ionicGesturesSlideGesture) {
            SlideGesture = _ionicGesturesSlideGesture.SlideGesture;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            SlideEdgeGesture = (function (_SlideGesture) {
                function SlideEdgeGesture(element) {
                    var opts = arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, SlideEdgeGesture);

                    util.defaults(opts, {
                        edge: 'left',
                        threshold: 50
                    });
                    _get(Object.getPrototypeOf(SlideEdgeGesture.prototype), 'constructor', this).call(this, element, opts);
                    // Can check corners through use of eg 'left top'
                    this.edges = opts.edge.split(' ');
                    this.threshold = opts.threshold;
                }

                _inherits(SlideEdgeGesture, _SlideGesture);

                _createClass(SlideEdgeGesture, [{
                    key: 'canStart',
                    value: function canStart(ev) {
                        var _this = this;

                        this._containerRect = this.getContainerDimensions();
                        return this.edges.every(function (edge) {
                            return _this._checkEdge(edge, ev.gesture.center);
                        });
                    }
                }, {
                    key: 'getContainerDimensions',
                    value: function getContainerDimensions() {
                        return {
                            left: 0,
                            top: 0,
                            width: window.innerWidth,
                            height: window.innerHeight
                        };
                    }
                }, {
                    key: '_checkEdge',
                    value: function _checkEdge(edge, pos) {
                        switch (edge) {
                            case 'left':
                                return pos.x <= this._containerRect.left + this.threshold;
                            case 'right':
                                return pos.x >= this._containerRect.width - this.threshold;
                            case 'top':
                                return pos.y <= this._containerRect.top + this.threshold;
                            case 'bottom':
                                return pos.y >= this._containerRect.height - this.threshold;
                        }
                    }
                }]);

                return SlideEdgeGesture;
            })(SlideGesture);

            _export('SlideEdgeGesture', SlideEdgeGesture);
        }
    };
});
System.register('ionic/gestures/slide-gesture', ['ionic/gestures/drag-gesture', 'ionic/util'], function (_export) {
    'use strict';

    var DragGesture, util, SlideGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_ionicGesturesDragGesture) {
            DragGesture = _ionicGesturesDragGesture.DragGesture;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            SlideGesture = (function (_DragGesture) {
                function SlideGesture(element) {
                    var opts = arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, SlideGesture);

                    _get(Object.getPrototypeOf(SlideGesture.prototype), 'constructor', this).call(this, element, opts);
                    this.element = element;
                }

                _inherits(SlideGesture, _DragGesture);

                _createClass(SlideGesture, [{
                    key: 'getSlideBoundaries',

                    /*
                     * Get the min and max for the slide. pageX/pageY.
                     * Only called on dragstart.
                     */
                    value: function getSlideBoundaries(slide, ev) {
                        return {
                            min: 0,
                            max: this.element.offsetWidth
                        };
                    }
                }, {
                    key: 'getElementStartPos',

                    /*
                     * Get the element's pos when the drag starts.
                     * For example, an open side menu starts at 100% and a closed
                     * sidemenu starts at 0%.
                     */
                    value: function getElementStartPos(slide, ev) {
                        return 0;
                    }
                }, {
                    key: 'canStart',
                    value: function canStart() {
                        return true;
                    }
                }, {
                    key: 'onDragStart',
                    value: function onDragStart(ev) {
                        var _this = this;

                        if (!this.canStart(ev)) return false;
                        this.slide = {};
                        var promise = this.onSlideBeforeStart(this.slide, ev) || Promise.resolve();
                        promise.then(function () {
                            var _getSlideBoundaries = _this.getSlideBoundaries(_this.slide, ev);

                            var min = _getSlideBoundaries.min;
                            var max = _getSlideBoundaries.max;

                            _this.slide.min = min;
                            _this.slide.max = max;
                            _this.slide.elementStartPos = _this.getElementStartPos(_this.slide, ev);
                            _this.slide.pointerStartPos = ev.gesture.center[_this.direction];
                            _this.slide.started = true;
                            _this.onSlideStart(_this.slide, ev);
                        })['catch'](function () {
                            _this.slide = null;
                        });
                    }
                }, {
                    key: 'onDrag',
                    value: function onDrag(ev) {
                        if (!this.slide || !this.slide.started) return;
                        this.slide.pos = ev.gesture.center[this.direction];
                        this.slide.distance = util.clamp(this.slide.min, this.slide.pos - this.slide.pointerStartPos + this.slide.elementStartPos, this.slide.max);
                        this.slide.delta = this.slide.pos - this.slide.pointerStartPos;
                        this.onSlide(this.slide, ev);
                    }
                }, {
                    key: 'onDragEnd',
                    value: function onDragEnd(ev) {
                        if (!this.slide || !this.slide.started) return;
                        this.onSlideEnd(this.slide, ev);
                        this.slide = null;
                    }
                }, {
                    key: 'onSlideBeforeStart',
                    value: function onSlideBeforeStart() {}
                }, {
                    key: 'onSlideStart',
                    value: function onSlideStart() {}
                }, {
                    key: 'onSlide',
                    value: function onSlide() {}
                }, {
                    key: 'onSlideEnd',
                    value: function onSlideEnd() {}
                }]);

                return SlideGesture;
            })(DragGesture);

            _export('SlideGesture', SlideGesture);
        }
    };
});
System.register('ionic/platform/platform', ['../util/util', '../util/dom'], function (_export) {
    'use strict';

    var util, dom, PlatformCtrl, PlatformNode, Platform;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function insertSuperset(platformNode) {
        var supersetPlaformName = platformNode.superset();
        if (supersetPlaformName) {
            // add a platform in between two exist platforms
            // so we can build the correct hierarchy of active platforms
            var supersetPlatform = new PlatformNode(supersetPlaformName);
            supersetPlatform.parent(platformNode.parent());
            supersetPlatform.child(platformNode);
            if (supersetPlatform.parent()) {
                supersetPlatform.parent().child(supersetPlatform);
            }
            platformNode.parent(supersetPlatform);
        }
    }
    return {
        setters: [function (_utilUtil) {
            util = _utilUtil;
        }, function (_utilDom) {
            dom = _utilDom;
        }],
        execute: function () {
            PlatformCtrl = (function () {
                function PlatformCtrl() {
                    var _this = this;

                    _classCallCheck(this, PlatformCtrl);

                    this._settings = {};
                    this._platforms = [];
                    this._versions = {};
                    this._registry = {};
                    this._default = null;
                    this._onResizes = [];
                    this._readyPromise = new Promise(function (res) {
                        _this._readyResolve = res;
                    });
                }

                _createClass(PlatformCtrl, [{
                    key: 'is',

                    // Methods
                    // **********************************************
                    value: function is(platformName) {
                        return this._platforms.indexOf(platformName) > -1;
                    }
                }, {
                    key: 'platforms',
                    value: function platforms() {
                        // get the array of active platforms, which also knows the hierarchy,
                        // with the last one the most important
                        return this._platforms;
                    }
                }, {
                    key: 'versions',
                    value: function versions(platformName) {
                        if (arguments.length) {
                            // get a specific platform's version
                            return this._versions[platformName];
                        }
                        // get all the platforms that have a valid parsed version
                        return this._versions;
                    }
                }, {
                    key: 'ready',
                    value: function ready() {
                        return this._readyPromise;
                    }
                }, {
                    key: 'prepareReady',
                    value: function prepareReady(config) {
                        var self = this;
                        function resolve() {
                            self._readyResolve(config);
                        }
                        if (this._engineReady) {
                            // the engine provide a ready promise, use this instead
                            this._engineReady(resolve);
                        } else {
                            // there is no custom ready method from the engine
                            // use the default dom ready
                            dom.ready(resolve);
                        }
                    }
                }, {
                    key: 'domReady',
                    value: function domReady() {
                        // convenience method so its easy to access on Platform
                        return dom.ready.apply(this, arguments);
                    }
                }, {
                    key: 'windowLoad',
                    value: function windowLoad() {
                        // convenience method so its easy to access on Platform
                        return dom.windowLoad.apply(this, arguments);
                    }
                }, {
                    key: 'on',

                    // Methods meant to be overridden by the engine
                    // **********************************************
                    // Provided NOOP methods so they do not error when
                    // called by engines (the browser) doesn't provide them
                    value: function on() {}
                }, {
                    key: 'onHardwareBackButton',
                    value: function onHardwareBackButton() {}
                }, {
                    key: 'registerBackButtonAction',
                    value: function registerBackButtonAction() {}
                }, {
                    key: 'exitApp',
                    value: function exitApp() {}
                }, {
                    key: 'fullScreen',
                    value: function fullScreen() {}
                }, {
                    key: 'showStatusBar',
                    value: function showStatusBar() {}
                }, {
                    key: 'url',

                    // Getter/Setter Methods
                    // **********************************************
                    value: function url(val) {
                        if (arguments.length) {
                            this._url = val;
                            this._qs = util.getQuerystring(val);
                        }
                        return this._url;
                    }
                }, {
                    key: 'query',
                    value: function query(key) {
                        return (this._qs || {})[key];
                    }
                }, {
                    key: 'userAgent',
                    value: function userAgent(val) {
                        if (arguments.length) {
                            this._ua = val;
                        }
                        return this._ua;
                    }
                }, {
                    key: 'navigatorPlatform',
                    value: function navigatorPlatform(val) {
                        if (arguments.length) {
                            this._bPlt = val;
                        }
                        return this._bPlt || '';
                    }
                }, {
                    key: 'width',
                    value: function width() {
                        if (!this._w) {
                            this._w = window.innerWidth;
                            this._h = window.innerHeight;
                        }
                        return this._w;
                    }
                }, {
                    key: 'height',
                    value: function height() {
                        if (!this._h) {
                            this._w = window.innerWidth;
                            this._h = window.innerHeight;
                        }
                        return this._h;
                    }
                }, {
                    key: 'isPortrait',
                    value: function isPortrait() {
                        return this.width() < this.height();
                    }
                }, {
                    key: 'isLandscape',
                    value: function isLandscape() {
                        return !this.isPortrait();
                    }
                }, {
                    key: 'winResize',
                    value: function winResize() {
                        Platform._w = Platform._h = 0;
                        clearTimeout(Platform._resizeTimer);
                        Platform._resizeTimer = setTimeout(function () {
                            for (var i = 0; i < Platform._onResizes.length; i++) {
                                try {
                                    Platform._onResizes[i]();
                                } catch (e) {
                                    console.error(e);
                                }
                            }
                        }, 500);
                    }
                }, {
                    key: 'onResize',
                    value: function onResize(cb) {
                        // TODO: Make more good
                        this._onResizes.push(cb);
                    }
                }, {
                    key: 'register',

                    // Registry
                    // **********************************************
                    value: function register(platformConfig) {
                        this._registry[platformConfig.name] = platformConfig;
                    }
                }, {
                    key: 'registry',
                    value: function registry() {
                        return this._registry;
                    }
                }, {
                    key: 'setDefault',
                    value: function setDefault(platformName) {
                        this._default = platformName;
                    }
                }, {
                    key: 'testQuery',
                    value: function testQuery(queryValue) {
                        var val = this.query('ionicplatform');
                        if (val) {
                            var valueSplit = val.toLowerCase().split(';');
                            for (var i = 0; i < valueSplit.length; i++) {
                                if (valueSplit[i] == queryValue) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    }
                }, {
                    key: 'testUserAgent',
                    value: function testUserAgent(userAgentExpression) {
                        var rx = new RegExp(userAgentExpression, 'i');
                        return rx.test(this._ua);
                    }
                }, {
                    key: 'matchUserAgentVersion',
                    value: function matchUserAgentVersion(userAgentExpression) {
                        var val = this._ua.match(userAgentExpression);
                        if (val) {
                            return {
                                major: val[1],
                                minor: val[2]
                            };
                        }
                    }
                }, {
                    key: 'isPlatform',
                    value: function isPlatform(queryValue, userAgentExpression) {
                        if (!userAgentExpression) {
                            userAgentExpression = queryValue;
                        }
                        return this.testQuery(queryValue) || this.testUserAgent(userAgentExpression);
                    }
                }, {
                    key: 'load',
                    value: function load(config) {
                        var rootPlatformNode = null;
                        var engineNode = null;
                        var self = this;
                        this.platformOverride = config.setting('platform');
                        // figure out the most specific platform and active engine
                        var tmpPlatform = null;
                        for (var platformName in this._registry) {
                            tmpPlatform = this.matchPlatform(platformName);
                            if (tmpPlatform) {
                                // we found a platform match!
                                // check if its more specific than the one we already have
                                if (tmpPlatform.isEngine) {
                                    // because it matched then this should be the active engine
                                    // you cannot have more than one active engine
                                    engineNode = tmpPlatform;
                                } else if (!rootPlatformNode || tmpPlatform.depth > rootPlatformNode.depth) {
                                    // only find the root node for platforms that are not engines
                                    // set this node as the root since we either don't already
                                    // have one, or this one is more specific that the current one
                                    rootPlatformNode = tmpPlatform;
                                }
                            }
                        }
                        if (!rootPlatformNode) {
                            rootPlatformNode = new PlatformNode(this._default);
                        }
                        // build a Platform instance filled with the
                        // hierarchy of active platforms and settings
                        if (rootPlatformNode) {
                            // check if we found an engine node (cordova/node-webkit/etc)
                            if (engineNode) {
                                // add the engine to the first in the platform hierarchy
                                // the original rootPlatformNode now becomes a child
                                // of the engineNode, which is not the new root
                                engineNode.child(rootPlatformNode);
                                rootPlatformNode.parent(engineNode);
                                rootPlatformNode = engineNode;
                                // add any events which the engine would provide
                                // for example, Cordova provides its own ready event
                                var engineMethods = engineNode.methods();
                                engineMethods._engineReady = engineMethods.ready;
                                delete engineMethods.ready;
                                util.extend(this, engineMethods);
                            }
                            var platformNode = rootPlatformNode;
                            while (platformNode) {
                                insertSuperset(platformNode);
                                platformNode = platformNode.child();
                            }
                            // make sure the root noot is actually the root
                            // incase a node was inserted before the root
                            platformNode = rootPlatformNode.parent();
                            while (platformNode) {
                                rootPlatformNode = platformNode;
                                platformNode = platformNode.parent();
                            }
                            platformNode = rootPlatformNode;
                            while (platformNode) {
                                // set the array of active platforms with
                                // the last one in the array the most important
                                this._platforms.push(platformNode.name());
                                // copy default platform settings into this platform settings obj
                                this._settings[platformNode.name()] = util.extend({}, platformNode.settings());
                                // get the platforms version if a version parser was provided
                                this._versions[platformNode.name()] = platformNode.version(this);
                                // go to the next platform child
                                platformNode = platformNode.child();
                            }
                        }
                    }
                }, {
                    key: 'matchPlatform',
                    value: function matchPlatform(platformName) {
                        // build a PlatformNode and assign config data to it
                        // use it's getRoot method to build up its hierarchy
                        // depending on which platforms match
                        var platformNode = new PlatformNode(platformName);
                        var rootNode = platformNode.getRoot(this, 0);
                        if (rootNode) {
                            rootNode.depth = 0;
                            var childPlatform = rootNode.child();
                            while (childPlatform) {
                                rootNode.depth++;
                                childPlatform = childPlatform.child();
                            }
                        }
                        return rootNode;
                    }
                }, {
                    key: 'settings',
                    value: function settings(val) {
                        if (arguments.length) {
                            this._settings = val;
                        }
                        return this._settings;
                    }
                }, {
                    key: 'get',
                    value: function get(platformName) {
                        return this._registry[platformName] || {};
                    }
                }]);

                return PlatformCtrl;
            })();

            _export('PlatformCtrl', PlatformCtrl);

            PlatformNode = (function () {
                function PlatformNode(platformName) {
                    _classCallCheck(this, PlatformNode);

                    this.c = Platform.get(platformName);
                    this.isEngine = this.c.isEngine;
                }

                _createClass(PlatformNode, [{
                    key: 'name',
                    value: function name() {
                        return this.c.name;
                    }
                }, {
                    key: 'settings',
                    value: function settings() {
                        return this.c.settings || {};
                    }
                }, {
                    key: 'superset',
                    value: function superset() {
                        return this.c.superset;
                    }
                }, {
                    key: 'methods',
                    value: function methods() {
                        return this.c.methods || {};
                    }
                }, {
                    key: 'parent',
                    value: function parent(val) {
                        if (arguments.length) {
                            this._parent = val;
                        }
                        return this._parent;
                    }
                }, {
                    key: 'child',
                    value: function child(val) {
                        if (arguments.length) {
                            this._child = val;
                        }
                        return this._child;
                    }
                }, {
                    key: 'isMatch',
                    value: function isMatch(p) {
                        if (typeof this.c.isMatched !== 'boolean') {
                            if (p.platformOverride && !this.isEngine) {
                                this.c.isMatched = p.platformOverride === this.c.name;
                            } else if (!this.c.isMatch) {
                                this.c.isMatched = false;
                            } else {
                                this.c.isMatched = this.c.isMatch(p);
                            }
                        }
                        return this.c.isMatched;
                    }
                }, {
                    key: 'version',
                    value: function version(p) {
                        if (this.c.versionParser) {
                            var v = this.c.versionParser(p);
                            if (v) {
                                var str = v.major + '.' + v.minor;
                                return {
                                    str: str,
                                    num: parseFloat(str),
                                    major: parseInt(v.major, 10),
                                    minor: parseInt(v.minor, 10)
                                };
                            }
                        }
                    }
                }, {
                    key: 'getRoot',
                    value: function getRoot(p) {
                        if (this.isMatch(p)) {
                            var parents = this.getSubsetParents(this.name());
                            if (!parents.length) {
                                return this;
                            }
                            var platform = null;
                            var rootPlatform = null;
                            for (var i = 0; i < parents.length; i++) {
                                platform = new PlatformNode(parents[i]);
                                platform.child(this);
                                rootPlatform = platform.getRoot(p);
                                if (rootPlatform) {
                                    this.parent(platform);
                                    return rootPlatform;
                                }
                            }
                        }
                        return null;
                    }
                }, {
                    key: 'getSubsetParents',
                    value: function getSubsetParents(subsetPlatformName) {
                        var registry = Platform.registry();
                        var parentPlatformNames = [];
                        var platform = null;
                        for (var platformName in registry) {
                            platform = registry[platformName];
                            if (platform.subsets && platform.subsets.indexOf(subsetPlatformName) > -1) {
                                parentPlatformNames.push(platformName);
                            }
                        }
                        return parentPlatformNames;
                    }
                }]);

                return PlatformNode;
            })();

            Platform = new PlatformCtrl();

            _export('Platform', Platform);
        }
    };
});
System.register('ionic/platform/registry', ['./platform'], function (_export) {
    'use strict';

    var Platform;
    return {
        setters: [function (_platform) {
            Platform = _platform.Platform;
        }],
        execute: function () {
            Platform.register({
                name: 'core',
                settings: {
                    backButtonText: 'Back',
                    backButtonIcon: 'ion-ios-arrow-back',
                    forwardIcon: 'ion-ios-arrow-forward',
                    mode: 'ios',
                    iconMode: 'ios',
                    navTitleAlign: 'center',
                    viewTransition: 'ios'
                }
            });
            Platform.setDefault('core');
            Platform.register({
                name: 'mobile'
            });
            Platform.register({
                name: 'phablet',
                isMatch: function isMatch(p) {
                    var smallest = Math.min(p.width(), p.height());
                    var largest = Math.max(p.width(), p.height());
                    // http://www.mydevice.io/devices/
                    return smallest > 390 && smallest < 520 && (largest > 620 && largest < 800);
                }
            });
            Platform.register({
                name: 'tablet',
                isMatch: function isMatch(p) {
                    var smallest = Math.min(p.width(), p.height());
                    var largest = Math.max(p.width(), p.height());
                    // http://www.mydevice.io/devices/
                    return smallest > 460 && smallest < 820 && (largest > 780 && largest < 1400);
                }
            });
            Platform.register({
                name: 'android',
                superset: 'mobile',
                subsets: ['phablet', 'tablet'],
                settings: {
                    backButtonText: '',
                    backButtonIcon: 'ion-android-arrow-back',
                    forwardIcon: '',
                    mode: 'md',
                    iconMode: 'md',
                    type: 'overlay',
                    keyboardScrollAssist: true,
                    mdRipple: true,
                    tabBarPlacement: 'top',
                    navTitleAlign: 'left',
                    viewTransition: 'md'
                },
                isMatch: function isMatch(p) {
                    // "silk" is kindle fire
                    return p.isPlatform('android', 'android| silk');
                },
                versionParser: function versionParser(p) {
                    return p.matchUserAgentVersion(/Android (\d+).(\d+)?/);
                }
            });
            Platform.register({
                name: 'ios',
                superset: 'mobile',
                subsets: ['ipad', 'iphone'],
                settings: {
                    backButtonText: 'Back',
                    backButtonIcon: 'ion-ios-arrow-back',
                    forwardIcon: 'ion-ios-arrow-forward',
                    mode: 'ios',
                    iconMode: 'ios',
                    tapPolyfill: function tapPolyfill() {
                        // this ensures it's actually a physical iOS device
                        // and not just an a spoofed user-agent string
                        return /iphone|ipad|ipod/i.test(Platform.navigatorPlatform());
                    },
                    keyboardScrollAssist: true,
                    viewTransition: 'ios',
                    navTitleAlign: 'center',
                    mdRipple: false
                },
                isMatch: function isMatch(p) {
                    return p.isPlatform('ios', 'iphone|ipad|ipod');
                },
                versionParser: function versionParser(p) {
                    return p.matchUserAgentVersion(/OS (\d+)_(\d+)?/);
                }
            });
            Platform.register({
                name: 'ipad',
                superset: 'tablet',
                isMatch: function isMatch(p) {
                    return p.isPlatform('ipad');
                }
            });
            Platform.register({
                name: 'iphone',
                subsets: ['phablet'],
                isMatch: function isMatch(p) {
                    return p.isPlatform('iphone');
                }
            });
            Platform.register({
                name: 'windowsphone',
                superset: 'mobile',
                subsets: ['phablet', 'tablet'],
                settings: {
                    mode: 'wp',
                    iconMode: 'md',
                    viewTransition: 'md'
                },
                isMatch: function isMatch(p) {
                    return p.isPlatform('windowsphone', 'windows phone');
                },
                versionParser: function versionParser(p) {
                    return p.matchUserAgentVersion(/Windows Phone (\d+).(\d+)?/);
                }
            });
            Platform.register({
                name: 'cordova',
                isEngine: true,
                methods: {
                    ready: function ready(resolve) {
                        Platform.windowLoad(function () {
                            document.addEventListener('deviceready', resolve);
                        });
                    }
                },
                isMatch: function isMatch(p) {
                    return !!(window.cordova || window.PhoneGap || window.phonegap);
                }
            });
        }
    };
});
System.register('ionic/net/http', ['ionic/util'], function (_export) {
    'use strict';

    var util, Http;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            //TODO(mlynch): surely, there must be another way, sir?
            window._jsonpcallbacks = {
                counter: 0
            };
            /**
             * The Http class makes it easy to send GET/POST/PUT/DELETE/PATCH requests
             * and send/receive JSON (or anything else) through a simple API.
             *
             * Http uses the `fetch()` API underneath, or a polyfill if it's not natively supported.
             */

            Http = (function () {
                function Http() {
                    _classCallCheck(this, Http);
                }

                _createClass(Http, null, [{
                    key: 'fetch',

                    /**
                     * The raw fetch() operation.
                     *
                     * Generally, you want to use one of get()/post()/put()/delete() but
                     * this is useful if you want to do something crazy.
                     *
                     * @param url the URL to pass to fetch
                     * @param options the options to configure the fetch
                     * @return es6 promise from the fetch.
                     */
                    value: function fetch(url, options) {
                        return window.fetch(url, options).then(function (response) {
                            // status "0" to handle local files fetching (e.g. Cordova/Phonegap etc.)
                            if (response.status === 200 || response.status === 0) {
                                // We have a good response, let's check the response headers and return
                                // deserialized JSON or return the text from the response.
                                if (response.headers.get('Content-Type') === 'application/json') {
                                    return response.json();
                                }
                                return response.text();
                            } else {
                                return Promise.reject(response, new Error(response.statusText));
                            }
                        })['catch'](function (err) {
                            return Promise.reject(err);
                        });
                    }
                }, {
                    key: 'jsonp',
                    value: function jsonp(url, callbackId, options) {
                        return new Promise(function (resolve, reject) {
                            var script = document.createElement('script');
                            script.src = url;
                            script.async = true;
                            script.type = 'text/javascript';
                            var callback = function callback(event) {
                                script.removeEventListener('load', callback);
                                script.removeEventListener('error', callback);
                                document.body.removeChild(script);
                                var text = undefined,
                                    status = undefined;
                                if (event) {
                                    if (event.type === 'load' && !window._jsonpcallbacks[callbackId].called) {
                                        event = { type: 'error' };
                                    }
                                    text = event.type;
                                    status = event.type === 'error' ? 404 : 200;
                                    resolve(window._jsonpcallbacks[callbackId].data, status, text);
                                } else {
                                    reject();
                                }
                                /*
                                var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId),
                                    callbackId, function(status, text) {
                                  completeRequest(callback, status, callbacks[callbackId].data, "", text);
                                  callbacks[callbackId] = noop;
                                });
                                */
                            };
                            script.addEventListener('load', callback);
                            script.addEventListener('error', callback);
                            document.body.appendChild(script);
                            return callback;
                        });
                    }
                }, {
                    key: '_method',
                    value: function _method(method, url, data, options, sendsJson) {
                        options = util.defaults(options, {
                            method: method,
                            headers: {
                                'Accept': 'application/json,text/plain,*/*'
                            }
                        });
                        if (options.body) {
                            options.body = typeof data === 'string' ? data : JSON.stringify(data);
                        }
                        if (sendsJson) {
                            options.headers['Content-Type'] = 'application/json';
                        }
                        if (options.method == 'jsonp') {
                            var callbackId;

                            var _ret = (function () {
                                // Adopted from Angular 1
                                var callbacks = window._jsonpcallbacks;
                                callbackId = '_' + (callbacks.counter++).toString(36);

                                callbacks[callbackId] = function (data) {
                                    callbacks[callbackId].data = data;
                                    callbacks[callbackId].called = true;
                                };
                                /*
                                var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId),
                                    callbackId, function(status, text) {
                                  completeRequest(callback, status, callbacks[callbackId].data, "", text);
                                  callbacks[callbackId] = noop;
                                });
                                */
                                url = url.replace('JSON_CALLBACK', '_jsonpcallbacks.' + callbackId);
                                return {
                                    v: Http.jsonp(url, callbackId, options)
                                };
                            })();

                            if (typeof _ret === 'object') return _ret.v;
                        } else {
                            return Http.fetch(url, options);
                        }
                    }
                }, {
                    key: 'get',

                    /**
                     * Send a GET request to the given URL.
                     *
                     * By default, options sends the `Accept` header as `application/json,text/plain,* / *`,
                     *
                     * @param url the URL to POST to
                     * @param options the options to configure the post with.
                     * @return promise
                     */
                    value: function get(url) {
                        var options = arguments[1] === undefined ? {} : arguments[1];

                        return Http._method('get', url, {}, options);
                    }
                }, {
                    key: 'post',

                    /**
                     * Send a POST request to the given URL.
                     *
                     * By default, options sends the `Accept` header as `application/json,text/plain,* / *`,
                     * and the `Content-Type` header as `application/json`
                     *
                     * @param url the URL to POST to
                     * @param options the options to configure the post with.
                     * @return promise
                     */
                    value: function post(url) {
                        var data = arguments[1] === undefined ? {} : arguments[1];
                        var options = arguments[2] === undefined ? {} : arguments[2];

                        return Http._method('post', url, data, options, true);
                    }
                }, {
                    key: 'put',

                    /**
                     * Send a PUT request to the given URL.
                     *
                     * By default, options sends the `Accept` header as `application/json,text/plain,* / *`,
                     * and the `Content-Type` header as `application/json`
                     *
                     * @param url the URL to PUT to
                     * @param data the JSON data to send
                     * @param options the options to configure the post with.
                     * @return promise
                     */
                    value: function put(url) {
                        var data = arguments[1] === undefined ? {} : arguments[1];
                        var options = arguments[2] === undefined ? {} : arguments[2];

                        return Http._method('put', url, data, options, true);
                    }
                }, {
                    key: 'delete',

                    /**
                     * Send a DELETE request to the given URL.
                     *
                     * By default, options sends the `Accept` header as `application/json,text/plain,* / *`,
                     * and the `Content-Type` header as `application/json`
                     *
                     * @param url the URL to DELETE to
                     * @param data the JSON data to send
                     * @param options the options to configure the post with.
                     * @return promise
                     */
                    value: function _delete(url) {
                        var data = arguments[1] === undefined ? {} : arguments[1];
                        var options = arguments[2] === undefined ? {} : arguments[2];

                        return Http._method('delete', url, data, options, true);
                    }
                }, {
                    key: 'patch',

                    /**
                     * Send a PATH request to the given URL.
                     *
                     * By default, options sends the `Accept` header as `application/json,text/plain,* / *`,
                     * and the `Content-Type` header as `application/json`
                     *
                     * @param url the URL to PATH to
                     * @param options the options to configure the post with.
                     * @return promise
                     */
                    value: function patch(url) {
                        var data = arguments[1] === undefined ? {} : arguments[1];
                        var options = arguments[2] === undefined ? {} : arguments[2];

                        return Http._method('patch', url, data, options, true);
                    }
                }]);

                return Http;
            })();

            _export('Http', Http);
        }
    };
});
System.register('ionic/routing/path-recognizer', ['angular2/src/facade/lang', 'angular2/src/facade/collection'], function (_export) {
    'use strict';

    var RegExpWrapper, StringWrapper, isPresent, BaseException, normalizeBlank, StringMapWrapper, ListWrapper, ContinuationSegment, StaticSegment, DynamicSegment, StarSegment, paramMatcher, wildcardMatcher, PathRecognizer, specialCharacters, escapeRe;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function parsePathString(route) {
        // normalize route as not starting with a "/". Recognition will
        // also normalize.
        if (StringWrapper.startsWith(route, '/')) {
            route = StringWrapper.substring(route, 1);
        }
        var segments = splitBySlash(route);
        var results = [];
        var specificity = 0;
        // The "specificity" of a path is used to determine which route is used when multiple routes match
        // a URL.
        // Static segments (like "/foo") are the most specific, followed by dynamic segments (like
        // "/:id"). Star segments
        // add no specificity. Segments at the start of the path are more specific than proceeding ones.
        // The code below uses place values to combine the different types of segments into a single
        // integer that we can
        // sort later. Each static segment is worth hundreds of points of specificity (10000, 9900, ...,
        // 200), and each
        // dynamic segment is worth single points of specificity (100, 99, ... 2).
        if (segments.length > 98) {
            throw new BaseException('\'' + route + '\' has more than the maximum supported number of segments.');
        }
        var limit = segments.length - 1;
        for (var i = 0; i <= limit; i++) {
            var segment = segments[i],
                match;
            if (isPresent(match = RegExpWrapper.firstMatch(paramMatcher, segment))) {
                results.push(new DynamicSegment(match[1]));
                specificity += 100 - i;
            } else if (isPresent(match = RegExpWrapper.firstMatch(wildcardMatcher, segment))) {
                results.push(new StarSegment(match[1]));
            } else if (segment == '...') {
                if (i < limit) {
                    // TODO (matsko): setup a proper error here `
                    throw new BaseException('Unexpected "..." before the end of the path for "' + route + '".');
                }
                results.push(new ContinuationSegment());
            } else if (segment.length > 0) {
                results.push(new StaticSegment(segment));
                specificity += 100 * (100 - i);
            }
        }
        return { segments: results, specificity: specificity };
    }
    function splitBySlash(url) {
        return url.split('/');
    }

    function escapeRegex(string) {
        return StringWrapper.replaceAllMapped(string, escapeRe, function (match) {
            return '\\' + match;
        });
    }
    return {
        setters: [function (_angular2SrcFacadeLang) {
            RegExpWrapper = _angular2SrcFacadeLang.RegExpWrapper;
            StringWrapper = _angular2SrcFacadeLang.StringWrapper;
            isPresent = _angular2SrcFacadeLang.isPresent;
            BaseException = _angular2SrcFacadeLang.BaseException;
            normalizeBlank = _angular2SrcFacadeLang.normalizeBlank;
        }, function (_angular2SrcFacadeCollection) {
            StringMapWrapper = _angular2SrcFacadeCollection.StringMapWrapper;
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }],
        execute: function () {
            ContinuationSegment = (function () {
                function ContinuationSegment() {
                    _classCallCheck(this, ContinuationSegment);
                }

                _createClass(ContinuationSegment, [{
                    key: 'generate',
                    value: function generate(params) {
                        return '';
                    }
                }]);

                return ContinuationSegment;
            })();

            StaticSegment = (function () {
                function StaticSegment(string) {
                    _classCallCheck(this, StaticSegment);

                    this.name = '';
                    this.regex = escapeRegex(string);
                }

                _createClass(StaticSegment, [{
                    key: 'generate',
                    value: function generate() {
                        return this.regex;
                    }
                }]);

                return StaticSegment;
            })();

            DynamicSegment = (function () {
                function DynamicSegment(name) {
                    _classCallCheck(this, DynamicSegment);

                    this.regex = '([^/]+)';
                }

                _createClass(DynamicSegment, [{
                    key: 'generate',
                    value: function generate(params) {
                        if (!StringMapWrapper.contains(params, this.name)) {
                            throw new BaseException('Route generator for \'' + this.name + '\' was not included in parameters passed.');
                        }
                        return normalizeBlank(StringMapWrapper.get(params, this.name));
                    }
                }]);

                return DynamicSegment;
            })();

            StarSegment = (function () {
                function StarSegment(name) {
                    _classCallCheck(this, StarSegment);

                    this.regex = '(.+)';
                }

                _createClass(StarSegment, [{
                    key: 'generate',
                    value: function generate(params) {
                        return normalizeBlank(StringMapWrapper.get(params, this.name));
                    }
                }]);

                return StarSegment;
            })();

            paramMatcher = RegExpWrapper.create('^:([^/]+)$');
            wildcardMatcher = RegExpWrapper.create('^\\*([^/]+)$');
            // represents something like '/foo/:bar'

            PathRecognizer = (function () {
                function PathRecognizer(path) {
                    var _this = this;

                    _classCallCheck(this, PathRecognizer);

                    this.segments = [];
                    var parsed = parsePathString(path);
                    var specificity = parsed['specificity'];
                    var segments = parsed['segments'];
                    var regexString = '^';
                    ListWrapper.forEach(segments, function (segment) {
                        if (segment instanceof ContinuationSegment) {
                            _this.terminal = false;
                        } else {
                            regexString += '/' + segment.regex;
                        }
                    });
                    if (this.terminal) {
                        regexString += '$';
                    }
                    this.regex = RegExpWrapper.create(regexString);
                    this.segments = segments;
                    this.specificity = specificity;
                }

                _createClass(PathRecognizer, [{
                    key: 'parseParams',
                    value: function parseParams(url) {
                        var params = StringMapWrapper.create();
                        var urlPart = url;
                        for (var i = 0; i < this.segments.length; i++) {
                            var segment = this.segments[i];
                            if (segment instanceof ContinuationSegment) {
                                continue;
                            }
                            var match = RegExpWrapper.firstMatch(RegExpWrapper.create('/' + segment.regex), urlPart);
                            urlPart = StringWrapper.substring(urlPart, match[0].length);
                            if (segment.name.length > 0) {
                                StringMapWrapper.set(params, segment.name, match[1]);
                            }
                        }
                        return params;
                    }
                }, {
                    key: 'generate',
                    value: function generate(params) {
                        return ListWrapper.join(ListWrapper.map(this.segments, function (segment) {
                            return '/' + segment.generate(params);
                        }), '');
                    }
                }]);

                return PathRecognizer;
            })();

            _export('PathRecognizer', PathRecognizer);

            specialCharacters = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\'];
            escapeRe = RegExpWrapper.create('(\\' + specialCharacters.join('|\\') + ')', 'g');
        }
    };
});
System.register('ionic/routing/router', ['angular2/src/facade/lang', '../util/util', './path-recognizer'], function (_export) {
    'use strict';

    var RegExpWrapper, util, PathRecognizer, IonicRouter, stateManagerClasses, stateManagers, Route;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_angular2SrcFacadeLang) {
            RegExpWrapper = _angular2SrcFacadeLang.RegExpWrapper;
        }, function (_utilUtil) {
            util = _utilUtil;
        }, function (_pathRecognizer) {
            PathRecognizer = _pathRecognizer.PathRecognizer;
        }],
        execute: function () {
            IonicRouter = (function () {
                function IonicRouter(config) {
                    _classCallCheck(this, IonicRouter);

                    this._routes = [];
                    this._viewCtrls = [];
                    this.config(config);
                }

                _createClass(IonicRouter, [{
                    key: 'app',
                    value: function app(_app) {
                        this.app = _app;
                    }
                }, {
                    key: 'config',
                    value: function config(_config) {
                        if (_config) {
                            for (var i = 0; i < _config.length; i++) {
                                this.addRoute(_config[i]);
                            }
                        }
                    }
                }, {
                    key: 'addRoute',
                    value: function addRoute(routeConfig) {
                        if (routeConfig && routeConfig.path && routeConfig.component) {
                            var route = new Route(routeConfig);
                            if (routeConfig.root) {
                                this.otherwise(route);
                            }
                            this._routes.push(route);
                        }
                    }
                }, {
                    key: 'stateChange',
                    value: function stateChange(type, activeView) {
                        // this fires when the app's state has changed. `stateChange` will
                        // tell each of the state managers that the state has changed, and
                        // each state manager will decide what to do with this info
                        // (the url state manager updates the url bar if a route was setup)
                        if (activeView && activeView.component) {
                            var componentRoute = activeView.component.route;
                            if (componentRoute) {
                                var path = componentRoute.generate(activeView.params);
                                if (path) {
                                    for (var _name in stateManagers) {
                                        stateManagers[_name].stateChange(path, type, activeView);
                                    }
                                }
                            }
                        }
                    }
                }, {
                    key: 'stateClear',
                    value: function stateClear() {
                        for (var _name2 in stateManagers) {
                            stateManagers[_name2].stateClear();
                        }
                    }
                }, {
                    key: 'matchPaths',
                    value: function matchPaths(paths) {
                        // load each of paths to a component
                        var components = [];
                        var route = undefined;
                        if (paths) {
                            for (var i = 0; i < paths.length; i++) {
                                route = this.matchPath(paths[i]);
                                if (route && route.component) {
                                    components.push(route.component);
                                }
                            }
                        }
                        return components;
                    }
                }, {
                    key: 'matchPath',
                    value: function matchPath(path) {
                        // takes a string path and loops through each of the setup
                        // routes to see if the path matches any of the routes
                        // the matched path with the highest specifity wins
                        var matchedRoute = null;
                        var route = null;
                        var routeMatch = null;
                        for (var i = 0; i < this._routes.length; i++) {
                            route = this._routes[i];
                            routeMatch = route.match(path);
                            if (routeMatch && (!matchedRoute || route.specificity > matchedRoute.specificity)) {
                                matchedRoute = route;
                            }
                        }
                        return matchedRoute;
                    }
                }, {
                    key: 'load',
                    value: function load(window, ionicApp, ionicConfig) {
                        var _this = this;

                        // load is called when the app has finished loading each state
                        // manager gets a chance to say what path the app should be at
                        var viewCtrl = this.viewController();
                        if (!viewCtrl || !this._routes.length) {
                            return Promise.resolve();
                        }
                        var resolve = undefined;
                        var promise = new Promise(function (res) {
                            resolve = res;
                        });
                        // get the initial load paths from the state manager with the highest priorty
                        this.getManagerPaths(window, ionicApp, ionicConfig).then(function (paths) {
                            // load all of the paths the highest priority state manager has given
                            var components = _this.matchPaths(paths);
                            if (!components.length && _this.otherwise()) {
                                // the state manager did not find and loaded components
                                // use the "otherwise" path
                                components = [_this.otherwise().component];
                            }
                            _this.app.zoneRun(function () {
                                viewCtrl.setItems(components).then(resolve);
                            });
                        });
                        return promise;
                    }
                }, {
                    key: 'getManagerPaths',
                    value: function getManagerPaths(window, ionicApp, ionicConfig) {
                        // loop through all of the state managers and load their paths
                        // the state manager with valid paths and highest priority wins
                        var resolve = undefined;
                        var promise = new Promise(function (res) {
                            resolve = res;
                        });
                        // load each of the state managers
                        var stateManagerPromises = [];
                        for (var _name3 in stateManagerClasses) {
                            stateManagers[_name3] = new stateManagerClasses[_name3](window, this, ionicApp, ionicConfig);
                            stateManagerPromises.push(stateManagers[_name3].load());
                        }
                        // when all the state manager loads have resolved then see which one wins
                        Promise.all(stateManagerPromises).then(function (stateManagerLoadResults) {
                            // now that all the state managers are loaded
                            // get the highest priority state manager's paths
                            var stateLoadResult = null;
                            var paths = null;
                            var highestPriority = -1;
                            for (var i = 0; i < stateManagerLoadResults.length; i++) {
                                stateLoadResult = stateManagerLoadResults[i];
                                if (stateLoadResult && stateLoadResult.paths.length && stateLoadResult.priority > highestPriority) {
                                    paths = stateLoadResult.paths;
                                    highestPriority = stateLoadResult.priority;
                                }
                            }
                            resolve(paths);
                        });
                        return promise;
                    }
                }, {
                    key: 'push',
                    value: function push(path) {
                        var _this2 = this;

                        var viewCtrl = this.viewController();
                        if (viewCtrl) {
                            (function () {
                                var matchedRoute = _this2.matchPath(path);
                                if (matchedRoute && matchedRoute.component) {
                                    _this2.app.zoneRun(function () {
                                        viewCtrl.push(matchedRoute.component, matchedRoute.params, {});
                                    });
                                }
                            })();
                        }
                    }
                }, {
                    key: 'pop',
                    value: function pop() {
                        var viewCtrl = this.viewController();
                        if (viewCtrl) {
                            this.app.zoneRun(function () {
                                viewCtrl.pop();
                            });
                        }
                    }
                }, {
                    key: 'otherwise',
                    value: function otherwise(val) {
                        if (arguments.length) {
                            this._otherwise = val;
                        }
                        return this._otherwise;
                    }
                }, {
                    key: 'addViewController',
                    value: function addViewController(viewCtrl) {
                        this._viewCtrls.push(viewCtrl);
                    }
                }, {
                    key: 'viewController',
                    value: function viewController() {
                        if (this._viewCtrls.length) {
                            return this._viewCtrls[this._viewCtrls.length - 1];
                        }
                    }
                }], [{
                    key: 'registerStateManager',
                    value: function registerStateManager(name, StateManagerClass) {
                        stateManagerClasses[name] = StateManagerClass;
                    }
                }, {
                    key: 'deregisterStateManager',
                    value: function deregisterStateManager(name) {
                        delete stateManagerClasses[name];
                        delete stateManagers[name];
                    }
                }]);

                return IonicRouter;
            })();

            _export('IonicRouter', IonicRouter);

            stateManagerClasses = {};
            stateManagers = {};

            Route = (function () {
                function Route(routeConfig) {
                    _classCallCheck(this, Route);

                    util.extend(this, routeConfig);
                    this.recognizer = new PathRecognizer(this.path);
                    this.specificity = this.recognizer.specificity;
                    this.component.route = this;
                }

                _createClass(Route, [{
                    key: 'match',
                    value: function match(path) {
                        return RegExpWrapper.firstMatch(this.recognizer.regex, path);
                    }
                }, {
                    key: 'generate',
                    value: function generate(params) {
                        return this.recognizer.generate(params);
                    }
                }]);

                return Route;
            })();
        }
    };
});
System.register('ionic/routing/url-state', ['./router'], function (_export) {
    'use strict';

    var IonicRouter, UrlStateManager, PATH_STORE_KEY, MAX_PATH_STORE;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_router) {
            IonicRouter = _router.IonicRouter;
        }],
        execute: function () {
            UrlStateManager = (function () {
                function UrlStateManager(window, router) {
                    var _this = this;

                    _classCallCheck(this, UrlStateManager);

                    this.location = window.location;
                    this.history = window.history;
                    this.ls = window.localStorage;
                    this.router = router;
                    // overkill for location change listeners, but ensures we
                    // know when the location has changed. Only 1 of the listeners
                    // will actually do the work, the other will be skipped.
                    window.addEventListener('popstate', function () {
                        _this.onLocationChange();
                    });
                    window.addEventListener('hashchange', function () {
                        _this.onLocationChange();
                    });
                }

                _createClass(UrlStateManager, [{
                    key: 'load',
                    value: function load() {
                        var paths = [this.getCurrentPath()];
                        var savedPaths = this.paths();
                        if (savedPaths[savedPaths.length - 1] == paths[0]) {
                            // the last path in the saved paths is the same as the
                            // current path, so use the saved paths to rebuild the history
                            paths = savedPaths;
                        } else {
                            // the current path is not the same as the last path in the
                            // saved history, so the saved history is no good, erase it
                            this.paths([]);
                        }
                        return Promise.resolve({
                            paths: paths,
                            priority: 0
                        });
                    }
                }, {
                    key: 'stateChange',
                    value: function stateChange(path, type, activeView) {
                        var savedPaths = this.paths();
                        // check if the given path is different than the current location
                        var isDifferentPath = this.getCurrentPath() !== path;
                        if (type == 'pop') {
                            // if the popstate came from the browser's back button (and not Ionic)
                            // then we shouldn't force another browser history.back()
                            // only do a history.back() if the URL hasn't been updated yet
                            if (isDifferentPath) {
                                this.history.back();
                            }
                            if (savedPaths.length && savedPaths[savedPaths.length - 1] != path) {
                                // only if the last item in the saved paths
                                // equals this path then it can be removed
                                savedPaths.pop();
                            }
                        } else {
                            if (this._hasInit) {
                                if (isDifferentPath) {
                                    // push the new state to the history stack since the path
                                    // isn't already in the location hash
                                    this.history.pushState(path, '', '#' + path);
                                }
                            } else {
                                // replace the very first load with the correct entering state info
                                this.history.replaceState(path, '', '#' + path);
                                this._hasInit = true;
                            }
                            if (savedPaths[savedPaths.length - 1] != path) {
                                // only if the last item in the saved paths does
                                // not equal this path then it can be added
                                savedPaths.push(path);
                                // don't allow the history to grow too large
                                if (savedPaths.length > MAX_PATH_STORE) {
                                    savedPaths = savedPaths.slice(savedPaths.length - MAX_PATH_STORE);
                                }
                            }
                        }
                        // save the new path data
                        this.paths(savedPaths);
                        // ensure this resets
                        this._currentPath = null;
                    }
                }, {
                    key: 'stateClear',
                    value: function stateClear() {
                        this.paths([]);
                    }
                }, {
                    key: 'onLocationChange',
                    value: function onLocationChange() {
                        var currentPath = this.getCurrentPath();
                        if (currentPath == this._currentPath) {
                            // absolutely no change since last onLocationChange
                            return;
                        }
                        // keep in-memory the current path to quickly tell if things have changed
                        this._currentPath = currentPath;
                        // load up the saved paths
                        var savedPaths = this.paths();
                        if (currentPath === savedPaths[savedPaths.length - 1]) {
                            // do nothing if the last saved path is
                            // the same as the current path
                            return;
                        }
                        if (currentPath === savedPaths[savedPaths.length - 2]) {
                            // the user is moving back
                            this.router.pop();
                        } else {
                            // the user is moving forward
                            this.router.push(currentPath);
                        }
                    }
                }, {
                    key: 'paths',
                    value: function paths(val) {
                        if (arguments.length) {
                            // set in-memory data
                            this._paths = val;
                            // set localStorage data
                            try {
                                this.ls.setItem(PATH_STORE_KEY, JSON.stringify(val));
                            } catch (e) {}
                        } else {
                            if (!this._paths) {
                                // we don't already have data in-memory
                                // see if we have data in localStorage
                                try {
                                    var strData = this.ls.getItem(PATH_STORE_KEY);
                                    if (strData) {
                                        this._paths = JSON.parse(strData);
                                    }
                                } catch (e) {}
                                // if not in localStorage yet then create new path data
                                if (!this._paths) {
                                    this._paths = [];
                                }
                            }
                            // return the in-memory data
                            return this._paths;
                        }
                    }
                }, {
                    key: 'getCurrentPath',
                    value: function getCurrentPath() {
                        // remove leading # to get the path
                        return this.location.hash.slice(1);
                    }
                }]);

                return UrlStateManager;
            })();

            PATH_STORE_KEY = 'ionic:history';
            MAX_PATH_STORE = 20;

            IonicRouter.registerStateManager('url', UrlStateManager);
        }
    };
});
System.register('ionic/util/activator', ['./dom'], function (_export) {
    'use strict';

    var raf, queueElements, activeElements, keyId, ACTIVATED_CLASS, DEACTIVATE_TIMEOUT, Activator;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_dom) {
            raf = _dom.raf;
        }],
        execute: function () {
            queueElements = {};
            // elements that should get an active state in XX milliseconds
            activeElements = {};
            // elements that are currently active
            keyId = 0;
            // a counter for unique keys for the above ojects
            ACTIVATED_CLASS = 'activated';
            DEACTIVATE_TIMEOUT = 180;

            Activator = (function () {
                function Activator() {
                    _classCallCheck(this, Activator);
                }

                _createClass(Activator, null, [{
                    key: 'start',
                    value: function start(ele) {
                        queueElements[++keyId] = ele;
                        if (keyId > 9) keyId = 0;
                        raf(Activator.activate);
                    }
                }, {
                    key: 'activate',
                    value: function activate() {
                        // activate all elements in the queue
                        for (var key in queueElements) {
                            if (queueElements[key]) {
                                queueElements[key].classList.add(ACTIVATED_CLASS);
                                activeElements[key] = queueElements[key];
                            }
                        }
                        queueElements = {};
                    }
                }, {
                    key: 'end',
                    value: function end() {
                        setTimeout(Activator.clear, DEACTIVATE_TIMEOUT);
                    }
                }, {
                    key: 'clear',
                    value: function clear() {
                        // clear out any elements that are queued to be set to active
                        queueElements = {};
                        // in the next frame, remove the active class from all active elements
                        raf(Activator.deactivate);
                    }
                }, {
                    key: 'deactivate',
                    value: function deactivate() {
                        for (var key in activeElements) {
                            if (activeElements[key]) {
                                activeElements[key].classList.remove(ACTIVATED_CLASS);
                            }
                            delete activeElements[key];
                        }
                    }
                }, {
                    key: 'moveListeners',
                    value: function moveListeners(pointerMove, shouldAdd) {
                        document.removeEventListener('touchmove', pointerMove);
                        document.removeEventListener('mousemove', pointerMove);
                        if (shouldAdd) {
                            document.addEventListener('touchmove', pointerMove);
                            document.addEventListener('mousemove', pointerMove);
                        }
                    }
                }]);

                return Activator;
            })();

            _export('Activator', Activator);
        }
    };
});
System.register('ionic/util/click-block', [], function (_export) {
    'use strict';

    var CSS_CLICK_BLOCK, DEFAULT_EXPIRE, cbEle, fallbackTimerId, isShowing, ClickBlock;

    function disableInput(ev) {
        ev.preventDefault();
        ev.stopPropagation();
    }
    function show(expire) {
        clearTimeout(fallbackTimerId);
        fallbackTimerId = setTimeout(hide, expire || DEFAULT_EXPIRE);
        if (!isShowing) {
            isShowing = true;
            if (cbEle) {
                cbEle.classList.add(CSS_CLICK_BLOCK);
            } else {
                cbEle = document.createElement('div');
                cbEle.className = 'click-block ' + CSS_CLICK_BLOCK;
                document.body.appendChild(cbEle);
            }
            cbEle.addEventListener('touchmove', disableInput);
        }
    }
    function hide() {
        clearTimeout(fallbackTimerId);
        if (isShowing) {
            cbEle.classList.remove(CSS_CLICK_BLOCK);
            isShowing = false;
            cbEle.removeEventListener('touchmove', disableInput);
        }
    }
    return {
        setters: [],
        execute: function () {
            CSS_CLICK_BLOCK = 'click-block-active';
            DEFAULT_EXPIRE = 330;
            cbEle = undefined;
            fallbackTimerId = undefined;
            isShowing = false;

            ClickBlock = function ClickBlock(shouldShow, expire) {
                (shouldShow ? show : hide)(expire);
            };

            _export('ClickBlock', ClickBlock);
        }
    };
});
System.register('ionic/util/dom', ['angular2/src/facade/async'], function (_export) {
    'use strict';

    var Promise, nativeRaf, nativeCancelRaf, raf, rafCancel, CSS;

    _export('rafPromise', rafPromise);

    _export('transitionEnd', transitionEnd);

    _export('animationStart', animationStart);

    _export('animationEnd', animationEnd);

    _export('ready', ready);

    _export('windowLoad', windowLoad);

    _export('pointerCoord', pointerCoord);

    _export('hasPointerMoved', hasPointerMoved);

    _export('hasFocus', hasFocus);

    function rafPromise() {
        return new Promise(function (resolve) {
            return raf(resolve);
        });
    }

    function transitionEnd(el) {
        return cssPromise(el, CSS.transitionEnd);
    }

    function animationStart(el, animationName) {
        return cssPromise(el, CSS.animationStart, animationName);
    }

    function animationEnd(el, animationName) {
        return cssPromise(el, CSS.animationEnd, animationName);
    }

    function cssPromise(el, eventNames, animationName) {
        return new Promise(function (resolve) {
            eventNames.split(' ').forEach(function (eventName) {
                el.addEventListener(eventName, onEvent);
            });
            function onEvent(ev) {
                if (ev.animationName && animationName) {
                    // do not resolve if a bubbled up ev.animationName
                    // is not the same as the passed in animationName arg
                    if (ev.animationName !== animationName) {
                        return;
                    }
                } else if (ev.target !== el) {
                    // do not resolve if the event's target element is not
                    // the same as the element the listener was added to
                    return;
                }
                ev.stopPropagation();
                eventNames.split(' ').forEach(function (eventName) {
                    el.removeEventListener(eventName, onEvent);
                });
                resolve(ev);
            }
        });
    }

    function ready(callback) {
        var promise = null;
        if (!callback) {
            // a callback wasn't provided, so let's return a promise instead
            promise = new Promise(function (resolve) {
                callback = resolve;
            });
        }
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            callback();
        } else {
            (function () {
                var completed = function completed() {
                    document.removeEventListener('DOMContentLoaded', completed, false);
                    window.removeEventListener('load', completed, false);
                    callback();
                };

                document.addEventListener('DOMContentLoaded', completed, false);
                window.addEventListener('load', completed, false);
            })();
        }
        return promise;
    }

    function windowLoad(callback) {
        var promise = null;
        if (!callback) {
            // a callback wasn't provided, so let's return a promise instead
            promise = new Promise(function (resolve) {
                callback = resolve;
            });
        }
        if (document.readyState === 'complete') {
            callback();
        } else {
            (function () {
                var completed = function completed() {
                    window.removeEventListener('load', completed, false);
                    callback();
                };

                window.addEventListener('load', completed, false);
            })();
        }
        return promise;
    }

    function pointerCoord(ev) {
        // get coordinates for either a mouse click
        // or a touch depending on the given event
        var c = { x: 0, y: 0 };
        if (ev) {
            var touches = ev.touches && ev.touches.length ? ev.touches : [ev];
            var e = ev.changedTouches && ev.changedTouches[0] || touches[0];
            if (e) {
                c.x = e.clientX || e.pageX || 0;
                c.y = e.clientY || e.pageY || 0;
            }
        }
        return c;
    }

    function hasPointerMoved(threshold, startCoord, endCoord) {
        return startCoord && endCoord && (Math.abs(startCoord.x - endCoord.x) > threshold || Math.abs(startCoord.y - endCoord.y) > threshold);
    }

    function hasFocus(ele) {
        return !!(ele && (document.activeElement === ele.nativeElement || document.activeElement === ele));
    }

    return {
        setters: [function (_angular2SrcFacadeAsync) {
            Promise = _angular2SrcFacadeAsync.Promise;
        }],
        execute: function () {
            nativeRaf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
            nativeCancelRaf = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame;

            raf = nativeRaf || function (callback) {
                var timeCurrent = new Date().getTime(),
                    timeDelta = undefined;
                /* Dynamically set delay on a per-tick basis to match 60fps. */
                /* Technique by Erik Moller. MIT license: https://gist.github.com/paulirish/1579671 */
                timeDelta = Math.max(0, 16 - (timeCurrent - timeLast));
                timeLast = timeCurrent + timeDelta;
                return setTimeout(function () {
                    callback(timeCurrent + timeDelta);
                }, timeDelta);
            };

            _export('raf', raf);

            rafCancel = nativeRaf ? nativeCancelRaf : function (id) {
                return window.cancelTimeout(id);
            };

            _export('rafCancel', rafCancel);

            CSS = {};

            _export('CSS', CSS);

            (function () {
                // transform
                var i,
                    keys = ['webkitTransform', 'transform', '-webkit-transform', 'webkit-transform', '-moz-transform', 'moz-transform', 'MozTransform', 'mozTransform', 'msTransform'];
                for (i = 0; i < keys.length; i++) {
                    if (document.documentElement.style[keys[i]] !== undefined) {
                        CSS.transform = keys[i];
                        break;
                    }
                }
                // transition
                keys = ['webkitTransition', 'mozTransition', 'msTransition', 'transition'];
                for (i = 0; i < keys.length; i++) {
                    if (document.documentElement.style[keys[i]] !== undefined) {
                        CSS.transition = keys[i];
                        break;
                    }
                }
                // The only prefix we care about is webkit for transitions.
                var isWebkit = CSS.transition.indexOf('webkit') > -1;
                CSS.prefix = isWebkit ? '-webkit-' : '';
                // transition duration
                CSS.transitionDuration = (isWebkit ? '-webkit-' : '') + 'transition-duration';
                // To be sure transitionend works everywhere, include *both* the webkit and non-webkit events
                CSS.transitionEnd = (isWebkit ? 'webkitTransitionEnd ' : '') + 'transitionend';
            })();
            if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
                CSS.animation = 'WebkitAnimation';
                CSS.animationStart = 'webkitAnimationStart animationstart';
                CSS.animationEnd = 'webkitAnimationEnd animationend';
            } else {
                CSS.animation = 'animation';
                CSS.animationStart = 'animationstart';
                CSS.animationEnd = 'animationend';
            }
        }
    };
});
System.register('ionic/util/focus', ['./dom'], function (_export) {
    'use strict';

    var raf, ready, isKeyInputEnabled;

    function keyDown(ev) {
        if (!isKeyInputEnabled && ev.keyCode == 9) {
            isKeyInputEnabled = true;
            raf(enableKeyInput);
        }
    }
    function enableKeyInput() {
        document.body.classList[isKeyInputEnabled ? 'add' : 'remove']('key-input');
        if (isKeyInputEnabled) {
            document.addEventListener('mousedown', pointerDown);
            document.addEventListener('touchstart', pointerDown);
        } else {
            document.removeEventListener('mousedown', pointerDown);
            document.removeEventListener('touchstart', pointerDown);
        }
    }
    function pointerDown() {
        isKeyInputEnabled = false;
        raf(enableKeyInput);
    }
    return {
        setters: [function (_dom) {
            raf = _dom.raf;
            ready = _dom.ready;
        }],
        execute: function () {
            /* Focus Outline
             * --------------------------------------------------
             * When a keydown event happens, from a tab key, then the
             * 'key-input' class is added to the body element so focusable
             * elements have an outline. On a mousedown or touchstart
             * event then the 'key-input' class is removed.
             */
            isKeyInputEnabled = false;
            ready().then(function () {
                document.addEventListener('keydown', keyDown);
            });
        }
    };
});
System.register('ionic/util/util', [], function (_export) {
    // Simple noop function
    'use strict';

    var isBoolean, isString, isNumber, isFunction, isDefined, isUndefined, isBlank, isObject, isArray, uid, Log, array;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    _export('noop', noop);

    _export('clamp', clamp);

    _export('extend', extend);

    _export('merge', merge);

    _export('defaults', defaults);

    _export('pascalCaseToDashCase', pascalCaseToDashCase);

    _export('nextUid', nextUid);

    _export('getQuerystring', getQuerystring);

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function noop() {}

    /**
     * Given a min and max, restrict the given number
     * to the range.
     * @param min the minimum
     * @param n the value
     * @param max the maximum
     */

    function clamp(min, n, max) {
        return Math.max(min, Math.min(n, max));
    }

    /**
     * Extend the destination with an arbitrary number of other objects.
     * @param dst the destination
     * @param ... the param objects
     */

    function extend(dst) {
        return _baseExtend(dst, [].slice.call(arguments, 1), false);
    }

    /**
     * Do a deep extend (merge).
     * @param dst the destination
     * @param ... the param objects
     */

    function merge(dst) {
        return _baseExtend(dst, [].slice.call(arguments, 1), true);
    }

    function _baseExtend(dst, objs, deep) {
        for (var i = 0, ii = objs.length; i < ii; ++i) {
            var obj = objs[i];
            if (!obj || !isObject(obj) && !isFunction(obj)) continue;
            var keys = Object.keys(obj);
            for (var j = 0, jj = keys.length; j < jj; j++) {
                var key = keys[j];
                var src = obj[key];
                if (deep && isObject(src)) {
                    if (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};
                    _baseExtend(dst[key], [src], true);
                } else {
                    dst[key] = src;
                }
            }
        }
        return dst;
    }
    /**
     * Apply default arguments if they don't exist in
     * the first object.
     * @param the destination to apply defaults to.
     */

    function defaults(dest) {
        for (var i = arguments.length - 1; i >= 1; i--) {
            var source = arguments[i] || {};
            for (var key in source) {
                if (source.hasOwnProperty(key) && !dest.hasOwnProperty(key)) {
                    dest[key] = source[key];
                }
            }
        }
        return dest;
    }

    /**
     * Convert a string in the format thisIsAString to a slug format this-is-a-string
     */

    function pascalCaseToDashCase() {
        var str = arguments[0] === undefined ? '' : arguments[0];

        return str.charAt(0).toLowerCase() + str.substring(1).replace(/[A-Z]/g, function (match) {
            return '-' + match.toLowerCase();
        });
    }

    function nextUid() {
        return ++uid;
    }

    /**
     * Grab the query string param value for the given key.
     * @param key the key to look for
     */

    function getQuerystring(url, key) {
        var queryParams = {};
        if (url) {
            var startIndex = url.indexOf('?');
            if (startIndex !== -1) {
                var queries = url.slice(startIndex + 1).split('&');
                if (queries.length) {
                    queries.forEach(function (param) {
                        var split = param.split('=');
                        queryParams[split[0]] = split[1].split('#')[0];
                    });
                }
            }
            if (key) {
                return queryParams[key] || '';
            }
        }
        return queryParams;
    }

    return {
        setters: [],
        execute: function () {
            ;
            isBoolean = function isBoolean(val) {
                return typeof val === 'boolean';
            };

            _export('isBoolean', isBoolean);

            isString = function isString(val) {
                return typeof val === 'string';
            };

            _export('isString', isString);

            isNumber = function isNumber(val) {
                return typeof val === 'number';
            };

            _export('isNumber', isNumber);

            isFunction = function isFunction(val) {
                return typeof val === 'function';
            };

            _export('isFunction', isFunction);

            isDefined = function isDefined(val) {
                return typeof val !== 'undefined';
            };

            _export('isDefined', isDefined);

            isUndefined = function isUndefined(val) {
                return typeof val === 'undefined';
            };

            _export('isUndefined', isUndefined);

            isBlank = function isBlank(val) {
                return val === undefined || val === null;
            };

            _export('isBlank', isBlank);

            isObject = function isObject(val) {
                return typeof val === 'object';
            };

            _export('isObject', isObject);

            isArray = Array.isArray;

            _export('isArray', isArray);

            uid = 0;

            /**
             * A simple logger class.
             */

            Log = (function () {
                function Log() {
                    _classCallCheck(this, Log);
                }

                _createClass(Log, null, [{
                    key: 'log',
                    value: function log() {
                        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                            args[_key] = arguments[_key];
                        }

                        console.log.apply(console, args);
                    }
                }, {
                    key: 'info',
                    value: function info() {
                        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                            args[_key2] = arguments[_key2];
                        }

                        console.info.apply(console, args);
                    }
                }, {
                    key: 'warn',
                    value: function warn() {
                        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                            args[_key3] = arguments[_key3];
                        }

                        console.warn.apply(console, args);
                    }
                }, {
                    key: 'error',
                    value: function error() {
                        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                            args[_key4] = arguments[_key4];
                        }

                        console.error.apply(console, args);
                    }
                }]);

                return Log;
            })();

            _export('Log', Log);

            array = {
                find: function find(arr, cb) {
                    for (var i = 0, ii = arr.length; i < ii; i++) {
                        if (cb(arr[i], i)) return arr[i];
                    }
                },
                remove: function remove(arr, itemOrIndex) {
                    var index = -1;
                    if (isNumber(itemOrIndex)) {
                        index = itemOrIndex;
                    } else {
                        index = arr.indexOf(itemOrIndex);
                    }
                    if (index < 0) {
                        return false;
                    }
                    arr.splice(index, 1);
                    return true;
                }
            };

            _export('array', array);
        }
    };
});
System.register('ionic/transitions/ios-transition', ['./transition', '../animations/animation'], function (_export) {
    'use strict';

    var Transition, Animation, DURATION, EASING, OPACITY, TRANSLATEX, OFF_RIGHT, OFF_LEFT, CENTER, OFF_OPACITY, IOSTransition;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_transition) {
            Transition = _transition.Transition;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }],
        execute: function () {
            DURATION = 600;
            EASING = 'cubic-bezier(0.36,0.66,0.04,1)';
            OPACITY = 'opacity';
            TRANSLATEX = 'translateX';
            OFF_RIGHT = '100%';
            OFF_LEFT = '-33%';
            CENTER = '0%';
            OFF_OPACITY = 0.8;

            IOSTransition = (function (_Transition) {
                function IOSTransition(nav, opts) {
                    _classCallCheck(this, IOSTransition);

                    _get(Object.getPrototypeOf(IOSTransition.prototype), 'constructor', this).call(this, nav, opts);
                    // global duration and easing for all child animations
                    this.duration(DURATION);
                    this.easing(EASING);
                    // entering item moves to center
                    this.enteringView.to(TRANSLATEX, CENTER).to(OPACITY, 1).before.setStyles({ zIndex: this.entering.index });
                    this.enteringTitle.fadeIn().to(TRANSLATEX, CENTER);
                    // leaving view moves off screen
                    this.leavingView.from(TRANSLATEX, CENTER).from(OPACITY, 1).before.setStyles({ zIndex: this.leaving.index });
                    this.leavingTitle.from(TRANSLATEX, CENTER).from(OPACITY, 1);
                    // set properties depending on direction
                    if (opts.direction === 'back') {
                        // back direction
                        this.enteringView.from(TRANSLATEX, OFF_LEFT).from(OPACITY, OFF_OPACITY).to(OPACITY, 1);
                        this.enteringTitle.from(TRANSLATEX, OFF_LEFT);
                        this.leavingNavbar.before.addClass('transparent-navbar').after.removeClass('transparent-navbar');
                        this.leavingView.to(TRANSLATEX, OFF_RIGHT).to(OPACITY, 1);
                        this.leavingTitle.to(TRANSLATEX, OFF_RIGHT).to(OPACITY, 0);
                        if (this.leaving.enableBack() && this.viewWidth() > 200) {
                            var leavingBackButtonText = new Animation(this.leaving.backButtonTextElement());
                            leavingBackButtonText.fromTo(TRANSLATEX, CENTER, this.viewWidth() / 2 + 'px');
                            this.leavingNavbar.add(leavingBackButtonText);
                        }
                    } else {
                        // forward direction
                        this.enteringView.from(TRANSLATEX, OFF_RIGHT).from(OPACITY, 1);
                        this.enteringNavbar.before.addClass('transparent-navbar').after.removeClass('transparent-navbar');
                        this.enteringTitle.from(TRANSLATEX, OFF_RIGHT);
                        this.leavingView.to(TRANSLATEX, OFF_LEFT).to(OPACITY, OFF_OPACITY);
                        this.leavingTitle.to(TRANSLATEX, OFF_LEFT).to(OPACITY, 0);
                        if (this.entering.enableBack() && this.viewWidth() > 200) {
                            var enteringBackButtonText = new Animation(this.entering.backButtonTextElement());
                            enteringBackButtonText.fromTo(TRANSLATEX, this.viewWidth() / 2 + 'px', CENTER);
                            this.enteringNavbar.add(enteringBackButtonText);
                        }
                    }
                }

                _inherits(IOSTransition, _Transition);

                return IOSTransition;
            })(Transition);

            Transition.register('ios', IOSTransition);
        }
    };
});
System.register('ionic/transitions/md-transition', ['./transition', '../animations/animation'], function (_export) {
    'use strict';

    var Transition, Animation, DURATION, EASING, TRANSLATEY, OFF_BOTTOM, CENTER, MaterialTransition;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_transition) {
            Transition = _transition.Transition;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }],
        execute: function () {
            DURATION = 300;
            EASING = 'cubic-bezier(0.36,0.66,0.04,1)';
            TRANSLATEY = 'translateY';
            OFF_BOTTOM = '5%';
            CENTER = '0%';

            MaterialTransition = (function (_Transition) {
                function MaterialTransition(nav, opts) {
                    _classCallCheck(this, MaterialTransition);

                    _get(Object.getPrototypeOf(MaterialTransition.prototype), 'constructor', this).call(this, nav, opts);
                    // global duration and easing for all child animations
                    this.duration(DURATION);
                    this.easing(EASING);
                    // entering item moves in bottom to center
                    this.enteringView.to(TRANSLATEY, CENTER).before.setStyles({ zIndex: this.entering.index });
                    // entering title fades in
                    this.enteringTitle.fadeIn();
                    // leaving view stays put
                    this.leavingView.before.setStyles({ zIndex: this.leaving.index });
                    // leaving title fades out
                    this.leavingTitle.fadeOut();
                    // set properties depending on direction
                    if (opts.direction === 'back') {
                        // back direction
                        this.enteringView.from(TRANSLATEY, CENTER);
                        this.leavingNavbar.before.addClass('transparent-navbar').after.removeClass('transparent-navbar');
                        this.leavingTitle.fadeOut();
                        // leaving view goes center to bottom
                        this.leavingView.fromTo(TRANSLATEY, CENTER, OFF_BOTTOM).fadeOut();
                        if (this.leaving.enableBack()) {
                            var leavingBackButtonText = new Animation(this.leaving.backButtonTextElement());
                            leavingBackButtonText.fadeOut();
                            this.leavingNavbar.add(leavingBackButtonText);
                        }
                    } else {
                        // forward direction
                        this.enteringView.from(TRANSLATEY, OFF_BOTTOM).fadeIn();
                        this.enteringNavbar.before.addClass('transparent-navbar').after.removeClass('transparent-navbar');
                        if (this.entering.enableBack()) {
                            var enteringBackButtonText = new Animation(this.entering.backButtonTextElement());
                            enteringBackButtonText.fadeIn();
                            this.enteringNavbar.add(enteringBackButtonText);
                        }
                    }
                }

                _inherits(MaterialTransition, _Transition);

                return MaterialTransition;
            })(Transition);

            Transition.register('md', MaterialTransition);
        }
    };
});
System.register('ionic/transitions/transition', ['../animations/animation'], function (_export) {
    'use strict';

    var Animation, SHOW_NAVBAR_CSS, SHOW_VIEW_CSS, SHOW_BACK_BUTTON, TransitionRegistry, Transition;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }],
        execute: function () {
            SHOW_NAVBAR_CSS = 'show-navbar';
            SHOW_VIEW_CSS = 'show-view';
            SHOW_BACK_BUTTON = 'show-back-button';
            TransitionRegistry = {};

            Transition = (function (_Animation) {
                function Transition(nav, opts) {
                    _classCallCheck(this, Transition);

                    _get(Object.getPrototypeOf(Transition.prototype), 'constructor', this).call(this);
                    // get the entering and leaving items
                    var enteringItem = this.entering = nav.getStagedEnteringItem();
                    var leavingItem = this.leaving = nav.getStagedLeavingItem();
                    // create animation for the entering item's "ion-view" element
                    this.enteringView = new Animation(enteringItem.viewElementRef());
                    this.enteringView.before.addClass(SHOW_VIEW_CSS);
                    this.enteringView.onPlay(function () {
                        enteringItem.postRender();
                    });
                    this.add(this.enteringView);
                    if (opts.navbar !== false) {
                        var enteringNavbar = this.enteringNavbar = new Animation(enteringItem.navbarElement());
                        enteringNavbar.before.addClass(SHOW_NAVBAR_CSS);
                        if (enteringItem.enableBack()) {
                            // only animate in the back button if the entering view has it enabled
                            var enteringBackButton = this.enteringBackButton = new Animation(enteringItem.backButtonElement());
                            enteringBackButton.before.addClass(SHOW_BACK_BUTTON).fadeIn();
                            enteringNavbar.add(enteringBackButton);
                        }
                        this.enteringTitle = new Animation(enteringItem.titleElement());
                        enteringNavbar.add(this.enteringTitle);
                        this.add(enteringNavbar);
                        this.enteringNavbarItems = new Animation(enteringItem.navbarItemElements());
                        this.enteringNavbarItems.fadeIn();
                        enteringNavbar.add(this.enteringNavbarItems);
                    }
                    if (leavingItem) {
                        // setup the leaving item if one exists (initial viewing wouldn't have a leaving item)
                        this.leavingView = new Animation(leavingItem.viewElementRef());
                        this.leavingView.after.removeClass(SHOW_VIEW_CSS);
                        var leavingNavbar = this.leavingNavbar = new Animation(leavingItem.navbarElement());
                        leavingNavbar.after.removeClass(SHOW_NAVBAR_CSS);
                        var leavingBackButton = this.leavingBackButton = new Animation(leavingItem.backButtonElement());
                        leavingBackButton.after.removeClass(SHOW_BACK_BUTTON).fadeOut();
                        leavingNavbar.add(leavingBackButton);
                        this.leavingTitle = new Animation(leavingItem.titleElement());
                        leavingNavbar.add(this.leavingTitle);
                        this.leavingNavbarItems = new Animation(leavingItem.navbarItemElements());
                        this.leavingNavbarItems.fadeOut();
                        leavingNavbar.add(this.leavingNavbarItems);
                        this.add(this.leavingView, leavingNavbar);
                    }
                }

                _inherits(Transition, _Animation);

                _createClass(Transition, [{
                    key: 'viewWidth',
                    value: function viewWidth() {
                        // TODO: MAKE MORE BETTER
                        return this._w || (this._w = this.leaving && this.leaving.viewElementRef().nativeElement.offsetWidth);
                    }
                }], [{
                    key: 'create',

                    /*
                     STATIC CLASSES
                     */
                    value: function create(nav) {
                        var opts = arguments[1] === undefined ? {} : arguments[1];

                        //const name = opts.animation || IonicConfig.global.setting('viewTransition') || 'ios';
                        var name = opts.animation || 'ios';
                        var TransitionClass = TransitionRegistry[name];
                        if (!TransitionClass) {
                            // transition wasn't found, default to a 'none' transition
                            // which doesn't animate anything, just shows and hides
                            TransitionClass = Transition;
                        }
                        return new TransitionClass(nav, opts);
                    }
                }, {
                    key: 'register',
                    value: function register(name, TransitionClass) {
                        TransitionRegistry[name] = TransitionClass;
                    }
                }]);

                return Transition;
            })(Animation);

            _export('Transition', Transition);
        }
    };
});
System.register("ionic/components/action-menu/action-menu", ["angular2/angular2", "../button/button", "../overlay/overlay", "../../animations/animation", "ionic/util"], function (_export) {
    /**
    * @ngdoc service
    * @name ActionMenu
    * @module ionic
    * @description
    * The ActionMenu is a modal menu with options to select based on an action.
    */
    "use strict";

    var View, Injectable, NgFor, NgIf, CSSClass, TapClick, Overlay, Animation, util, __decorate, __metadata, ActionMenuDirective, ActionMenu, OVERLAY_TYPE, ActionMenuAnimation, ActionMenuSlideIn, ActionMenuSlideOut;

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            View = _angular2Angular2.View;
            Injectable = _angular2Angular2.Injectable;
            NgFor = _angular2Angular2.NgFor;
            NgIf = _angular2Angular2.NgIf;
            CSSClass = _angular2Angular2.CSSClass;
        }, function (_buttonButton) {
            TapClick = _buttonButton.TapClick;
        }, function (_overlayOverlay) {
            Overlay = _overlayOverlay.Overlay;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            ActionMenuDirective = (function () {
                var _class = function ActionMenuDirective() {
                    _classCallCheck(this, _class);
                };

                _createClass(_class, [{
                    key: "_cancel",
                    value: function _cancel() {
                        this.cancel && this.cancel();
                        return this.overlayRef.close();
                    }
                }, {
                    key: "_destructive",
                    value: function _destructive() {
                        var shouldClose = this.destructiveButtonClicked();
                        if (shouldClose === true) {
                            return this.overlayRef.close();
                        }
                    }
                }, {
                    key: "_buttonClicked",
                    value: function _buttonClicked(index) {
                        var shouldClose = this.buttonClicked(index);
                        if (shouldClose === true) {
                            return this.overlayRef.close();
                        }
                    }
                }]);

                return _class;
            })();

            ActionMenuDirective = __decorate([View({
                template: "<backdrop (click)=\"_cancel()\" tappable></backdrop>" + "<action-menu-wrapper>" + "<div class=\"action-menu-container\">" + "<div class=\"action-menu-group action-menu-options\">" + "<div class=\"action-menu-title\" *ng-if=\"titleText\">{{titleText}}</div>" + "<button (^click)=\"_buttonClicked(index)\" *ng-for=\"#b of buttons; #index = index\" class=\"action-menu-option\">" + "<i class=\"icon\" [class]=\"b.icon\" *ng-if=\"b.icon\"></i> " + "{{b.text}}" + "</button>" + "<button *ng-if=\"destructiveText\" (click)=\"_destructive()\" class=\"destructive action-menu-destructive\">" + "<i class=\"icon\" [class]=\"destructiveIcon\" *ng-if=\"destructiveIcon\"></i> " + "{{destructiveText}}</button>" + "</div>" + "<div class=\"action-menu-group action-menu-cancel\" *ng-if=\"cancelText\">" + "<button (click)=\"_cancel()\"><i class=\"icon\" [class]=\"cancelIcon\"></i> {{cancelText}}</button>" + "</div>" + "</div>" + "</action-menu-wrapper>",
                directives: [NgFor, NgIf, CSSClass, TapClick]
            }), __metadata("design:paramtypes", [])], ActionMenuDirective);

            ActionMenu = (function (_Overlay) {
                var _class2 = function ActionMenu() {
                    _classCallCheck(this, _class2);

                    _get(Object.getPrototypeOf(_class2.prototype), "constructor", this).apply(this, arguments);
                };

                _inherits(_class2, _Overlay);

                _createClass(_class2, [{
                    key: "open",

                    /**
                     * Create and open a new Action Menu. This is the
                     * public API, and most often you will only use ActionMenu.open()
                     *
                     * @return Promise that resolves when the action menu is open.
                     */
                    value: function open() {
                        var opts = arguments[0] === undefined ? {} : arguments[0];

                        var defaults = {
                            enterAnimation: "action-menu-slide-in",
                            leaveAnimation: "action-menu-slide-out"
                        };
                        var contextDefaults = {
                            cancelIcon: "ion-close",
                            destructiveIcon: "ion-trash-a"
                        };
                        var context = util.extend(contextDefaults, opts);
                        return this.create(OVERLAY_TYPE, ActionMenuDirective, util.extend(defaults, opts), context);
                    }
                }, {
                    key: "get",
                    value: function get() {
                        return Modal.getByType(OVERLAY_TYPE);
                    }
                }]);

                return _class2;
            })(Overlay);

            _export("ActionMenu", ActionMenu);

            _export("ActionMenu", ActionMenu = __decorate([Injectable(), __metadata("design:paramtypes", [])], ActionMenu));
            OVERLAY_TYPE = "action-menu";

            /**
             * Animations for action sheet
             */

            ActionMenuAnimation = (function (_Animation) {
                function ActionMenuAnimation(element) {
                    _classCallCheck(this, ActionMenuAnimation);

                    _get(Object.getPrototypeOf(ActionMenuAnimation.prototype), "constructor", this).call(this, element);
                    this.easing("cubic-bezier(.36, .66, .04, 1)").duration(400);
                    this.backdrop = new Animation(element.querySelector("backdrop"));
                    this.wrapper = new Animation(element.querySelector("action-menu-wrapper"));
                    this.add(this.backdrop, this.wrapper);
                }

                _inherits(ActionMenuAnimation, _Animation);

                return ActionMenuAnimation;
            })(Animation);

            ActionMenuSlideIn = (function (_ActionMenuAnimation) {
                function ActionMenuSlideIn(element) {
                    _classCallCheck(this, ActionMenuSlideIn);

                    _get(Object.getPrototypeOf(ActionMenuSlideIn.prototype), "constructor", this).call(this, element);
                    this.backdrop.fromTo("opacity", 0, 0.4);
                    this.wrapper.fromTo("translateY", "100%", "0%");
                }

                _inherits(ActionMenuSlideIn, _ActionMenuAnimation);

                return ActionMenuSlideIn;
            })(ActionMenuAnimation);

            Animation.register("action-menu-slide-in", ActionMenuSlideIn);

            ActionMenuSlideOut = (function (_ActionMenuAnimation2) {
                function ActionMenuSlideOut(element) {
                    _classCallCheck(this, ActionMenuSlideOut);

                    _get(Object.getPrototypeOf(ActionMenuSlideOut.prototype), "constructor", this).call(this, element);
                    this.backdrop.fromTo("opacity", 0.4, 0);
                    this.wrapper.fromTo("translateY", "0%", "100%");
                }

                _inherits(ActionMenuSlideOut, _ActionMenuAnimation2);

                return ActionMenuSlideOut;
            })(ActionMenuAnimation);

            Animation.register("action-menu-slide-out", ActionMenuSlideOut);
        }
    };
});
System.register("ionic/components/app/app", ["angular2/angular2", "../../routing/router", "../../config/config", "../../platform/platform", "../action-menu/action-menu", "../modal/modal", "../popup/popup", "../form/focus-holder"], function (_export) {
    "use strict";

    var Component, View, bootstrap, ElementRef, NgZone, bind, DynamicComponentLoader, Injector, IonicRouter, IonicConfig, Platform, ActionMenu, Modal, Popup, FocusHolder, __decorate, __metadata, IonicApp, RootAnchor;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    _export("ionicBootstrap", ionicBootstrap);

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function initApp(window, document, config) {
        // create the base IonicApp
        var app = new IonicApp();
        app.isRTL(document.documentElement.getAttribute("dir") == "rtl");
        // load all platform data
        // Platform is a global singleton
        Platform.url(window.location.href);
        Platform.userAgent(window.navigator.userAgent);
        Platform.navigatorPlatform(window.navigator.platform);
        Platform.load(config);
        // on resize be sure to clear out existing window dimensions
        window.addEventListener("resize", Platform.winResize);
        return app;
    }

    function ionicBootstrap(rootComponentType, config, router) {
        return new Promise(function (resolve) {
            try {
                (function () {
                    // get the user config, or create one if wasn't passed in
                    if (typeof config !== IonicConfig) {
                        config = new IonicConfig(config);
                    }
                    // create the base IonicApp
                    var app = initApp(window, document, config);
                    // copy default platform settings into the user config platform settings
                    // user config platform settings should override default platform settings
                    config.setPlatform(Platform);
                    // config and platform settings have been figured out
                    // apply the correct CSS to the app
                    app.applyBodyCss(document.body, Platform, config);
                    // prepare the ready promise to fire....when ready
                    Platform.prepareReady(config);
                    // setup router
                    if (typeof router !== IonicRouter) {
                        router = new IonicRouter(router);
                    }
                    router.app(app);
                    // TODO: don't wire these together
                    app.router = router;
                    // TODO: probs need a better way to inject global injectables
                    var actionMenu = new ActionMenu(app, config);
                    var modal = new Modal(app, config);
                    var popup = new Popup(app, config);
                    // add injectables that will be available to all child components
                    var appBindings = Injector.resolve([bind(IonicApp).toValue(app), bind(IonicConfig).toValue(config), bind(IonicRouter).toValue(router), bind(ActionMenu).toValue(actionMenu), bind(Modal).toValue(modal), bind(Popup).toValue(popup)]);
                    bootstrap(rootComponentType, appBindings).then(function (appRef) {
                        app.load(appRef);
                        // Adding a anchor to add overlays off of...huh??
                        var elementRefs = appRef._hostComponent.hostView._view.elementRefs;
                        var lastElementRef = elementRefs[1];
                        var injector = lastElementRef.parentView._view.rootElementInjectors[0]._injector;
                        var loader = injector.get(DynamicComponentLoader);
                        loader.loadNextToLocation(RootAnchor, lastElementRef).then(function () {
                            // append the focus holder if its needed
                            if (config.setting("keyboardScrollAssist")) {
                                app.appendComponent(FocusHolder).then(function (ref) {
                                    app.focusHolder(ref.instance);
                                });
                            }
                        })["catch"](function (err) {
                            console.error(err);
                        });
                        router.load(window, app, config).then(function () {
                            // resolve that the app has loaded
                            resolve(app);
                        });
                    })["catch"](function (err) {
                        console.error("ionicBootstrap", err);
                    });
                })();
            } catch (err) {
                console.error(err);
            }
        });
    }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            bootstrap = _angular2Angular2.bootstrap;
            ElementRef = _angular2Angular2.ElementRef;
            NgZone = _angular2Angular2.NgZone;
            bind = _angular2Angular2.bind;
            DynamicComponentLoader = _angular2Angular2.DynamicComponentLoader;
            Injector = _angular2Angular2.Injector;
        }, function (_routingRouter) {
            IonicRouter = _routingRouter.IonicRouter;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_platformPlatform) {
            Platform = _platformPlatform.Platform;
        }, function (_actionMenuActionMenu) {
            ActionMenu = _actionMenuActionMenu.ActionMenu;
        }, function (_modalModal) {
            Modal = _modalModal.Modal;
        }, function (_popupPopup) {
            Popup = _popupPopup.Popup;
        }, function (_formFocusHolder) {
            FocusHolder = _formFocusHolder.FocusHolder;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            IonicApp = (function () {
                function IonicApp() {
                    _classCallCheck(this, IonicApp);

                    this.overlays = [];
                    // Our component registry map
                    this.components = {};
                    this._activeViewId = null;
                }

                _createClass(IonicApp, [{
                    key: "load",
                    value: function load(appRef) {
                        this.ref(appRef);
                        this._zone = appRef.injector.get(NgZone);
                    }
                }, {
                    key: "focusHolder",
                    value: function focusHolder(val) {
                        if (arguments.length) {
                            this._focusHolder = val;
                        }
                        return this._focusHolder;
                    }
                }, {
                    key: "title",
                    value: function title(val) {
                        document.title = val;
                    }
                }, {
                    key: "ref",
                    value: function ref(val) {
                        if (arguments.length) {
                            this._ref = val;
                        }
                        return this._ref;
                    }
                }, {
                    key: "zoneRun",
                    value: function zoneRun(fn) {
                        this._zone.run(fn);
                    }
                }, {
                    key: "stateChange",
                    value: function stateChange(type, activeView) {
                        if (this._activeViewId !== activeView.id) {
                            this.router.stateChange(type, activeView);
                            this._activeViewId = activeView.id;
                        }
                    }
                }, {
                    key: "stateClear",
                    value: function stateClear() {
                        this.router.stateClear();
                    }
                }, {
                    key: "register",

                    /**
                     * Register a known component with a key, for easy lookups later.
                     */
                    value: function register(key, component) {
                        this.components[key] = component;
                        // TODO(mlynch): We need to track the lifecycle of this component to remove it onDehydrate
                    }
                }, {
                    key: "getComponent",

                    /**
                     * Get the component for the given key.
                     */
                    value: function getComponent(key) {
                        return this.components[key];
                    }
                }, {
                    key: "appendComponent",

                    /**
                     * Create and append the given component into the root
                     * element of the app.
                     *
                     * @param Component the component to create and insert
                     * @return Promise that resolves with the ContainerRef created
                     */
                    value: function appendComponent(componentType) {
                        var context = arguments[1] === undefined ? null : arguments[1];

                        return this.rootAnchor.append(componentType);
                    }
                }, {
                    key: "applyBodyCss",
                    value: function applyBodyCss(bodyEle, platform, config) {
                        var versions = platform.versions();
                        platform.platforms().forEach(function (platformName) {
                            // platform-ios
                            var platformClass = "platform-" + platformName;
                            bodyEle.classList.add(platformClass);
                            var platformVersion = versions[platformName];
                            if (platformVersion) {
                                // platform-ios_8
                                platformClass += "_" + platformVersion.major;
                                bodyEle.classList.add(platformClass);
                                // platform-ios_8_3
                                bodyEle.classList.add(platformClass + "_" + platformVersion.minor);
                            }
                        });
                        bodyEle.setAttribute("mode", config.setting("mode"));
                    }
                }, {
                    key: "isRTL",
                    value: function isRTL(val) {
                        if (arguments.length) {
                            this._rtl = val;
                        }
                        return this._rtl;
                    }
                }, {
                    key: "injector",
                    get: function get() {
                        return this._ref.injector;
                    }
                }]);

                return IonicApp;
            })();

            _export("IonicApp", IonicApp);

            RootAnchor = (function () {
                var _class = function RootAnchor(app, elementRef, loader) {
                    _classCallCheck(this, _class);

                    this.elementRef = elementRef;
                    this.loader = loader;
                    app.rootAnchor = this;
                };

                _createClass(_class, [{
                    key: "append",
                    value: function append(componentType) {
                        return this.loader.loadNextToLocation(componentType, this.elementRef)["catch"](function (err) {
                            console.error(err);
                        });
                    }
                }]);

                return _class;
            })();

            RootAnchor = __decorate([Component({
                selector: "root-anchor"
            }), View({
                template: ""
            }), __metadata("design:paramtypes", [IonicApp, typeof ElementRef !== "undefined" && ElementRef || Object, typeof DynamicComponentLoader !== "undefined" && DynamicComponentLoader || Object])], RootAnchor);
        }
    };
});
System.register("ionic/components/button/button", ["angular2/angular2", "../../config/config", "../../util/activator", "../../util/dom"], function (_export) {
    "use strict";

    var Directive, ElementRef, Optional, Ancestor, NgZone, IonicConfig, Activator, dom, __decorate, __metadata, __param, Button, TapDisabled, TapClick;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            ElementRef = _angular2Angular2.ElementRef;
            Optional = _angular2Angular2.Optional;
            Ancestor = _angular2Angular2.Ancestor;
            NgZone = _angular2Angular2.NgZone;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_utilActivator) {
            Activator = _utilActivator.Activator;
        }, function (_utilDom) {
            dom = _utilDom;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Button = (function () {
                var _class = function Button() {
                    _classCallCheck(this, _class);

                    this.iconLeft = this.iconRight = this.iconOnly = false;
                };

                _createClass(_class, [{
                    key: "registerIcon",
                    value: function registerIcon(icon) {
                        this.iconLeft = icon.iconLeft;
                        this.iconRight = icon.iconRight;
                        this.iconOnly = icon.iconOnly;
                    }
                }]);

                return _class;
            })();

            _export("Button", Button);

            _export("Button", Button = __decorate([Directive({
                selector: "button,[button]",
                host: {
                    "[class.icon-left]": "iconLeft",
                    "[class.icon-right]": "iconRight",
                    "[class.icon-only]": "iconOnly"
                }
            }), __metadata("design:paramtypes", [])], Button));

            TapDisabled = (function () {
                var _class2 = function TapDisabled() {
                    _classCallCheck(this, _class2);
                };

                return _class2;
            })();

            _export("TapDisabled", TapDisabled);

            _export("TapDisabled", TapDisabled = __decorate([Directive({
                selector: "[tap-disabled]"
            }), __metadata("design:paramtypes", [])], TapDisabled));

            TapClick = (function () {
                var _class3 = function TapClick(elementRef, config, ngZone, tapDisabled) {
                    _classCallCheck(this, _class3);

                    this.ele = elementRef.nativeElement;
                    this.tapEnabled = !tapDisabled;
                    this.tapPolyfill = config.setting("tapPolyfill");
                    this.zone = ngZone;
                    var self = this;
                    self.pointerMove = function (ev) {
                        var moveCoord = dom.pointerCoord(ev);
                        console.log("pointerMove", moveCoord, self.start);
                        if (dom.hasPointerMoved(10, self.start, moveCoord)) {
                            self.pointerCancel();
                        }
                    };
                };

                _createClass(_class3, [{
                    key: "touchStart",
                    value: function touchStart(ev) {
                        this.pointerStart(ev);
                    }
                }, {
                    key: "touchEnd",
                    value: function touchEnd(ev) {
                        var self = this;
                        if (this.tapPolyfill && this.tapEnabled) {
                            var endCoord = dom.pointerCoord(ev);
                            this.disableClick = true;
                            this.zone.runOutsideAngular(function () {
                                clearTimeout(self.disableTimer);
                                self.disableTimer = setTimeout(function () {
                                    self.disableClick = false;
                                }, 600);
                            });
                            if (this.start && !dom.hasPointerMoved(3, this.start, endCoord)) {
                                var clickEvent = document.createEvent("MouseEvents");
                                clickEvent.initMouseEvent("click", true, true, window, 1, 0, 0, endCoord.x, endCoord.y, false, false, false, false, 0, null);
                                clickEvent.isIonicTap = true;
                                this.ele.dispatchEvent(clickEvent);
                            }
                        }
                        this.pointerEnd();
                    }
                }, {
                    key: "mouseDown",
                    value: function mouseDown(ev) {
                        if (this.disableClick) {
                            ev.preventDefault();
                            ev.stopPropagation();
                        } else {
                            this.pointerStart(ev);
                        }
                    }
                }, {
                    key: "mouseUp",
                    value: function mouseUp(ev) {
                        if (this.disableClick) {
                            ev.preventDefault();
                            ev.stopPropagation();
                        }
                        this.pointerEnd();
                    }
                }, {
                    key: "pointerStart",
                    value: function pointerStart(ev) {
                        var _this = this;

                        this.start = dom.pointerCoord(ev);
                        this.zone.runOutsideAngular(function () {
                            Activator.start(ev.currentTarget);
                            Activator.moveListeners(_this.pointerMove, true);
                        });
                    }
                }, {
                    key: "pointerEnd",
                    value: function pointerEnd() {
                        var _this2 = this;

                        this.zone.runOutsideAngular(function () {
                            Activator.end();
                            Activator.moveListeners(_this2.pointerMove, false);
                        });
                    }
                }, {
                    key: "pointerCancel",
                    value: function pointerCancel() {
                        var _this3 = this;

                        this.start = null;
                        this.zone.runOutsideAngular(function () {
                            Activator.clear();
                            Activator.moveListeners(_this3.pointerMove, false);
                        });
                    }
                }, {
                    key: "allowClick",
                    value: function allowClick(ev) {
                        if (!ev.isIonicTap) {
                            if (this.disableClick || !this.start) {
                                return false;
                            }
                        }
                        return true;
                    }
                }, {
                    key: "click",
                    value: function click(ev) {
                        if (!this.allowClick(ev)) {
                            ev.preventDefault();
                            ev.stopPropagation();
                        }
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this.ele = null;
                    }
                }]);

                return _class3;
            })();

            _export("TapClick", TapClick);

            _export("TapClick", TapClick = __decorate([Directive({
                selector: "button,[button],[tappable],ion-checkbox",
                host: {
                    "(^touchstart)": "touchStart($event)",
                    "(^touchend)": "touchEnd($event)",
                    "(^touchcancel)": "pointerCancel()",
                    "(^mousedown)": "mouseDown($event)",
                    "(^mouseup)": "mouseUp($event)",
                    "(^click)": "click($event)"
                }
            }), __param(3, Optional()), __param(3, Ancestor()), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object, typeof NgZone !== "undefined" && NgZone || Object, TapDisabled])], TapClick));
        }
    };
});
System.register("ionic/components/aside/aside", ["angular2/angular2", "../ion", "../../config/config", "../../config/annotations", "./extensions/types", "./extensions/gestures", "ionic/util"], function (_export) {
    "use strict";

    var View, EventEmitter, ElementRef, Ion, IonicConfig, IonicComponent, types, gestures, dom, __decorate, __metadata, Aside;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            View = _angular2Angular2.View;
            EventEmitter = _angular2Angular2.EventEmitter;
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
        }, function (_extensionsTypes) {
            types = _extensionsTypes;
        }, function (_extensionsGestures) {
            gestures = _extensionsGestures;
        }, function (_ionicUtil) {
            dom = _ionicUtil.dom;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * TODO (?) add docs about how to have a root aside and a nested aside, then hide the root one
             */

            Aside = (function (_Ion) {
                var _class = function Aside(elementRef, ionicConfig) {
                    var _this = this;

                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                    this.opening = new EventEmitter("opening");
                    // TODO: Use Animation Class
                    this.getNativeElement().addEventListener("transitionend", function (ev) {
                        _this.setChanging(false);
                    });
                };

                _inherits(_class, _Ion);

                _createClass(_class, [{
                    key: "onInit",
                    value: function onInit() {
                        _get(Object.getPrototypeOf(_class.prototype), "onInit", this).call(this);
                        this.contentElement = this.content instanceof Node ? this.content : this.content.getNativeElement();
                        this.gestureDelegate = this.getDelegate("gesture");
                        this.typeDelegate = this.getDelegate("type");
                    }
                }, {
                    key: "getContentElement",
                    value: function getContentElement() {
                        return this.contentElement;
                    }
                }, {
                    key: "setOpenAmt",
                    value: function setOpenAmt(v) {
                        this.opening.next(v);
                    }
                }, {
                    key: "setTransform",
                    value: function setTransform(transform) {
                        this.typeDelegate.setTransform(transform);
                    }
                }, {
                    key: "setSliding",
                    value: function setSliding(isSliding) {
                        if (isSliding !== this.isSliding) {
                            this.typeDelegate.setSliding(isSliding);
                        }
                    }
                }, {
                    key: "setChanging",
                    value: function setChanging(isChanging) {
                        if (isChanging !== this.isChanging) {
                            this.isChanging = isChanging;
                            this.getNativeElement().classList[isChanging ? "add" : "remove"]("changing");
                        }
                    }
                }, {
                    key: "setOpen",
                    value: function setOpen(isOpen) {
                        var _this2 = this;

                        console.log("SET OPEN", isOpen);
                        console.trace();
                        if (isOpen !== this.isOpen) {
                            this.isOpen = isOpen;
                            this.setChanging(true);
                            // Set full or closed amount
                            this.setOpenAmt(isOpen ? 1 : 0);
                            return dom.rafPromise().then(function () {
                                _this2.typeDelegate.setOpen(isOpen);
                            });
                        }
                    }
                }, {
                    key: "open",
                    value: function open() {
                        return this.setOpen(true);
                    }
                }, {
                    key: "close",
                    value: function close() {
                        return this.setOpen(false);
                    }
                }, {
                    key: "toggle",
                    value: function toggle() {
                        return this.setOpen(!this.isOpen);
                    }
                }]);

                return _class;
            })(Ion);

            _export("Aside", Aside);

            _export("Aside", Aside = __decorate([IonicComponent({
                selector: "ion-aside",
                properties: ["content", "dragThreshold"],
                defaultProperties: {
                    "side": "left",
                    "type": "reveal"
                },
                delegates: {
                    gesture: [[function (instance) {
                        return instance.side == "top";
                    }, gestures.TopAsideGesture], [function (instance) {
                        return instance.side == "bottom";
                    }, gestures.BottomAsideGesture], [function (instance) {
                        return instance.side == "right";
                    }, gestures.RightAsideGesture], [function (instance) {
                        return instance.side == "left";
                    }, gestures.LeftAsideGesture]],
                    type: [[function (instance) {
                        return instance.type == "overlay";
                    }, types.AsideTypeOverlay], [function (instance) {
                        return instance.type == "reveal";
                    }, types.AsideTypeReveal], [function (instance) {
                        return instance.type == "push";
                    }, types.AsideTypePush]]
                },
                events: ["opening"]
            }), View({
                template: "<ng-content></ng-content>"
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], Aside));
        }
    };
});
System.register('ionic/components/aside/config', ['ionic/config/component', 'ionic/components/aside/aside'], function (_export) {
    'use strict';

    var ComponentConfig, Aside, AsideConfig;
    return {
        setters: [function (_ionicConfigComponent) {
            ComponentConfig = _ionicConfigComponent.ComponentConfig;
        }, function (_ionicComponentsAsideAside) {
            Aside = _ionicComponentsAsideAside.Aside;
        }],
        execute: function () {
            AsideConfig = new ComponentConfig(Aside);

            _export('AsideConfig', AsideConfig);

            AsideConfig.classes('side', 'type');
            AsideConfig.delegate('gesture').when({ side: 'left' }, gestures.LeftAsideGesture).when({ side: 'right' }, gestures.RightAsideGesture).when({ side: 'top' }, gestures.TopAsideGesture).when({ side: 'bottom' }, gestures.BottomAsideGesture);
            AsideConfig.delegate('type').when({ type: 'overlay' }, types.AsideTypeOverlay).when({ type: 'push' }, types.AsideTypePush).when({ type: 'reveal' }, types.AsideTypeReveal);
            AsideConfig.platform('android').defaults({ type: 'overlay' });
            AsideConfig.platform('ios').defaults({ type: 'reveal' });
        }
    };
});
System.register("ionic/components/card/card", ["angular2/angular2", "../ion", "../../config/config", "../../config/annotations"], function (_export) {
    "use strict";

    var ElementRef, Ion, IonicConfig, IonicDirective, __decorate, __metadata, Card;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicDirective = _configAnnotations.IonicDirective;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Card = (function (_Ion) {
                var _class = function Card(elementRef, ionicConfig) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                };

                _inherits(_class, _Ion);

                return _class;
            })(Ion);

            _export("Card", Card);

            _export("Card", Card = __decorate([IonicDirective({
                selector: "ion-card",
                host: {
                    "class": "list"
                }
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], Card));
        }
    };
});
System.register("ionic/components/checkbox/checkbox", ["angular2/angular2", "../form/input", "../../config/config", "../../config/annotations", "../button/button"], function (_export) {
    "use strict";

    var ElementRef, Optional, NgControl, IonInputItem, IonicConfig, IonicComponent, IonicView, TapClick, __decorate, __metadata, __param, Checkbox;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Optional = _angular2Angular2.Optional;
            NgControl = _angular2Angular2.NgControl;
        }, function (_formInput) {
            IonInputItem = _formInput.IonInputItem;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
            IonicView = _configAnnotations.IonicView;
        }, function (_buttonButton) {
            TapClick = _buttonButton.TapClick;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Checkbox = (function (_IonInputItem) {
                var _class = function Checkbox(cd, elementRef, config, tapClick) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, config);
                    this.tapClick = tapClick;
                    this.onChange = function (_) {};
                    this.onTouched = function (_) {};
                    this.cd = cd;
                    if (cd) cd.valueAccessor = this;
                };

                _inherits(_class, _IonInputItem);

                _createClass(_class, [{
                    key: "onInit",
                    value: function onInit() {
                        _get(Object.getPrototypeOf(_class.prototype), "onInit", this).call(this);
                        this.labelId = "label-" + this.id;
                    }
                }, {
                    key: "onAllChangesDone",
                    value: function onAllChangesDone() {
                        this.input.checked = this.checked;
                        this.input.disabled = this.disabled;
                        this.input.value = this.value;
                    }
                }, {
                    key: "toggle",
                    value: function toggle() {
                        this.input.checked = this.checked = !this.input.checked;
                        this.onChange(this.checked);
                    }
                }, {
                    key: "click",
                    value: function click(ev) {
                        if (this.tapClick.allowClick(ev)) {
                            ev.preventDefault();
                            ev.stopPropagation();
                            this.toggle();
                        }
                    }
                }, {
                    key: "writeValue",

                    // Called by the model (Control) to update the view
                    value: function writeValue(modelValue) {
                        this.input.checked = modelValue;
                    }
                }, {
                    key: "registerOnChange",

                    // Used by the view to update the model (Control)
                    // Up to us to call it in update()
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }
                }, {
                    key: "registerOnTouched",
                    value: function registerOnTouched(fn) {
                        this.onTouched = fn;
                    }
                }]);

                return _class;
            })(IonInputItem);

            _export("Checkbox", Checkbox);

            _export("Checkbox", Checkbox = __decorate([IonicComponent({
                selector: "ion-checkbox",
                properties: ["value", "checked", "disabled"],
                host: {
                    "class": "item",
                    "role": "checkbox",
                    "[attr.aria-checked]": "input.checked",
                    "[attr.aria-disabled]": "input.disabled",
                    "[attr.aria-labelledby]": "labelId",
                    "(^click)": "click($event)"
                },
                exportAs: "checkbox"
            }), IonicView({
                template: "<div class=\"item-media media-checkbox\">" + "<input type=\"checkbox\" aria-hidden=\"true\">" + "<div class=\"checkbox-icon\"></div>" + "</div>" + "<div class=\"item-content\" id=\"{{labelId}}\">" + "<ng-content></ng-content>" + "</div>"
            }), __param(0, Optional()), __metadata("design:paramtypes", [typeof NgControl !== "undefined" && NgControl || Object, typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object, typeof TapClick !== "undefined" && TapClick || Object])], Checkbox));
        }
    };
});
System.register("ionic/components/content/content", ["angular2/angular2", "../ion", "../../config/config", "../../animations/scroll-to"], function (_export) {
    "use strict";

    var Component, View, ElementRef, Ion, IonicConfig, ScrollTo, __decorate, __metadata, Content;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _defineProperty(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_animationsScrollTo) {
            ScrollTo = _animationsScrollTo.ScrollTo;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Content = (function (_Ion) {
                var _class = function Content(elementRef, config) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, config);
                    this.scrollPadding = config.setting("keyboardScrollAssist");
                };

                _inherits(_class, _Ion);

                _createClass(_class, [{
                    key: "onIonInit",
                    value: function onIonInit() {
                        this.scrollElement = this.getNativeElement().children[0];
                    }
                }, {
                    key: "addScrollEventListener",
                    value: function addScrollEventListener(handler) {
                        var _this = this;

                        if (!this.scrollElement) {
                            return;
                        }
                        this.scrollElement.addEventListener("scroll", handler);
                        return function () {
                            _this.scrollElement.removeEventListener("scroll", handler);
                        };
                    }
                }, {
                    key: "addTouchMoveListener",
                    value: function addTouchMoveListener(handler) {
                        var _this2 = this;

                        if (!this.scrollElement) {
                            return;
                        }
                        this.scrollElement.addEventListener("touchmove", handler);
                        return function () {
                            _this2.scrollElement.removeEventListener("touchmove", handler);
                        };
                    }
                }, {
                    key: "scrollTo",
                    value: function scrollTo(x, y, duration, tolerance) {
                        if (this._scrollTo) {
                            this._scrollTo.dispose();
                        }
                        this._scrollTo = new ScrollTo(this.scrollElement);
                        return this._scrollTo.start(x, y, duration, tolerance);
                    }
                }, {
                    key: "scrollPadding",
                    get: function get() {
                        return this._sp;
                    },
                    set: function set(val) {
                        this._sp = val;
                    }
                }]);

                return _class;
            })(Ion);

            _export("Content", Content);

            _export("Content", Content = __decorate([Component({
                selector: "ion-content",
                properties: ["parallax"],
                host: _defineProperty({}, "[class.scroll-padding]", "scrollPadding")
            }), View({
                template: "<div class=\"scroll-content\"><ng-content></ng-content></div>"
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], Content));
        }
    };
});
System.register("ionic/components/form/focus-holder", ["angular2/angular2", "./input"], function (_export) {
    "use strict";

    var Component, Directive, View, Ancestor, ElementRef, forwardRef, IonInput, __decorate, __metadata, __param, FocusHolder, FocusInput, PREVIOUS_TAB_INDEX, ACTIVE_TAB_INDEX, NEXT_TAB_INDEX;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            Directive = _angular2Angular2.Directive;
            View = _angular2Angular2.View;
            Ancestor = _angular2Angular2.Ancestor;
            ElementRef = _angular2Angular2.ElementRef;
            forwardRef = _angular2Angular2.forwardRef;
        }, function (_input) {
            IonInput = _input.IonInput;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            FocusHolder = (function () {
                var _class = function FocusHolder() {
                    _classCallCheck(this, _class);

                    this.i = [];
                };

                _createClass(_class, [{
                    key: "setFocusHolder",
                    value: function setFocusHolder(inputType) {
                        IonInput.clearTabIndexes();
                        this.i[1].tabIndex = ACTIVE_TAB_INDEX;
                        this.i[1].type = inputType;
                        this.i[1].focus();
                    }
                }, {
                    key: "setActiveInput",
                    value: function setActiveInput(input) {
                        IonInput.clearTabIndexes();
                        this.i[1].tabIndex = -1;
                        input.tabIndex = ACTIVE_TAB_INDEX;
                    }
                }, {
                    key: "receivedFocus",
                    value: function receivedFocus(tabIndex) {
                        if (tabIndex === PREVIOUS_TAB_INDEX) {
                            // they tabbed back one input
                            // reset the focus to the center focus holder
                            this.i[1].focus();
                            // focus on the previous input
                            IonInput.focusPrevious();
                        } else if (tabIndex === NEXT_TAB_INDEX) {
                            // they tabbed to the next input
                            // reset the focus to the center focus holder
                            this.i[1].focus();
                            // focus on the next input
                            IonInput.focusNext();
                        }
                    }
                }, {
                    key: "register",
                    value: function register(input) {
                        // register each of the focus holder inputs
                        // assign them their correct tab indexes
                        input.tabIndex = PREVIOUS_TAB_INDEX + this.i.length;
                        this.i.push(input);
                    }
                }]);

                return _class;
            })();

            _export("FocusHolder", FocusHolder);

            _export("FocusHolder", FocusHolder = __decorate([Component({
                selector: "focus-holder"
            }), View({
                template: "<input><input><input>",
                directives: [forwardRef(function () {
                    return FocusInput;
                })]
            }), __metadata("design:paramtypes", [])], FocusHolder));

            FocusInput = (function () {
                var _class2 = function FocusInput(elementRef, holder) {
                    _classCallCheck(this, _class2);

                    this.elementRef = elementRef;
                    holder.register(this);
                    this.holder = holder;
                };

                _createClass(_class2, [{
                    key: "focus",
                    value: function focus() {
                        this.elementRef.nativeElement.focus();
                    }
                }, {
                    key: "keydown",
                    value: function keydown(ev) {
                        // prevent any keyboard typing when a holder has focus
                        if (ev.keyCode !== 9) {
                            ev.preventDefault();
                            ev.stopPropagation();
                        }
                    }
                }, {
                    key: "type",
                    get: function get() {
                        // default to text type if unknown
                        return this._t || "text";
                    },
                    set: function set(val) {
                        this._t = val;
                    }
                }]);

                return _class2;
            })();

            FocusInput = __decorate([Directive({
                selector: "input",
                properties: ["tabIndex"],
                host: {
                    "[tabIndex]": "tabIndex",
                    "[type]": "type",
                    "(focus)": "holder.receivedFocus(tabIndex)",
                    "(keydown)": "keydown($event)"
                }
            }), __param(1, Ancestor()), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, FocusHolder])], FocusInput);
            PREVIOUS_TAB_INDEX = 999;
            ACTIVE_TAB_INDEX = 1000;
            NEXT_TAB_INDEX = 1001;
        }
    };
});
System.register('ionic/components/form/form', ['./focus-holder', './input', './tap-input', './text-input'], function (_export) {
  'use strict';

  return {
    setters: [function (_focusHolder) {
      for (var _key in _focusHolder) {
        _export(_key, _focusHolder[_key]);
      }
    }, function (_input) {
      for (var _key2 in _input) {
        _export(_key2, _input[_key2]);
      }
    }, function (_tapInput) {
      for (var _key3 in _tapInput) {
        _export(_key3, _tapInput[_key3]);
      }
    }, function (_textInput) {
      for (var _key4 in _textInput) {
        _export(_key4, _textInput[_key4]);
      }
    }],
    execute: function () {}
  };
});
System.register('ionic/components/form/input', ['../ion', '../../util/dom'], function (_export) {
    'use strict';

    var Ion, dom, inputRegistry, itemRegistry, inputItemIds, activeInput, lastInput, IonInput, IonInputItem;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_ion) {
            Ion = _ion.Ion;
        }, function (_utilDom) {
            dom = _utilDom;
        }],
        execute: function () {
            inputRegistry = [];
            itemRegistry = [];
            inputItemIds = -1;
            activeInput = null;
            lastInput = null;

            // Input element (not the container)

            IonInput = (function () {
                function IonInput(elementRef, app, config, scrollView) {
                    _classCallCheck(this, IonInput);

                    this.elementRef = elementRef;
                    this.app = app;
                    this.scrollView = scrollView;
                    this.scrollAssist = config.setting('keyboardScrollAssist');
                    inputRegistry.push(this);
                }

                _createClass(IonInput, [{
                    key: 'hasFocus',
                    value: function hasFocus() {
                        return dom.hasFocus(this.elementRef);
                    }
                }, {
                    key: 'focus',
                    value: function focus() {
                        this.setFocus();
                    }
                }, {
                    key: 'setFocus',
                    value: function setFocus() {
                        // TODO: How do you do this w/ NG2?
                        this.elementRef.nativeElement.focus();
                    }
                }, {
                    key: 'setFocusHolder',
                    value: function setFocusHolder(type) {
                        var focusHolder = this.app.focusHolder();
                        focusHolder && focusHolder.setFocusHolder(type);
                    }
                }, {
                    key: 'isActiveInput',
                    value: function isActiveInput(shouldBeActive) {
                        if (shouldBeActive) {
                            if (activeInput && activeInput !== lastInput) {
                                lastInput = activeInput;
                            }
                            activeInput = this;
                            var focusHolder = this.app.focusHolder();
                            focusHolder && focusHolder.setActiveInput(activeInput);
                        } else if (activeInput === this) {
                            lastInput = activeInput;
                            activeInput = null;
                        }
                    }
                }, {
                    key: 'sibling',
                    value: function sibling(inc) {
                        var index = inputRegistry.indexOf(this);
                        if (index > -1) {
                            return inputRegistry[index + inc];
                        }
                    }
                }], [{
                    key: 'focusPrevious',
                    value: function focusPrevious() {
                        this.focusMove(-1);
                    }
                }, {
                    key: 'focusNext',
                    value: function focusNext() {
                        this.focusMove(1);
                    }
                }, {
                    key: 'focusMove',
                    value: function focusMove(inc) {
                        var input = activeInput || lastInput;
                        if (input) {
                            var siblingInput = input.sibling(inc);
                            siblingInput && siblingInput.focus();
                        }
                    }
                }, {
                    key: 'clearTabIndexes',
                    value: function clearTabIndexes() {
                        for (var i = 0; i < inputRegistry.length; i++) {
                            inputRegistry[i].tabIndex = -1;
                        }
                    }
                }]);

                return IonInput;
            })();

            _export('IonInput', IonInput);

            // Container element for the label and input element

            IonInputItem = (function (_Ion) {
                function IonInputItem(elementRef, ionicConfig) {
                    _classCallCheck(this, IonInputItem);

                    _get(Object.getPrototypeOf(IonInputItem.prototype), 'constructor', this).call(this, elementRef, ionicConfig);
                    this.id = ++inputItemIds;
                    itemRegistry.push(this);
                }

                _inherits(IonInputItem, _Ion);

                _createClass(IonInputItem, [{
                    key: 'onInit',
                    value: function onInit() {
                        _get(Object.getPrototypeOf(IonInputItem.prototype), 'onInit', this).call(this);
                        if (this.input && this.label) {
                            this.input.id = this.input.id || 'input-' + this.id;
                            this.label.labelFor = this.input.id;
                        }
                    }
                }, {
                    key: 'registerInput',
                    value: function registerInput(input) {
                        this.input = input;
                    }
                }, {
                    key: 'registerLabel',
                    value: function registerLabel(label) {
                        this.label = label;
                    }
                }]);

                return IonInputItem;
            })(Ion);

            _export('IonInputItem', IonInputItem);
        }
    };
});
System.register("ionic/components/form/label", ["angular2/angular2", "../../config/config", "../../util/dom", "./text-input", "../checkbox/checkbox", "../radio/radio", "../switch/switch"], function (_export) {
    "use strict";

    var Directive, Ancestor, Optional, IonicConfig, dom, Input, Checkbox, RadioButton, Switch, __decorate, __metadata, __param, Label;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Ancestor = _angular2Angular2.Ancestor;
            Optional = _angular2Angular2.Optional;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_utilDom) {
            dom = _utilDom;
        }, function (_textInput) {
            Input = _textInput.Input;
        }, function (_checkboxCheckbox) {
            Checkbox = _checkboxCheckbox.Checkbox;
        }, function (_radioRadio) {
            RadioButton = _radioRadio.RadioButton;
        }, function (_switchSwitch) {
            Switch = _switchSwitch.Switch;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Label = (function () {
                var _class = function Label(textContainer, checkboxContainer, radioContainer, switchContainer, config) {
                    _classCallCheck(this, _class);

                    this.container = textContainer || checkboxContainer || radioContainer || switchContainer;
                    if (this.container) {
                        this.container.registerLabel(this);
                        this.inputLabel = true;
                    }
                    this.scrollAssist = config.setting("keyboardScrollAssist");
                };

                _createClass(_class, [{
                    key: "pointerStart",
                    value: function pointerStart(ev) {
                        if (this.scrollAssist) {
                            // remember where the touchstart/mousedown started
                            this.startCoord = dom.pointerCoord(ev);
                        }
                    }
                }, {
                    key: "pointerEnd",
                    value: function pointerEnd(ev) {
                        if (this.container) {
                            // get where the touchend/mouseup ended
                            var endCoord = dom.pointerCoord(ev);
                            // focus this input if the pointer hasn't moved XX pixels
                            if (!dom.hasPointerMoved(20, this.startCoord, endCoord)) {
                                ev.preventDefault();
                                ev.stopPropagation();
                                this.container instanceof Input ? this.container.focus() : this.container.toggle();
                            }
                            this.startCoord = null;
                        }
                    }
                }]);

                return _class;
            })();

            _export("Label", Label);

            _export("Label", Label = __decorate([Directive({
                selector: "label",
                host: {
                    "[attr.for]": "labelFor",
                    "[class.input-label]": "inputLabel",
                    "(touchstart)": "pointerStart($event)",
                    "(touchend)": "pointerEnd($event)",
                    "(mousedown)": "pointerStart($event)",
                    "(mouseup)": "pointerEnd($event)"
                }
            }), __param(0, Optional()), __param(0, Ancestor()), __param(1, Optional()), __param(1, Ancestor()), __param(2, Optional()), __param(2, Ancestor()), __param(3, Optional()), __param(3, Ancestor()), __metadata("design:paramtypes", [typeof Input !== "undefined" && Input || Object, typeof Checkbox !== "undefined" && Checkbox || Object, typeof RadioButton !== "undefined" && RadioButton || Object, typeof Switch !== "undefined" && Switch || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], Label));
        }
    };
});
System.register("ionic/components/form/tap-input", ["angular2/angular2", "./input", "../app/app", "../../config/config", "../content/content", "../checkbox/checkbox", "../radio/radio"], function (_export) {
    "use strict";

    var Ancestor, Optional, ElementRef, Attribute, Directive, IonInput, IonicApp, IonicConfig, Content, Checkbox, RadioButton, __decorate, __metadata, __param, TapInput;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Ancestor = _angular2Angular2.Ancestor;
            Optional = _angular2Angular2.Optional;
            ElementRef = _angular2Angular2.ElementRef;
            Attribute = _angular2Angular2.Attribute;
            Directive = _angular2Angular2.Directive;
        }, function (_input) {
            IonInput = _input.IonInput;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_contentContent) {
            Content = _contentContent.Content;
        }, function (_checkboxCheckbox) {
            Checkbox = _checkboxCheckbox.Checkbox;
        }, function (_radioRadio) {
            RadioButton = _radioRadio.RadioButton;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            TapInput = (function (_IonInput) {
                var _class = function TapInput(checkboxContainer, radioContainer, scrollView, type, elementRef, app, config) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, app, config, scrollView);
                    var container = checkboxContainer || radioContainer;
                    if (container) {
                        container.registerInput(this);
                        this.container = container;
                    }
                    this.type = type;
                    this.elementRef = elementRef;
                    this.tabIndex = this.tabIndex || "";
                };

                _inherits(_class, _IonInput);

                return _class;
            })(IonInput);

            _export("TapInput", TapInput);

            _export("TapInput", TapInput = __decorate([Directive({
                selector: "input[type=checkbox],input[type=radio]",
                properties: ["checked", "name", "value"],
                host: {
                    "[checked]": "checked",
                    "[value]": "value",
                    "[attr.name]": "name",
                    "class": "tap-input input"
                }
            }), __param(0, Optional()), __param(0, Ancestor()), __param(1, Optional()), __param(1, Ancestor()), __param(2, Optional()), __param(2, Ancestor()), __param(3, Attribute("type")), __metadata("design:paramtypes", [typeof Checkbox !== "undefined" && Checkbox || Object, typeof RadioButton !== "undefined" && RadioButton || Object, typeof Content !== "undefined" && Content || Object, String, typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicApp !== "undefined" && IonicApp || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], TapInput));
        }
    };
});
System.register("ionic/components/form/text-input", ["angular2/angular2", "../../config/annotations", "../../config/config", "./input", "../app/app", "../content/content", "../../util/click-block", "../../util/dom"], function (_export) {
    "use strict";

    var Directive, Ancestor, Optional, ElementRef, Attribute, IonicDirective, IonicConfig, IonInput, IonInputItem, IonicApp, Content, ClickBlock, dom, __decorate, __metadata, __param, Input, TextInput, SCROLL_INTO_VIEW_DURATION, SCROLL_Y_PADDING;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Ancestor = _angular2Angular2.Ancestor;
            Optional = _angular2Angular2.Optional;
            ElementRef = _angular2Angular2.ElementRef;
            Attribute = _angular2Angular2.Attribute;
        }, function (_configAnnotations) {
            IonicDirective = _configAnnotations.IonicDirective;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_input) {
            IonInput = _input.IonInput;
            IonInputItem = _input.IonInputItem;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_contentContent) {
            Content = _contentContent.Content;
        }, function (_utilClickBlock) {
            ClickBlock = _utilClickBlock.ClickBlock;
        }, function (_utilDom) {
            dom = _utilDom;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Input = (function (_IonInputItem) {
                var _class = function Input(elementRef, ionicConfig) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                };

                _inherits(_class, _IonInputItem);

                _createClass(_class, [{
                    key: "focus",
                    value: function focus() {
                        this.input && this.input.focus();
                    }
                }]);

                return _class;
            })(IonInputItem);

            _export("Input", Input);

            _export("Input", Input = __decorate([IonicDirective({
                selector: "ion-input",
                classId: "item-input",
                host: {
                    "class": "item"
                }
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], Input));

            TextInput = (function (_IonInput) {
                var _class2 = function TextInput(container, scrollView, type, elementRef, app, config) {
                    _classCallCheck(this, _class2);

                    _get(Object.getPrototypeOf(_class2.prototype), "constructor", this).call(this, elementRef, app, config, scrollView);
                    if (container) {
                        container.registerInput(this);
                        this.container = container;
                    }
                    this.type = type;
                    this.elementRef = elementRef;
                    this.tabIndex = this.tabIndex || "";
                };

                _inherits(_class2, _IonInput);

                _createClass(_class2, [{
                    key: "pointerStart",
                    value: function pointerStart(ev) {
                        if (this.scrollAssist) {
                            // remember where the touchstart/mousedown started
                            this.startCoord = dom.pointerCoord(ev);
                            this.pressStart = Date.now();
                        }
                    }
                }, {
                    key: "pointerEnd",
                    value: function pointerEnd(ev) {
                        if (this.scrollAssist) {
                            // get where the touchend/mouseup ended
                            var endCoord = dom.pointerCoord(ev);
                            // focus this input if the pointer hasn't moved XX pixels
                            // and the input doesn't already have focus
                            if (!dom.hasPointerMoved(20, this.startCoord, endCoord) && !this.hasFocus()) {
                                ev.preventDefault();
                                ev.stopPropagation();
                                this.focus();
                            }
                            this.startCoord = this.pressStart = null;
                        }
                    }
                }, {
                    key: "focus",
                    value: function focus() {
                        var _this = this;

                        var scrollView = this.scrollView;
                        if (scrollView && this.scrollAssist) {
                            // this input is inside of a scroll view
                            // scroll the input to the top
                            var inputY = this.elementRef.nativeElement.offsetTop - SCROLL_Y_PADDING;
                            // do not allow any clicks while it's scrolling
                            ClickBlock(true, SCROLL_INTO_VIEW_DURATION + 200);
                            // used to put a lot of padding on the bottom of the scroll view
                            scrollView.scrollPadding = true;
                            // temporarily move the focus to the focus holder so the browser
                            // doesn't freak out while it's trying to get the input in place
                            this.setFocusHolder(this.type);
                            // scroll the input into place
                            scrollView.scrollTo(0, inputY, SCROLL_INTO_VIEW_DURATION, 8).then(function () {
                                // the scroll view is in the correct position now
                                // give the native input the focus
                                _this.setFocus();
                                // all good, allow clicks again
                                ClickBlock(false);
                            });
                        } else {
                            // not inside of a scroll view, just focus it
                            this.setFocus();
                        }
                    }
                }, {
                    key: "receivedFocus",
                    value: function receivedFocus(_receivedFocus) {
                        var self = this;
                        var scrollView = self.scrollView;
                        self.isActiveInput(_receivedFocus);
                        function touchMove(ev) {
                            if (!self.isPressHold()) {
                                self.setFocusHolder(self.type);
                                self.deregTouchMove();
                            }
                        }
                        if (scrollView && this.scrollAssist) {
                            if (_receivedFocus) {
                                // when the input has focus, then the focus holder
                                // should not be able to be focused
                                self.deregTouchMove = scrollView && scrollView.addTouchMoveListener(touchMove);
                            } else {
                                // the input no longer has focus
                                self.deregTouchMove && self.deregTouchMove();
                            }
                        }
                    }
                }, {
                    key: "isPressHold",
                    value: function isPressHold() {
                        return this.pressStart && this.pressStart + 500 < Date.now();
                    }
                }]);

                return _class2;
            })(IonInput);

            _export("TextInput", TextInput);

            _export("TextInput", TextInput = __decorate([Directive({
                selector: "textarea,input[type=text],input[type=password],input[type=number],input[type=search],input[type=email],input[type=url],input[type=tel]",
                property: ["tabIndex"],
                host: {
                    "[tabIndex]": "tabIndex",
                    "(focus)": "receivedFocus(true)",
                    "(blur)": "receivedFocus(false)",
                    "(touchstart)": "pointerStart($event)",
                    "(touchend)": "pointerEnd($event)",
                    "(mousedown)": "pointerStart($event)",
                    "(mouseup)": "pointerEnd($event)",
                    "[attr.id]": "id",
                    "class": "text-input input"
                }
            }), __param(0, Optional()), __param(0, Ancestor()), __param(1, Optional()), __param(1, Ancestor()), __param(2, Attribute("type")), __metadata("design:paramtypes", [Input, typeof Content !== "undefined" && Content || Object, String, typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicApp !== "undefined" && IonicApp || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], TextInput));
            SCROLL_INTO_VIEW_DURATION = 500;
            SCROLL_Y_PADDING = 28;
        }
    };
});
System.register("ionic/components/icon/icon", ["angular2/angular2", "../../config/config", "../../config/annotations", "../ion", "../button/button"], function (_export) {
    "use strict";

    var Directive, View, CSSClass, ElementRef, Optional, Ancestor, Attribute, Renderer, IonicConfig, IonicComponent, Ion, Button, __decorate, __metadata, __param, IconDirective, Icon;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            View = _angular2Angular2.View;
            CSSClass = _angular2Angular2.CSSClass;
            ElementRef = _angular2Angular2.ElementRef;
            Optional = _angular2Angular2.Optional;
            Ancestor = _angular2Angular2.Ancestor;
            Attribute = _angular2Angular2.Attribute;
            Renderer = _angular2Angular2.Renderer;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_buttonButton) {
            Button = _buttonButton.Button;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            /*
            
            'home': {
              ios: ['ion-ios-home', 'ion-ios-home-outline'],
              md: 'ion-md-home'
            }
            
            1-for-1 swap
            Map of stuff that's 1-for-1
            <icon name="home"></icon>
            <icon class="ion-ios-home"></icon>
            <icon class="ion-md-home"></icon>
            
            
            Always use the same no matter what
            Cuz it's not in the map of 1-for-1's
            <icon name="alert"></icon>
            <icon class="ion-alert"></icon>
            
            
            Different between modes
            Used different attributes
            <icon ios-name="search3" md-name="search2"></icon>
            <icon class="ion-ios-search3"></icon>
            <icon class="ion-md-search2"></icon>
            
            
            
            Ionicons SVG
            <icon svg="home"></icon>
            <icon><svg>...ios...</svg></icon>
            <icon><svg>...md...</svg></icon>
            
            
            Custom SVG File
            <icon svg-src="home.svg"></icon>
            
            
            Custom Font Icon
            <icon class="fa-home"></icon>
            
            */

            IconDirective = (function () {
                var _class = function IconDirective(_elementRef, AncestorButton, forward, config, _renderer) {
                    _classCallCheck(this, _class);

                    this._elementRef = _elementRef;
                    this._renderer = _renderer;
                    var ele = this.ele = _elementRef.nativeElement;
                    this.iconLeft = this.iconRight = this.iconOnly = false;
                    this.ariaHidden = true;
                    if (forward !== null) {
                        this.fwdIcon = config.setting("forwardIcon");
                    }
                    if (AncestorButton) {
                        // this icon is within a button
                        this.withinButton = true;
                        // check if there is a sibling element (that's not aria hidden)
                        var hasPreviousSiblingElement = !!ele.previousElementSibling;
                        var hasNextSiblingElement = ele.nextElementSibling && ele.nextElementSibling.getAttribute("aria-hidden") !== "true";
                        if (!hasPreviousSiblingElement && !hasNextSiblingElement) {
                            // this icon is within a button, and doesn't have a sibling element
                            // check for text nodes to the right and left of this icon element
                            this.iconLeft = (ele.nextSibling && ele.nextSibling.textContent || "").trim() !== "";
                            this.iconRight = (ele.previousSibling && ele.previousSibling.textContent || "").trim() !== "";
                            this.iconOnly = !this.iconLeft && !this.iconRight;
                        }
                        // tell the button there's a child icon
                        // the button will set the correct css classes on itself
                        AncestorButton.registerIcon(this);
                    }
                };

                _createClass(_class, [{
                    key: "onInit",
                    value: function onInit() {
                        if (this.fwdIcon) {
                            this.name = this.fwdIcon;
                        }
                        if (!this.name) return;
                        // add the css class to show the icon font
                        this._renderer.setElementClass(this._elementRef, this.name, true);
                        // hide the icon when it's within a button
                        // and the button isn't an icon only button
                        this.ariaHidden = this.withinButton && !this.iconOnly;
                        if (!this.ariaHidden) {
                            // the icon is either not within a button
                            // or the icon is within a button, and its an icon only button
                            this.label = this.name.replace("ion-", "").replace("ios-", "").replace("md-", "").replace("-", "");
                        }
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this.ele = null;
                    }
                }]);

                return _class;
            })();

            _export("IconDirective", IconDirective);

            _export("IconDirective", IconDirective = __decorate([Directive({
                selector: "icon",
                properties: ["name", "iconName"],
                host: {
                    "[attr.aria-label]": "label",
                    "[attr.aria-hidden]": "ariaHidden",
                    "role": "img"
                }
            }), __param(1, Optional()), __param(1, Ancestor()), __param(2, Attribute("forward")), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof Button !== "undefined" && Button || Object, String, typeof IonicConfig !== "undefined" && IonicConfig || Object, typeof Renderer !== "undefined" && Renderer || Object])], IconDirective));

            Icon = (function (_Ion) {
                var _class2 = function Icon(elementRef, ionicConfig) {
                    _classCallCheck(this, _class2);

                    _get(Object.getPrototypeOf(_class2.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                };

                _inherits(_class2, _Ion);

                _createClass(_class2, [{
                    key: "onIonInit",
                    value: function onIonInit() {
                        var _this = this;

                        this.iconClass = this.ios;
                        console.log("ICON", this.mode);
                        setTimeout(function () {
                            console.log("MODE", _this.mode);
                        });
                    }
                }]);

                return _class2;
            })(Ion);

            _export("Icon", Icon);

            _export("Icon", Icon = __decorate([IonicComponent({
                selector: "ion-icon",
                properties: ["md", "ios"],
                host: {
                    "mode": "mode"
                }
            }), View({
                template: "<i class=\"icon\" [class]=\"iconClass\">",
                directives: [CSSClass]
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], Icon));
        }
    };
});
System.register("ionic/components/item/item-group", ["angular2/angular2"], function (_export) {
    "use strict";

    var Directive, ElementRef, __decorate, __metadata, ItemGroup, ItemGroupTitle;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            ElementRef = _angular2Angular2.ElementRef;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            ItemGroup = (function () {
                var _class = function ItemGroup(elementRef) {
                    _classCallCheck(this, _class);

                    this.ele = elementRef.nativeElement;
                };

                return _class;
            })();

            _export("ItemGroup", ItemGroup);

            _export("ItemGroup", ItemGroup = __decorate([Directive({
                selector: "ion-item-group",
                host: {
                    "class": "item-group"
                }
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object])], ItemGroup));

            ItemGroupTitle = (function () {
                var _class2 = function ItemGroupTitle(elementRef) {
                    _classCallCheck(this, _class2);

                    this.isSticky = true;
                    this.ele = elementRef.nativeElement;
                };

                return _class2;
            })();

            _export("ItemGroupTitle", ItemGroupTitle);

            _export("ItemGroupTitle", ItemGroupTitle = __decorate([Directive({
                selector: "ion-item-group-title",
                host: {
                    "class": "item-group-title",
                    "[class.sticky]": "isSticky"
                }
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object])], ItemGroupTitle));
        }
    };
});
System.register("ionic/components/item/item-options", [], function (_export) {
    "use strict";

    var __decorate, __metadata, ItemPrimaryOptions, ItemSecondaryOptions;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            ItemPrimaryOptions = (function () {
                var _class = function ItemPrimaryOptions() {
                    _classCallCheck(this, _class);
                };

                return _class;
            })();

            _export("ItemPrimaryOptions", ItemPrimaryOptions);

            _export("ItemPrimaryOptions", ItemPrimaryOptions = __decorate([Decorator({
                selector: "ion-primary-options"
            }), __metadata("design:paramtypes", [])], ItemPrimaryOptions));

            ItemSecondaryOptions = (function () {
                var _class2 = function ItemSecondaryOptions() {
                    _classCallCheck(this, _class2);
                };

                return _class2;
            })();

            _export("ItemSecondaryOptions", ItemSecondaryOptions);

            _export("ItemSecondaryOptions", ItemSecondaryOptions = __decorate([Decorator({
                selector: "ion-secondary-options"
            }), __metadata("design:paramtypes", [])], ItemSecondaryOptions));
        }
    };
});
System.register("ionic/components/item/item-swipe-buttons", ["angular2/angular2", "ionic/components/item/item", "ionic/gestures/slide-gesture"], function (_export) {
    "use strict";

    var ElementRef, Ancestor, Directive, Item, SlideGesture, __decorate, __metadata, __param, ItemPrimarySwipeButtons, ItemSecondarySwipeButtons, ItemSlideGesture;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Ancestor = _angular2Angular2.Ancestor;
            Directive = _angular2Angular2.Directive;
        }, function (_ionicComponentsItemItem) {
            Item = _ionicComponentsItemItem.Item;
        }, function (_ionicGesturesSlideGesture) {
            SlideGesture = _ionicGesturesSlideGesture.SlideGesture;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            ItemPrimarySwipeButtons = (function () {
                var _class = function ItemPrimarySwipeButtons(elementRef, item) {
                    _classCallCheck(this, _class);

                    item.primarySwipeButtons = this;
                    this.ele = elementRef.nativeElement;
                    this.AncestorItem = item;
                    this.gesture = new ItemSlideGesture(this);
                    this.gesture.listen();
                };

                _createClass(_class, [{
                    key: "setOpen",
                    value: function setOpen(isOpen) {
                        var _this = this;

                        if (isOpen !== this.isOpen) {
                            this.isOpen = isOpen;
                            requestAnimationFrame(function () {
                                _this.ele.classList[isOpen ? "add" : "remove"](isOpen);
                            });
                        }
                    }
                }]);

                return _class;
            })();

            _export("ItemPrimarySwipeButtons", ItemPrimarySwipeButtons);

            _export("ItemPrimarySwipeButtons", ItemPrimarySwipeButtons = __decorate([Directive({
                selector: "ion-primary-swipe-buttons"
            }), __param(1, Ancestor()), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof Item !== "undefined" && Item || Object])], ItemPrimarySwipeButtons));

            ItemSecondarySwipeButtons = (function () {
                var _class2 = function ItemSecondarySwipeButtons() {
                    _classCallCheck(this, _class2);
                };

                return _class2;
            })();

            _export("ItemSecondarySwipeButtons", ItemSecondarySwipeButtons);

            _export("ItemSecondarySwipeButtons", ItemSecondarySwipeButtons = __decorate([Directive({
                selector: "ion-secondary-swipe-buttons"
            }), __metadata("design:paramtypes", [])], ItemSecondarySwipeButtons));

            ItemSlideGesture = (function (_SlideGesture) {
                function ItemSlideGesture(buttons) {
                    _classCallCheck(this, ItemSlideGesture);

                    _get(Object.getPrototypeOf(ItemSlideGesture.prototype), "constructor", this).call(this, buttons.AncestorItem.ele);
                    this.buttons = buttons;
                }

                _inherits(ItemSlideGesture, _SlideGesture);

                _createClass(ItemSlideGesture, [{
                    key: "getSlideBoundaries",
                    value: function getSlideBoundaries() {
                        return {
                            min: -this.buttons.ele.offsetWidth,
                            max: 0
                        };
                    }
                }, {
                    key: "getElementStartPos",
                    value: function getElementStartPos(slide, ev) {
                        return this.buttons.isOpen ? slide.max : slide.min;
                    }
                }, {
                    key: "onSlideBeforeStart",
                    value: function onSlideBeforeStart() {
                        this.buttons.ele.classList.add("changing");
                        this.buttons.ele.classList.add("no-transition");
                        return new Promise(function (resolve) {
                            requestAnimationFrame(resolve);
                        });
                    }
                }, {
                    key: "onSlide",
                    value: function onSlide(slide, ev) {
                        this.buttons.ele.style.transform = "translate3d(" + slide.distance + "px,0,0)";
                    }
                }, {
                    key: "onSlideEnd",
                    value: function onSlideEnd(slide, ev) {
                        this.buttons.ele.style.transform = "";
                        this.buttons.ele.classList.remove("no-transition");
                        if (Math.abs(ev.velocityX) > 0.2 || Math.abs(slide.delta) > Math.abs(slide.max) * 0.5) {
                            this.buttons.setOpen(!this.buttons.isOpen);
                        }
                    }
                }]);

                return ItemSlideGesture;
            })(SlideGesture);
        }
    };
});
System.register("ionic/components/item/item", ["angular2/angular2", "ionic/util"], function (_export) {
    "use strict";

    var Component, View, ElementRef, dom, __decorate, __metadata, Item, Slideable, ItemSlideGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ionicUtil) {
            dom = _ionicUtil.dom;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Item = (function () {
                var _class = function Item(elementRef) {
                    _classCallCheck(this, _class);

                    this._isOpen = false;
                    this._isSlideActive = false;
                    this._isTransitioning = false;
                    this._transform = "";
                    this.ele = elementRef.nativeElement;
                    this.swipeButtons = {};
                    this.optionButtons = {};
                };

                return _class;
            })();

            _export("Item", Item);

            _export("Item", Item = __decorate([Component({
                selector: "ion-item",
                host: {
                    "class": "item"
                }
            }), View({
                template: "\n    <!--\n    <ng-content select=\"ion-primary-options\"></ng-content>\n    <ng-content select=\"ion-primary-swipe-buttons\"></ng-content>\n    -->\n    <div class=\"item-content\">\n      <div class=\"item-media\">\n      </div>\n      <div class=\"item-accessory\">\n        <!--<ng-content select=\"ion-item-accessory\"></ng-content>-->\n      </div>\n      <div class=\"item-label\">\n        <ng-content></ng-content>\n      </div>\n    </div>\n    <!--\n    <ng-content select=\"ion-secondary-options\"></ng-content>\n    <ng-content select=\"ion-secondary-swipe-buttons\"></ng-content>\n    -->\n  "
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object])], Item));

            Slideable = (function () {
                function Slideable(slideElement) {
                    _classCallCheck(this, Slideable);
                }

                _createClass(Slideable, [{
                    key: "onTransform",

                    // override
                    value: function onTransform(str) {}
                }, {
                    key: "onTransitionActive",

                    // override
                    value: function onTransitionActive(active) {}
                }, {
                    key: "onSlideActive",

                    //override
                    value: function onSlideActive(active) {}
                }, {
                    key: "transform",
                    value: function transform(str) {
                        if (arguments.length && str !== this._transform) {
                            this.onTransform();
                        }
                    }
                }, {
                    key: "isTransitionActive",
                    value: function isTransitionActive(active) {
                        if (arguments.length && active !== this._isTransitionActive) {
                            this._isTransitionActive = active;
                            this.onSetTransitionActive(active);
                        }
                        return this._isTransitioning;
                    }
                }, {
                    key: "isSlideActive",
                    value: function isSlideActive(active) {
                        if (arguments.length && active !== this._isSlideActive) {
                            this._isSlideActive = active;
                            this.onSetDragActive(active);
                        }
                        return this._isSlideActive;
                    }
                }, {
                    key: "isOpen",
                    value: (function (_isOpen) {
                        function isOpen(_x) {
                            return _isOpen.apply(this, arguments);
                        }

                        isOpen.toString = function () {
                            return _isOpen.toString();
                        };

                        return isOpen;
                    })(function (open) {
                        var _this = this;

                        if (arguments.length && open !== this._isOpen) {
                            this.isTransitionActive(true);
                            dom.raf(function () {
                                _this.isOpen = isOpen;
                                _this.onSetIsOpen(open);
                            });
                        }
                    })
                }]);

                return Slideable;
            })();

            ItemSlideGesture = function ItemSlideGesture() {
                _classCallCheck(this, ItemSlideGesture);
            };
        }
    };
});
System.register("ionic/components/layout/layout", ["angular2/angular2"], function (_export) {
    "use strict";

    var Component, View, ElementRef, __decorate, __metadata, __param, Layout;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Layout = (function () {
                var _class = function Layout(elementRef) {
                    var _this = this;

                    _classCallCheck(this, _class);

                    this.ele = ngElement.nativeElement;
                    this.eqEle = this.ele.lastElementChild;
                    window.requestAnimationFrame(function () {
                        _this.initLayout();
                    });
                };

                _createClass(_class, [{
                    key: "initLayout",
                    value: function initLayout() {
                        var _this2 = this;

                        this.mqs = {};

                        var _loop = function (x) {
                            var attr = _this2.ele.attributes[x];
                            var val = attr.nodeValue;
                            var mqClassname = attr.nodeName;
                            if (val.indexOf("(") > -1 && val.indexOf(")") > -1) {
                                var mql = _this2.eqEle.contentDocument.defaultView.matchMedia(val);
                                if (mql.media !== "not all") {
                                    _this2.mqs[mql.media] = function (mql) {
                                        console.log(mql.media, mql.matches, mqClassname);
                                        window.requestAnimationFrame(function () {
                                            _this2.ele.classList[mql.matches ? "add" : "remove"](mqClassname);
                                        });
                                    };
                                    _this2.mqs[mql.media](mql);
                                    mql.addListener(_this2.mqs[mql.media]);
                                }
                            }
                        };

                        for (var x = 0; x < this.ele.attributes.length; x++) {
                            _loop(x);
                        }
                    }
                }]);

                return _class;
            })();

            _export("Layout", Layout);

            _export("Layout", Layout = __decorate([Component({
                selector: "layout,[layout]"
            }), View({
                template: "\n    <ng-content></ng-content>\n    <object class=\"ele-qry\" data=\"about:blank\"></object>\n  "
            }), __param(0, ElementRef()), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object])], Layout));
        }
    };
});
System.register("ionic/components/list/list", ["angular2/angular2", "../ion", "../../config/config", "../../config/annotations", "./virtual", "ionic/util"], function (_export) {
    "use strict";

    var ElementRef, Ion, IonicConfig, IonicDirective, ListVirtualScroll, util, __decorate, __metadata, List;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicDirective = _configAnnotations.IonicDirective;
        }, function (_virtual) {
            ListVirtualScroll = _virtual.ListVirtualScroll;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            List = (function (_Ion) {
                var _class = function List(elementRef, ionicConfig) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                    this.ele = elementRef.nativeElement;
                };

                _inherits(_class, _Ion);

                _createClass(_class, [{
                    key: "onIonInit",
                    value: function onIonInit() {
                        if (util.isDefined(this.virtual)) {
                            console.log("Content", this.content);
                            console.log("Virtual?", this.virtual);
                            console.log("Items?", this.items.length, "of 'em");
                            this._initVirtualScrolling();
                        }
                    }
                }, {
                    key: "_initVirtualScrolling",
                    value: function _initVirtualScrolling() {
                        if (!this.content) {
                            return;
                        }
                        this._virtualScrollingManager = new ListVirtualScroll(this);
                    }
                }, {
                    key: "setItemTemplate",
                    value: function setItemTemplate(item) {
                        this.itemTemplate = item;
                    }
                }]);

                return _class;
            })(Ion);

            _export("List", List);

            _export("List", List = __decorate([IonicDirective({
                selector: "ion-list",
                properties: ["items", "virtual", "content"]
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], List));
        }
    };
});
System.register('ionic/components/list/virtual', [], function (_export) {
    'use strict';

    var ListVirtualScroll, VirtualItemRef;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [],
        execute: function () {
            ListVirtualScroll = (function () {
                function ListVirtualScroll(list) {
                    var _this = this;

                    _classCallCheck(this, ListVirtualScroll);

                    this.list = list;
                    this.content = this.list.content;
                    this.viewportHeight = this.content.height();
                    this.viewContainer = this.list.itemTemplate.viewContainer;
                    this.itemHeight = 60;
                    this.shownItems = {};
                    this.enteringItems = [];
                    this.leavingItems = [];
                    // Compute the initial sizes
                    setTimeout(function () {
                        _this.resize();
                        // Simulate the first event to start layout
                        _this._handleVirtualScroll({
                            target: _this.content.scrollElement
                        });
                    });
                    this.content.addScrollEventListener(function (event) {
                        _this._handleVirtualScroll(event);
                    });
                }

                _createClass(ListVirtualScroll, [{
                    key: 'resize',
                    value: function resize() {
                        this.viewportHeight = this.content.height();
                        this.viewportScrollHeight = this.content.scrollElement.scrollHeight;
                        this.virtualHeight = this.list.items.length * this.itemHeight;
                        this.itemsPerScreen = this.viewportHeight / this.itemHeight;
                        console.log('VIRTUAL: resize(viewportHeight:', this.viewportHeight, 'viewportScrollHeight:', this.viewportScrollHeight, 'virtualHeight:', this.virtualHeight, ', itemsPerScreen:', this.itemsPerScreen, ')');
                    }
                }, {
                    key: '_handleVirtualScroll',
                    value: function _handleVirtualScroll(event) {
                        var item = undefined;
                        var shownItemRef = undefined;
                        var st = event.target.scrollTop;
                        var sh = event.target.scrollHeight;
                        var topIndex = Math.floor(st / this.itemHeight);
                        var bottomIndex = Math.floor(st / this.itemHeight + this.itemsPerScreen);
                        var items = this.list.items;
                        // Key iterate the shown items map
                        // and compare the index to our index range,
                        // pushing the items to remove to our leaving
                        // list if they're ouside this range.
                        for (var i in this.shownItems) {
                            if (i < topIndex || i > bottomIndex) {
                                this.leavingItems.push(this.shownItems[i]);
                                delete this.shownItems[i];
                            }
                        }
                        var realIndex = 0;
                        // Iterate the set of items that will be rendered, using the
                        // index from the actual items list as the map for the
                        // virtual items we draw
                        for (var i = topIndex, _realIndex = 0; i < bottomIndex && i < items.length; i++, _realIndex++) {
                            item = items[i];
                            console.log('Drawing item', i, item.title);
                            shownItemRef = this.shownItems[i];
                            // Is this a new item?
                            if (!shownItemRef) {
                                var itemView = this.viewContainer.create(this.list.itemTemplate.protoViewRef, _realIndex);
                                itemView.setLocal('$implicit', item);
                                itemView.setLocal('$item', item);
                                shownItemRef = new VirtualItemRef(item, i, _realIndex, itemView);
                                this.shownItems[i] = shownItemRef;
                                this.enteringItems.push(shownItemRef);
                            }
                        }
                        while (this.leavingItems.length) {
                            var itemRef = this.leavingItems.pop();
                            console.log('Removing item', itemRef.item, itemRef.realIndex);
                            this.viewContainer.remove(itemRef.realIndex);
                        }
                        console.log('VIRTUAL SCROLL: scroll(scrollTop:', st, 'topIndex:', topIndex, 'bottomIndex:', bottomIndex, ')');
                        console.log('Container has', this.list.getNativeElement().children.length, 'children');
                    }
                }, {
                    key: 'cellAtIndex',
                    value: function cellAtIndex(index) {}
                }]);

                return ListVirtualScroll;
            })();

            _export('ListVirtualScroll', ListVirtualScroll);

            VirtualItemRef = function VirtualItemRef(item, index, realIndex, view) {
                _classCallCheck(this, VirtualItemRef);

                this.item = item;
                this.index = index;
                this.realIndex = realIndex;
                this.view = view;
            };
        }
    };
});
System.register("ionic/components/material/button", ["angular2/angular2", "../../config/config", "../material/ripple"], function (_export) {
    "use strict";

    var ElementRef, Directive, onDestroy, IonicConfig, MaterialRippleEffect, __decorate, __metadata, MaterialButton;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Directive = _angular2Angular2.Directive;
            onDestroy = _angular2Angular2.onDestroy;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_materialRipple) {
            MaterialRippleEffect = _materialRipple.MaterialRippleEffect;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            MaterialButton = (function () {
                var _class = function MaterialButton(elementRef, config) {
                    _classCallCheck(this, _class);

                    this.elementRef = elementRef;
                    if (config.setting("mdRipple")) {
                        this.ripple = new MaterialRippleEffect(this);
                    }
                };

                _createClass(_class, [{
                    key: "onDestroy",
                    value: function onDestroy() {}
                }]);

                return _class;
            })();

            _export("MaterialButton", MaterialButton);

            _export("MaterialButton", MaterialButton = __decorate([Directive({
                selector: "button,[button]",
                lifecycle: [onDestroy]
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], MaterialButton));
        }
    };
});
System.register('ionic/components/material/ripple', [], function (_export) {
    /**
     * Lovingly Adapted from Material Design Lite
     * Copyright Google, 2015, Licensed under the Apache 2 license.
     * https://github.com/google/material-design-lite
     */
    'use strict';

    var MaterialRippleEffect;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [],
        execute: function () {
            MaterialRippleEffect = (function () {
                function MaterialRippleEffect(button) {
                    _classCallCheck(this, MaterialRippleEffect);

                    this.elementRef = button.elementRef;
                    this.element = this.elementRef.nativeElement;
                    var rippleContainer = document.createElement('span');
                    rippleContainer.classList.add('md-ripple-container');
                    rippleContainer.setAttribute('aria-hidden', 'true');
                    this.rippleElement = document.createElement('span');
                    this.rippleElement.classList.add('md-ripple');
                    rippleContainer.appendChild(this.rippleElement);
                    this.recentering = false; //this.element.classList.contains(this.CssClasses_.RIPPLE_CENTER);
                    this.INITIAL_SCALE = 'scale(0.0001, 0.0001)';
                    this.INITIAL_SIZE = '1px';
                    this.INITIAL_OPACITY = '0.4';
                    this.FINAL_OPACITY = '0';
                    this.FINAL_SCALE = '';
                    //this.boundRippleBlurHandler = this.blurHandler.bind(this);
                    //this.rippleElement_.addEventListener('mouseup', this.boundRippleBlurHandler);
                    this.elementRef.nativeElement.appendChild(rippleContainer);
                    this._initRipple();
                }

                _createClass(MaterialRippleEffect, [{
                    key: '_initRipple',
                    value: function _initRipple() {
                        this.frameCount = 0;
                        this.rippleSize = 0;
                        this.x = 0;
                        this.y = 0;
                        // Touch start produces a compat mouse down event, which would cause a
                        // second ripples. To avoid that, we use this property to ignore the first
                        // mouse down after a touch start.
                        this.ignoringMouseDown = false;
                        this.boundDownHandler = this.downHandler.bind(this);
                        this.element.addEventListener('mousedown', this.boundDownHandler);
                        this.element.addEventListener('touchstart', this.boundDownHandler);
                        this.boundUpHandler = this.upHandler.bind(this);
                        this.element.addEventListener('mouseup', this.boundUpHandler);
                        this.element.addEventListener('mouseleave', this.boundUpHandler);
                        this.element.addEventListener('touchend', this.boundUpHandler);
                        this.element.addEventListener('blur', this.boundUpHandler);
                    }
                }, {
                    key: 'downHandler',

                    /**
                     * Handle mouse / finger down on element.
                     * @param {Event} event The event that fired.
                     * @private
                     */
                    value: function downHandler(event) {
                        'use strict';
                        if (!this.rippleElement.style.width && !this.rippleElement.style.height) {
                            var rect = this.element.getBoundingClientRect();
                            this.boundHeight = rect.height;
                            this.boundWidth = rect.width;
                            this.rippleSize = Math.sqrt(rect.width * rect.width + rect.height * rect.height) * 2 + 2;
                            this.rippleElement.style.width = this.rippleSize + 'px';
                            this.rippleElement.style.height = this.rippleSize + 'px';
                        }
                        this.rippleElement.classList.add('is-visible');
                        if (event.type === 'mousedown' && this.ignoringMouseDown) {
                            this.ignoringMouseDown = false;
                        } else {
                            if (event.type === 'touchstart') {
                                this.ignoringMouseDown = true;
                            }
                            var frameCount = this.getFrameCount();
                            if (frameCount > 0) {
                                return;
                            }
                            this.setFrameCount(1);
                            var bound = event.currentTarget.getBoundingClientRect();
                            var x;
                            var y;
                            // Check if we are handling a keyboard click.
                            if (event.clientX === 0 && event.clientY === 0) {
                                x = Math.round(bound.width / 2);
                                y = Math.round(bound.height / 2);
                            } else {
                                var clientX = event.clientX ? event.clientX : event.touches[0].clientX;
                                var clientY = event.clientY ? event.clientY : event.touches[0].clientY;
                                x = Math.round(clientX - bound.left);
                                y = Math.round(clientY - bound.top);
                            }
                            this.setRippleXY(x, y);
                            this.setRippleStyles(true);
                            window.requestAnimationFrame(this.animFrameHandler.bind(this));
                        }
                    }
                }, {
                    key: 'upHandler',

                    /**
                     * Handle mouse / finger up on element.
                     * @param {Event} event The event that fired.
                     * @private
                     */
                    value: function upHandler(event) {
                        'use strict';

                        var _this = this;

                        // Don't fire for the artificial "mouseup" generated by a double-click.
                        if (event && event.detail !== 2) {
                            setTimeout(function () {
                                _this.rippleElement.classList.remove('is-visible');
                            });
                        }
                    }
                }, {
                    key: 'getFrameCount',
                    value: function getFrameCount() {
                        return this.frameCount;
                    }
                }, {
                    key: 'setFrameCount',
                    value: function setFrameCount(fC) {
                        this.frameCount = fC;
                    }
                }, {
                    key: 'getRippleElement',
                    value: function getRippleElement() {
                        return this.rippleElement;
                    }
                }, {
                    key: 'setRippleXY',
                    value: function setRippleXY(newX, newY) {
                        this.x = newX;
                        this.y = newY;
                    }
                }, {
                    key: 'setRippleStyles',
                    value: function setRippleStyles(start) {
                        if (this.rippleElement !== null) {
                            var transformString;
                            var scale;
                            var size;
                            var offset = 'translate(' + this.x + 'px, ' + this.y + 'px)';
                            if (start) {
                                scale = this.INITIAL_SCALE;
                                size = this.INITIAL_SIZE;
                            } else {
                                scale = this.FINAL_SCALE;
                                size = this.rippleSize + 'px';
                                if (this.recentering) {
                                    offset = 'translate(' + this.boundWidth / 2 + 'px, ' + this.boundHeight / 2 + 'px)';
                                }
                            }
                            transformString = 'translate(-50%, -50%) ' + offset + scale;
                            this.rippleElement.style.webkitTransform = transformString;
                            this.rippleElement.style.msTransform = transformString;
                            this.rippleElement.style.transform = transformString;
                            if (start) {
                                this.rippleElement.classList.remove('md-ripple-animating');
                            } else {
                                this.rippleElement.classList.add('md-ripple-animating');
                            }
                        }
                    }
                }, {
                    key: 'animFrameHandler',
                    value: function animFrameHandler() {
                        if (this.frameCount-- > 0) {
                            window.requestAnimationFrame(this.animFrameHandler.bind(this));
                        } else {
                            this.setRippleStyles(false);
                        }
                    }
                }, {
                    key: 'elementClicked',
                    value: function elementClicked(event) {}
                }]);

                return MaterialRippleEffect;
            })();

            _export('MaterialRippleEffect', MaterialRippleEffect);
        }
    };
});
System.register("ionic/components/modal/modal", ["angular2/angular2", "../overlay/overlay", "../../animations/animation", "ionic/util"], function (_export) {
    "use strict";

    var Injectable, Overlay, Animation, util, __decorate, __metadata, Modal, OVERLAY_TYPE, ModalSlideIn, ModalSlideOut;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Injectable = _angular2Angular2.Injectable;
        }, function (_overlayOverlay) {
            Overlay = _overlayOverlay.Overlay;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Modal = (function (_Overlay) {
                var _class = function Modal() {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).apply(this, arguments);
                };

                _inherits(_class, _Overlay);

                _createClass(_class, [{
                    key: "open",
                    value: function open(ComponentType) {
                        var opts = arguments[1] === undefined ? {} : arguments[1];

                        var defaults = {
                            enterAnimation: "modal-slide-in",
                            leaveAnimation: "modal-slide-out"
                        };
                        return this.create(OVERLAY_TYPE, ComponentType, util.extend(defaults, opts));
                    }
                }, {
                    key: "get",
                    value: function get(handle) {
                        if (handle) {
                            return this.getByHandle(handle, OVERLAY_TYPE);
                        }
                        return this.getByType(OVERLAY_TYPE);
                    }
                }]);

                return _class;
            })(Overlay);

            _export("Modal", Modal);

            _export("Modal", Modal = __decorate([Injectable(), __metadata("design:paramtypes", [])], Modal));
            OVERLAY_TYPE = "modal";

            /**
             * Animations for modals
             */

            ModalSlideIn = (function (_Animation) {
                function ModalSlideIn(element) {
                    _classCallCheck(this, ModalSlideIn);

                    _get(Object.getPrototypeOf(ModalSlideIn.prototype), "constructor", this).call(this, element);
                    this.easing("cubic-bezier(.36,.66,.04,1)").duration(400).fromTo("translateY", "100%", "0%");
                }

                _inherits(ModalSlideIn, _Animation);

                return ModalSlideIn;
            })(Animation);

            Animation.register("modal-slide-in", ModalSlideIn);

            ModalSlideOut = (function (_Animation2) {
                function ModalSlideOut(element) {
                    _classCallCheck(this, ModalSlideOut);

                    _get(Object.getPrototypeOf(ModalSlideOut.prototype), "constructor", this).call(this, element);
                    this.easing("ease-out").duration(250).fromTo("translateY", "0%", "100%");
                }

                _inherits(ModalSlideOut, _Animation2);

                return ModalSlideOut;
            })(Animation);

            Animation.register("modal-slide-out", ModalSlideOut);
        }
    };
});
System.register("ionic/components/nav/anchors", ["angular2/angular2", "angular2/src/core/compiler/view_container_ref", "./pane", "../view/view-controller"], function (_export) {
    "use strict";

    var Component, View, Directive, Ancestor, ElementRef, forwardRef, Inject, ViewContainerRef, Pane, ViewController, __decorate, __metadata, __param, PaneAnchor, PaneContentAnchor, NavBarAnchor, NavBarContainer;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            Directive = _angular2Angular2.Directive;
            Ancestor = _angular2Angular2.Ancestor;
            ElementRef = _angular2Angular2.ElementRef;
            forwardRef = _angular2Angular2.forwardRef;
            Inject = _angular2Angular2.Inject;
        }, function (_angular2SrcCoreCompilerView_container_ref) {
            ViewContainerRef = _angular2SrcCoreCompilerView_container_ref.ViewContainerRef;
        }, function (_pane) {
            Pane = _pane.Pane;
        }, function (_viewViewController) {
            ViewController = _viewViewController.ViewController;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            PaneAnchor = (function () {
                var _class = function PaneAnchor(pane, elementRef) {
                    _classCallCheck(this, _class);

                    pane.sectionAnchorElementRef = elementRef;
                };

                return _class;
            })();

            _export("PaneAnchor", PaneAnchor);

            _export("PaneAnchor", PaneAnchor = __decorate([Directive({ selector: "template[pane-anchor]" }), __param(0, Ancestor()), __param(0, Inject(forwardRef(function () {
                return Pane;
            }))), __metadata("design:paramtypes", [typeof Pane !== "undefined" && Pane || Object, typeof ElementRef !== "undefined" && ElementRef || Object])], PaneAnchor));

            PaneContentAnchor = (function () {
                var _class2 = function PaneContentAnchor(pane, viewContainerRef) {
                    _classCallCheck(this, _class2);

                    pane.contentContainerRef = viewContainerRef;
                };

                return _class2;
            })();

            _export("PaneContentAnchor", PaneContentAnchor);

            _export("PaneContentAnchor", PaneContentAnchor = __decorate([Directive({ selector: "template[content-anchor]" }), __param(0, Ancestor()), __param(0, Inject(forwardRef(function () {
                return Pane;
            }))), __metadata("design:paramtypes", [typeof Pane !== "undefined" && Pane || Object, typeof ViewContainerRef !== "undefined" && ViewContainerRef || Object])], PaneContentAnchor));

            NavBarAnchor = (function () {
                var _class3 = function NavBarAnchor(viewCtrl, viewContainerRef) {
                    _classCallCheck(this, _class3);

                    viewCtrl.navbarViewContainer(viewContainerRef);
                };

                return _class3;
            })();

            NavBarAnchor = __decorate([Directive({
                selector: "template[navbar-anchor]"
            }), __param(0, Inject(forwardRef(function () {
                return ViewController;
            }))), __metadata("design:paramtypes", [typeof ViewController !== "undefined" && ViewController || Object, typeof ViewContainerRef !== "undefined" && ViewContainerRef || Object])], NavBarAnchor);

            NavBarContainer = (function () {
                var _class4 = function NavBarContainer() {
                    _classCallCheck(this, _class4);
                };

                return _class4;
            })();

            _export("NavBarContainer", NavBarContainer);

            _export("NavBarContainer", NavBarContainer = __decorate([Component({
                selector: "section",
                host: {
                    "class": "navbar-container"
                }
            }), View({
                template: "<template navbar-anchor></template>",
                directives: [NavBarAnchor]
            }), __metadata("design:paramtypes", [])], NavBarContainer));
        }
    };
});
System.register('ionic/components/nav/nav-controller', ['../../util/util'], function (_export) {
    'use strict';

    var extend, NavController, NavParams;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_utilUtil) {
            extend = _utilUtil.extend;
        }],
        execute: function () {
            NavController = (function () {
                function NavController(nav) {
                    _classCallCheck(this, NavController);

                    this._nav = nav;
                }

                _createClass(NavController, [{
                    key: 'setItems',

                    /**
                     * Set the history stack to match the list of component items.
                     */
                    value: function setItems(items) {
                        return this._nav.setItems(items);
                    }
                }, {
                    key: 'clear',

                    /**
                     * Clear the history stack.
                     */
                    value: function clear() {
                        return this._nav.clear();
                    }
                }, {
                    key: 'push',

                    /**
                     * Push an ew component onto the history stack.
                     */
                    value: function push() {
                        return this._nav.push.apply(this._nav, arguments);
                    }
                }, {
                    key: 'pop',

                    /**
                     * Pop the top most (visible) component off the history stack.
                     */
                    value: function pop() {
                        return this._nav.pop.apply(this._nav, arguments);
                    }
                }]);

                return NavController;
            })();

            _export('NavController', NavController);

            NavParams = function NavParams(params) {
                _classCallCheck(this, NavParams);

                extend(this, params);
            };

            _export('NavParams', NavParams);
        }
    };
});
System.register("ionic/components/nav/nav-push", ["angular2/angular2", "./nav-controller"], function (_export) {
    "use strict";

    var Directive, NavController, __decorate, __metadata, NavPush, NavPop;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
        }, function (_navController) {
            NavController = _navController.NavController;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            NavPush = (function () {
                var _class = function NavPush(nav) {
                    _classCallCheck(this, _class);

                    this.nav = nav;
                };

                _createClass(_class, [{
                    key: "onClick",
                    value: function onClick(event) {
                        this.nav.push(this.navPush, this.pushData);
                    }
                }]);

                return _class;
            })();

            _export("NavPush", NavPush);

            _export("NavPush", NavPush = __decorate([Directive({
                selector: "[nav-push]",
                properties: ["navPush", "pushData"],
                host: {
                    "(^click)": "onClick($event)",
                    "role": "link"
                }
            }), __metadata("design:paramtypes", [typeof NavController !== "undefined" && NavController || Object])], NavPush));

            NavPop = (function () {
                var _class2 = function NavPop(nav) {
                    _classCallCheck(this, _class2);

                    this.nav = nav;
                };

                _createClass(_class2, [{
                    key: "onClick",
                    value: function onClick(event) {
                        this.nav.pop();
                    }
                }]);

                return _class2;
            })();

            _export("NavPop", NavPop);

            _export("NavPop", NavPop = __decorate([Directive({
                selector: "[nav-pop]",
                host: {
                    "(^click)": "onClick($event)",
                    "role": "link"
                }
            }), __metadata("design:paramtypes", [typeof NavController !== "undefined" && NavController || Object])], NavPop));
        }
    };
});
System.register("ionic/components/nav/nav", ["angular2/angular2", "../../config/annotations", "../view/view-controller"], function (_export) {
    "use strict";

    var Directive, View, ElementRef, Ancestor, Optional, forwardRef, Injector, IonicComponent, ViewController, __decorate, __metadata, __param, Nav, NavPaneAnchor;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
            Ancestor = _angular2Angular2.Ancestor;
            Optional = _angular2Angular2.Optional;
            forwardRef = _angular2Angular2.forwardRef;
            Injector = _angular2Angular2.Injector;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
        }, function (_viewViewController) {
            ViewController = _viewViewController.ViewController;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Nav = (function (_ViewController) {
                var _class = function Nav(ancestorViewCtrl, injector, elementRef) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, ancestorViewCtrl, injector, elementRef);
                };

                _inherits(_class, _ViewController);

                _createClass(_class, [{
                    key: "onIonInit",
                    value: function onIonInit() {
                        if (this.root) {
                            this.push(this.root);
                        }
                        // default the swipe back to be enabled
                        var isSwipeBackEnabled = (this.swipeBackEnabled || "").toString() !== "false";
                        this.isSwipeBackEnabled(isSwipeBackEnabled);
                    }
                }]);

                return _class;
            })(ViewController);

            _export("Nav", Nav);

            _export("Nav", Nav = __decorate([IonicComponent({
                selector: "ion-nav",
                properties: ["root"],
                defaultProperties: {
                    "swipeBackEnabled": true
                }
            }), View({
                template: "<template pane-anchor></template>",
                directives: [forwardRef(function () {
                    return NavPaneAnchor;
                })]
            }), __param(0, Optional()), __metadata("design:paramtypes", [typeof ViewController !== "undefined" && ViewController || Object, typeof Injector !== "undefined" && Injector || Object, typeof ElementRef !== "undefined" && ElementRef || Object])], Nav));

            NavPaneAnchor = (function () {
                var _class2 = function NavPaneAnchor(nav, elementRef) {
                    _classCallCheck(this, _class2);

                    nav.anchorElementRef(elementRef);
                };

                return _class2;
            })();

            NavPaneAnchor = __decorate([Directive({ selector: "template[pane-anchor]" }), __param(0, Ancestor()), __metadata("design:paramtypes", [Nav, typeof ElementRef !== "undefined" && ElementRef || Object])], NavPaneAnchor);
        }
    };
});
System.register("ionic/components/nav/pane", ["angular2/angular2", "../ion", "../../config/config", "../view/view-controller", "./swipe-handle", "../../config/annotations", "./anchors"], function (_export) {
    "use strict";

    var View, ElementRef, Inject, forwardRef, Injector, bind, Ion, IonicConfig, ViewController, SwipeHandle, IonicComponent, PaneAnchor, PaneContentAnchor, NavBarContainer, __decorate, __metadata, __param, PaneController, Pane;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _defineProperty(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
            Inject = _angular2Angular2.Inject;
            forwardRef = _angular2Angular2.forwardRef;
            Injector = _angular2Angular2.Injector;
            bind = _angular2Angular2.bind;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_viewViewController) {
            ViewController = _viewViewController.ViewController;
        }, function (_swipeHandle) {
            SwipeHandle = _swipeHandle.SwipeHandle;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
        }, function (_anchors) {
            PaneAnchor = _anchors.PaneAnchor;
            PaneContentAnchor = _anchors.PaneContentAnchor;
            NavBarContainer = _anchors.NavBarContainer;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            PaneController = (function () {
                function PaneController(viewCtrl) {
                    _classCallCheck(this, PaneController);

                    this.panes = {};
                    this.viewCtrl = viewCtrl;
                    this.bindings = Injector.resolve([bind(ViewController).toValue(viewCtrl)]);
                }

                _createClass(PaneController, [{
                    key: "get",
                    value: function get(itemStructure, callback) {
                        var _this = this;

                        // this gets or creates the Pane which similar nav items live in
                        // Nav items with just a navbar/content would all use the same Pane
                        // Tabs and view's without a navbar would get a different Panes
                        var key = itemStructure.key;
                        var viewCtrl = this.viewCtrl;
                        var pane = this.panes[key];
                        if (pane) {
                            // nav pane which the entering component already exists
                            callback(pane);
                        } else {
                            // create a new nav pane
                            this.panes[key] = null;
                            viewCtrl.loader.loadNextToLocation(Pane, viewCtrl.anchorElementRef(), this.bindings).then(function () {
                                // get the pane reference by name
                                pane = _this.panes[key];
                                var sectionAnchorElementRef = pane && pane.sectionAnchorElementRef;
                                if (!sectionAnchorElementRef) {
                                    return callback();
                                }
                                var promises = [];
                                var sectionsToAdd = [];
                                // decide which sections should be added to this Pane, ie: nav bars, footers, etc.
                                // add only the sections it needs
                                if (itemStructure.navbar) {
                                    sectionsToAdd.push(NavBarContainer);
                                }
                                // add the sections which this type of Pane requires
                                sectionsToAdd.forEach(function (SectionClass) {
                                    // as each section is compiled and added to the Pane
                                    // the section will add a reference to itself in the Pane's sections object
                                    promises.push(viewCtrl.loader.loadNextToLocation(SectionClass, sectionAnchorElementRef));
                                });
                                // wait for all of the sections to resolve
                                Promise.all(promises).then(function () {
                                    callback(pane);
                                }, function (err) {
                                    console.error(err);
                                });
                            }, function (loaderErr) {
                                console.error(loaderErr);
                            })["catch"](function (err) {
                                console.error(err);
                            });
                        }
                    }
                }, {
                    key: "add",
                    value: function add(pane) {
                        for (var np in this.panes) {
                            if (this.panes[np] === null) {
                                this.panes[np] = pane;
                                return;
                            }
                        }
                    }
                }]);

                return PaneController;
            })();

            _export("PaneController", PaneController);

            Pane = (function (_Ion) {
                var _class = function Pane(viewCtrl, elementRef, ionicConfig) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                    viewCtrl.panes.add(this);
                };

                _inherits(_class, _Ion);

                _createClass(_class, [{
                    key: "showPane",
                    set: function set(val) {
                        this._showPane = val;
                    },
                    get: function get() {
                        return this._showPane;
                    }
                }]);

                return _class;
            })(Ion);

            _export("Pane", Pane);

            _export("Pane", Pane = __decorate([IonicComponent({
                selector: "ion-pane",
                classId: "nav",
                host: _defineProperty({}, "[class.show-pane]", "showPane")
            }), View({
                template: "\n    <template pane-anchor></template>\n    <section class=\"content-container\">\n      <template content-anchor></template>\n      <div class=\"swipe-handle\"></div>\n    </section>\n  ",
                directives: [PaneAnchor, PaneContentAnchor, SwipeHandle]
            }), __param(0, Inject(forwardRef(function () {
                return ViewController;
            }))), __metadata("design:paramtypes", [typeof ViewController !== "undefined" && ViewController || Object, typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], Pane));
        }
    };
});
System.register("ionic/components/nav/swipe-handle", ["angular2/angular2", "../view/view-controller", "./pane", "ionic/gestures/gesture"], function (_export) {
    "use strict";

    var ElementRef, Directive, Ancestor, Optional, Inject, forwardRef, NgZone, ViewController, Pane, Gesture, __decorate, __metadata, __param, SwipeHandle;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Directive = _angular2Angular2.Directive;
            Ancestor = _angular2Angular2.Ancestor;
            Optional = _angular2Angular2.Optional;
            Inject = _angular2Angular2.Inject;
            forwardRef = _angular2Angular2.forwardRef;
            NgZone = _angular2Angular2.NgZone;
        }, function (_viewViewController) {
            ViewController = _viewViewController.ViewController;
        }, function (_pane) {
            Pane = _pane.Pane;
        }, function (_ionicGesturesGesture) {
            Gesture = _ionicGesturesGesture.Gesture;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            SwipeHandle = (function () {
                var _class = function SwipeHandle(viewCtrl, pane, elementRef, ngZone) {
                    _classCallCheck(this, _class);

                    if (!viewCtrl || !viewCtrl.isSwipeBackEnabled() || !pane) return;
                    var self = this;
                    self.pane = pane;
                    self.viewCtrl = viewCtrl;
                    self.zone = ngZone;
                    this.zone.runOutsideAngular(function () {
                        var gesture = self.gesture = new Gesture(elementRef.nativeElement);
                        gesture.listen();
                        function dragHorizontal(ev) {
                            self.onDragHorizontal(ev);
                        }
                        gesture.on("panend", function (gestureEv) {
                            self.onDragEnd(gestureEv.gesture);
                        });
                        gesture.on("panleft", dragHorizontal);
                        gesture.on("panright", dragHorizontal);
                    });
                    self.startX = null;
                    self.width = null;
                };

                _createClass(_class, [{
                    key: "onDragEnd",
                    value: function onDragEnd(gesture) {
                        var _this = this;

                        gesture.srcEvent.preventDefault();
                        gesture.srcEvent.stopPropagation();
                        // TODO: POLISH THESE NUMBERS WITH GOOD MATHIFICATION
                        var progress = (gesture.center.x - this.startX) / this.width;
                        var completeSwipeBack = progress > 0.5;
                        var playbackRate = 4;
                        if (completeSwipeBack) {
                            // complete swipe back
                            if (progress > 0.9) {
                                playbackRate = 1;
                            } else if (progress > 0.8) {
                                playbackRate = 2;
                            } else if (progress > 0.7) {
                                playbackRate = 3;
                            }
                        } else {
                            // cancel swipe back
                            if (progress < 0.1) {
                                playbackRate = 1;
                            } else if (progress < 0.2) {
                                playbackRate = 2;
                            } else if (progress < 0.3) {
                                playbackRate = 3;
                            }
                        }
                        this.zone.run(function () {
                            _this.viewCtrl.swipeBackEnd(completeSwipeBack, progress, playbackRate);
                        });
                        this.startX = null;
                    }
                }, {
                    key: "onDragHorizontal",
                    value: function onDragHorizontal(gestureEv) {
                        var _this2 = this;

                        this.zone.run(function () {
                            var gesture = gestureEv.gesture;
                            if (_this2.startX === null) {
                                // starting drag
                                gesture.srcEvent.preventDefault();
                                gesture.srcEvent.stopPropagation();
                                _this2.startX = gesture.center.x;
                                _this2.width = _this2.pane.width() - _this2.startX;
                                _this2.viewCtrl.swipeBackStart();
                            }
                            _this2.viewCtrl.swipeBackProgress((gesture.center.x - _this2.startX) / _this2.width);
                        });
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this.gesture && this.gesture.destroy();
                    }
                }, {
                    key: "showHandle",
                    get: function get() {
                        return this.viewCtrl ? this.viewCtrl.canSwipeBack() : false;
                    }
                }]);

                return _class;
            })();

            _export("SwipeHandle", SwipeHandle);

            _export("SwipeHandle", SwipeHandle = __decorate([Directive({
                selector: ".swipe-handle",
                host: {
                    "[class.show-handle]": "showHandle"
                }
            }), __param(0, Optional()), __param(0, Inject(forwardRef(function () {
                return ViewController;
            }))), __param(1, Ancestor()), __param(1, Inject(forwardRef(function () {
                return Pane;
            }))), __metadata("design:paramtypes", [typeof ViewController !== "undefined" && ViewController || Object, typeof Pane !== "undefined" && Pane || Object, typeof ElementRef !== "undefined" && ElementRef || Object, typeof NgZone !== "undefined" && NgZone || Object])], SwipeHandle));
        }
    };
});
System.register("ionic/components/nav-bar/nav-bar", ["angular2/angular2", "../toolbar/toolbar", "../../config/config", "../../config/annotations", "../app/app", "../view/view-item"], function (_export) {
    "use strict";

    var Directive, Ancestor, Optional, ElementRef, forwardRef, TemplateRef, ToolbarBase, IonicConfig, IonicComponent, IonicView, IonicApp, ViewItem, __decorate, __metadata, __param, Navbar, BackButton, BackButtonText, Title, NavbarItem, NavbarTemplate;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Ancestor = _angular2Angular2.Ancestor;
            Optional = _angular2Angular2.Optional;
            ElementRef = _angular2Angular2.ElementRef;
            forwardRef = _angular2Angular2.forwardRef;
            TemplateRef = _angular2Angular2.TemplateRef;
        }, function (_toolbarToolbar) {
            ToolbarBase = _toolbarToolbar.ToolbarBase;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
            IonicView = _configAnnotations.IonicView;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_viewViewItem) {
            ViewItem = _viewViewItem.ViewItem;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Navbar = (function (_ToolbarBase) {
                var _class = function Navbar(elementRef, config, app, item) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, config);
                    this.app = app;
                    item && item.navbarView(this);
                    this.bbClass = config.setting("backButtonIcon");
                    this.bbDefault = config.setting("backButtonText");
                    this.bbText = "";
                };

                _inherits(_class, _ToolbarBase);

                _createClass(_class, [{
                    key: "backButtonElement",
                    value: function backButtonElement(eleRef) {
                        if (arguments.length) {
                            this._bbEle = eleRef;
                        }
                        return this._bbEle;
                    }
                }, {
                    key: "backButtonTextElement",
                    value: function backButtonTextElement(eleRef) {
                        if (arguments.length) {
                            this._bbTxEle = eleRef;
                        }
                        return this._bbTxEle;
                    }
                }, {
                    key: "didEnter",
                    value: function didEnter() {
                        var titleEle = this._ttEle || (this._ttEle = this.getNativeElement().querySelector("ion-title"));
                        titleEle && this.app.title(titleEle.textContent);
                    }
                }]);

                return _class;
            })(ToolbarBase);

            _export("Navbar", Navbar);

            _export("Navbar", Navbar = __decorate([IonicComponent({
                selector: "ion-navbar",
                host: {
                    "class": "toolbar"
                }
            }), IonicView({
                template: "\n    <div class=\"toolbar-inner\">\n      <button class=\"back-button\">\n        <icon class=\"back-button-icon\" [name]=\"bbClass\"></icon>\n        <span class=\"back-button-text\">\n          <span class=\"back-default\" [text-content]=\"bbDefault\"></span>\n          <span class=\"back-title\" [text-content]=\"bbText\"></span>\n        </span>\n      </button>\n      <div class=\"toolbar-title\">\n        <div class=\"toolbar-inner-title\">\n          <ng-content select=\"ion-title\"></ng-content>\n        </div>\n      </div>\n      <div class=\"toolbar-item toolbar-primary-item\">\n        <ng-content select=\"[primary]\"></ng-content>\n      </div>\n      <div class=\"toolbar-item toolbar-secondary-item\">\n        <ng-content select=\"[secondary]\"></ng-content>\n      </div>\n    </div>\n  ",
                directives: [forwardRef(function () {
                    return BackButton;
                }), forwardRef(function () {
                    return BackButtonText;
                }), forwardRef(function () {
                    return Title;
                }), forwardRef(function () {
                    return NavbarItem;
                })]
            }), __param(3, Optional()), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object, typeof IonicApp !== "undefined" && IonicApp || Object, typeof ViewItem !== "undefined" && ViewItem || Object])], Navbar));

            BackButton = (function () {
                var _class2 = function BackButton(navbar, item, elementRef) {
                    _classCallCheck(this, _class2);

                    this.item = item;
                    navbar.backButtonElement(elementRef);
                };

                _createClass(_class2, [{
                    key: "goBack",
                    value: function goBack(ev) {
                        ev.stopPropagation();
                        ev.preventDefault();
                        this.item && this.item.viewCtrl.pop();
                    }
                }]);

                return _class2;
            })();

            BackButton = __decorate([Directive({
                selector: ".back-button",
                host: {
                    "(^click)": "goBack($event)"
                }
            }), __param(0, Ancestor()), __param(1, Optional()), __metadata("design:paramtypes", [Navbar, typeof ViewItem !== "undefined" && ViewItem || Object, typeof ElementRef !== "undefined" && ElementRef || Object])], BackButton);

            BackButtonText = (function () {
                var _class3 = function BackButtonText(navbar, elementRef) {
                    _classCallCheck(this, _class3);

                    navbar.backButtonTextElement(elementRef);
                };

                return _class3;
            })();

            BackButtonText = __decorate([Directive({
                selector: ".back-button-text"
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [Navbar, typeof ElementRef !== "undefined" && ElementRef || Object])], BackButtonText);

            Title = (function () {
                var _class4 = function Title(toolbar, elementRef) {
                    _classCallCheck(this, _class4);

                    toolbar.titleElement(elementRef);
                };

                return _class4;
            })();

            Title = __decorate([Directive({
                selector: ".toolbar-title"
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [Navbar, typeof ElementRef !== "undefined" && ElementRef || Object])], Title);

            NavbarItem = (function () {
                var _class5 = function NavbarItem(toolbar, elementRef) {
                    _classCallCheck(this, _class5);

                    toolbar.itemElements(elementRef);
                };

                return _class5;
            })();

            NavbarItem = __decorate([Directive({
                selector: ".toolbar-item"
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [Navbar, typeof ElementRef !== "undefined" && ElementRef || Object])], NavbarItem);
            /*
              Used to find and register headers in a view, and this directive's
              content will be moved up to the common navbar location, and created
              using the same context as the view's content area.
            */

            NavbarTemplate = (function () {
                var _class6 = function NavbarTemplate(item, templateRef) {
                    _classCallCheck(this, _class6);

                    item && item.addTemplateRef("navbar", templateRef);
                };

                return _class6;
            })();

            _export("NavbarTemplate", NavbarTemplate);

            _export("NavbarTemplate", NavbarTemplate = __decorate([Directive({
                selector: "template[navbar]"
            }), __param(0, Optional()), __param(1, Optional()), __metadata("design:paramtypes", [typeof ViewItem !== "undefined" && ViewItem || Object, typeof TemplateRef !== "undefined" && TemplateRef || Object])], NavbarTemplate));
        }
    };
});
System.register('ionic/components/overlay/overlay', ['angular2/angular2', 'angular2/src/core/compiler/element_injector', '../../animations/animation', '../../util/click-block', 'ionic/util'], function (_export) {
    'use strict';

    var Component, DirectiveBinding, Animation, ClickBlock, util, Overlay, OverlayRef, ROOT_Z_INDEX;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
        }, function (_angular2SrcCoreCompilerElement_injector) {
            DirectiveBinding = _angular2SrcCoreCompilerElement_injector.DirectiveBinding;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }, function (_utilClickBlock) {
            ClickBlock = _utilClickBlock.ClickBlock;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            Overlay = (function () {
                function Overlay(app, config) {
                    _classCallCheck(this, Overlay);

                    this.app = app;
                    this.mode = config.setting('mode');
                }

                _createClass(Overlay, [{
                    key: 'create',
                    value: function create(overlayType, componentType) {
                        var _this = this;

                        var opts = arguments[2] === undefined ? {} : arguments[2];
                        var context = arguments[3] === undefined ? null : arguments[3];

                        return new Promise(function (resolve, reject) {
                            var app = _this.app;
                            var annotation = new Component({
                                selector: 'ion-' + overlayType,
                                host: {
                                    '[style.z-index]': 'zIndex',
                                    'mode': _this.mode,
                                    'class': overlayType
                                }
                            });
                            var overlayComponentType = DirectiveBinding.createFromType(componentType, annotation);
                            // create a unique token that works as a cache key
                            overlayComponentType.token = overlayType + componentType.name;
                            app.appendComponent(overlayComponentType).then(function (ref) {
                                var overlayRef = new OverlayRef(app, overlayType, opts, ref, context);
                                overlayRef._open(opts).then(function () {
                                    resolve(overlayRef);
                                });
                            })['catch'](function (err) {
                                console.error('Overlay appendComponent:', err);
                                reject(err);
                            });
                        })['catch'](function (err) {
                            console.error('Overlay create:', err);
                        });
                    }
                }, {
                    key: 'getByType',
                    value: function getByType(overlayType) {
                        if (this.app) {
                            for (var i = this.app.overlays.length - 1; i >= 0; i--) {
                                if (overlayType === this.app.overlays[i]._type) {
                                    return this.app.overlays[i];
                                }
                            }
                        }
                        return null;
                    }
                }, {
                    key: 'getByHandle',
                    value: function getByHandle(handle, overlayType) {
                        if (this.app) {
                            for (var i = this.app.overlays.length - 1; i >= 0; i--) {
                                if (handle === this.app.overlays[i]._handle && overlayType === this.app.overlays[i]._type) {
                                    return this.app.overlays[i];
                                }
                            }
                        }
                        return null;
                    }
                }]);

                return Overlay;
            })();

            _export('Overlay', Overlay);

            OverlayRef = (function () {
                function OverlayRef(app, overlayType, opts, ref, context) {
                    var _this2 = this;

                    _classCallCheck(this, OverlayRef);

                    var overlayInstance = ref && ref.instance;
                    if (!overlayInstance) return;
                    if (context) {
                        util.extend(ref.instance, context);
                    }
                    this._instance = overlayInstance;
                    overlayInstance.viewLoaded && overlayInstance.viewLoaded();
                    this.zIndex = ROOT_Z_INDEX;
                    for (var i = 0; i < app.overlays.length; i++) {
                        if (app.overlays[i].zIndex >= this.zIndex) {
                            this.zIndex = app.overlays[i].zIndex + 1;
                        }
                    }
                    overlayInstance.zIndex = this.zIndex;
                    overlayInstance.overlayRef = this;
                    overlayInstance.close = function (instanceOpts) {
                        _this2.close(instanceOpts);
                    };
                    this._elementRef = ref.location;
                    this._type = overlayType;
                    this._opts = opts;
                    this._handle = opts.handle || this.zIndex;
                    this._dispose = function () {
                        _this2._instance = null;
                        ref.dispose && ref.dispose();
                        util.array.remove(app.overlays, _this2);
                    };
                    app.overlays.push(this);
                }

                _createClass(OverlayRef, [{
                    key: 'getElementRef',
                    value: function getElementRef() {
                        return this._elementRef;
                    }
                }, {
                    key: '_open',
                    value: function _open() {
                        var _this3 = this;

                        var opts = arguments[0] === undefined ? {} : arguments[0];

                        return new Promise(function (resolve) {
                            var instance = _this3._instance || {};
                            instance.viewWillEnter && instance.viewWillEnter();
                            var animationName = opts && opts.animation || _this3._opts.enterAnimation;
                            var animation = Animation.create(_this3._elementRef.nativeElement, animationName);
                            animation.before.addClass('show-overlay');
                            ClickBlock(true, animation.duration() + 200);
                            animation.play().then(function () {
                                ClickBlock(false);
                                animation.dispose();
                                instance.viewDidEnter && instance.viewDidEnter();
                                resolve();
                            });
                        })['catch'](function (err) {
                            console.error(err);
                        });
                    }
                }, {
                    key: 'close',
                    value: function close() {
                        var _this4 = this;

                        var opts = arguments[0] === undefined ? {} : arguments[0];

                        return new Promise(function (resolve) {
                            var instance = _this4._instance || {};
                            instance.viewWillLeave && instance.viewWillLeave();
                            instance.viewWillUnload && instance.viewWillUnload();
                            var animationName = opts && opts.animation || _this4._opts.leaveAnimation;
                            var animation = Animation.create(_this4._elementRef.nativeElement, animationName);
                            animation.after.removeClass('show-overlay');
                            ClickBlock(true, animation.duration() + 200);
                            animation.play().then(function () {
                                instance.viewDidLeave && instance.viewDidLeave();
                                instance.viewDidUnload && instance.viewDidUnload();
                                _this4._dispose();
                                ClickBlock(false);
                                animation.dispose();
                                resolve();
                            });
                        })['catch'](function (err) {
                            console.error(err);
                        });
                    }
                }]);

                return OverlayRef;
            })();

            _export('OverlayRef', OverlayRef);

            ROOT_Z_INDEX = 1000;
        }
    };
});
System.register("ionic/components/popup/popup", ["angular2/angular2", "../overlay/overlay", "../../animations/animation", "ionic/util"], function (_export) {
    "use strict";

    var formDirectives, Component, View, Injectable, CSSClass, NgIf, NgFor, Overlay, Animation, util, __decorate, __metadata, Popup, OVERLAY_TYPE, StandardPopup, PopupAnimation, PopupPopIn, PopupPopOut;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x8, _x9, _x10) { var _again = true; _function: while (_again) { var object = _x8, property = _x9, receiver = _x10; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x8 = parent; _x9 = property; _x10 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            formDirectives = _angular2Angular2.formDirectives;
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            Injectable = _angular2Angular2.Injectable;
            CSSClass = _angular2Angular2.CSSClass;
            NgIf = _angular2Angular2.NgIf;
            NgFor = _angular2Angular2.NgFor;
        }, function (_overlayOverlay) {
            Overlay = _overlayOverlay.Overlay;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Popup = (function (_Overlay) {
                var _class = function Popup() {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).apply(this, arguments);
                };

                _inherits(_class, _Overlay);

                _createClass(_class, [{
                    key: "popup",
                    value: function popup(context) {
                        var _this = this;

                        var opts = arguments[1] === undefined ? {} : arguments[1];

                        return new Promise(function (resolve, reject) {
                            var defaults = {
                                enterAnimation: "popup-pop-in",
                                leaveAnimation: "popup-pop-out"
                            };
                            context.promiseResolve = resolve;
                            context.promiseReject = reject;
                            return _this.create(OVERLAY_TYPE, StandardPopup, util.extend(defaults, opts), context);
                        });
                    }
                }, {
                    key: "alert",
                    value: function alert() {
                        var context = arguments[0] === undefined ? {} : arguments[0];
                        var opts = arguments[1] === undefined ? {} : arguments[1];

                        if (typeof context === "string") {
                            context = {
                                title: context
                            };
                        }
                        var button = {
                            text: "OK",
                            onTap: function onTap(event, popupRef) {}
                        };
                        context = util.extend({
                            cancel: function cancel() {},
                            buttons: [button]
                        }, context);
                        return this.popup(context, opts);
                    }
                }, {
                    key: "confirm",
                    value: function confirm() {
                        var context = arguments[0] === undefined ? {} : arguments[0];
                        var opts = arguments[1] === undefined ? {} : arguments[1];

                        if (typeof context === "string") {
                            context = {
                                title: context
                            };
                        }
                        var okButton = {
                            text: "OK",
                            onTap: function onTap(event, popupRef) {}
                        };
                        var cancelButton = {
                            text: "Cancel",
                            isCancel: true,
                            onTap: function onTap(event, popupRef) {}
                        };
                        context = util.extend({
                            cancel: function cancel() {},
                            buttons: [cancelButton, okButton]
                        }, context);
                        return this.popup(context, opts);
                    }
                }, {
                    key: "prompt",
                    value: function prompt() {
                        var context = arguments[0] === undefined ? {} : arguments[0];
                        var opts = arguments[1] === undefined ? {} : arguments[1];

                        if (typeof context === "string") {
                            context = {
                                title: context
                            };
                        }
                        var okButton = {
                            text: "Ok",
                            onTap: function onTap(event, popupRef) {}
                        };
                        var cancelButton = {
                            text: "Cancel",
                            isCancel: true,
                            onTap: function onTap(event, popupRef) {}
                        };
                        context = util.extend({
                            showPrompt: true,
                            promptPlaceholder: "",
                            cancel: function cancel() {},
                            buttons: [cancelButton, okButton]
                        }, context);
                        return this.popup(context, opts);
                    }
                }, {
                    key: "get",
                    value: function get(handle) {
                        if (handle) {
                            return this.getByHandle(handle, OVERLAY_TYPE);
                        }
                        return this.getByType(OVERLAY_TYPE);
                    }
                }]);

                return _class;
            })(Overlay);

            _export("Popup", Popup);

            _export("Popup", Popup = __decorate([Injectable(), __metadata("design:paramtypes", [])], Popup));
            OVERLAY_TYPE = "popup";

            StandardPopup = (function () {
                var _class2 = function StandardPopup(popup) {
                    _classCallCheck(this, _class2);

                    this.popup = popup;
                };

                _createClass(_class2, [{
                    key: "onInit",
                    value: function onInit() {
                        var _this2 = this;

                        setTimeout(function () {
                            _this2.element = _this2.overlayRef.getElementRef().nativeElement;
                            _this2.promptInput = _this2.element.querySelector("input");
                            if (_this2.promptInput) {
                                _this2.promptInput.value = "";
                            }
                        });
                    }
                }, {
                    key: "buttonTapped",
                    value: function buttonTapped(button, event) {
                        var promptValue = this.promptInput && this.promptInput.value;
                        var retVal = button.onTap && button.onTap(event, this, {
                            promptValue: promptValue
                        });
                        // If the event.preventDefault() wasn't called, close
                        if (!event.defaultPrevented) {
                            // If this is a cancel button, reject the promise
                            if (button.isCancel) {
                                this.promiseReject();
                            } else {
                                // Resolve with the prompt value
                                this.promiseResolve(promptValue);
                            }
                            return this.overlayRef.close();
                        }
                    }
                }, {
                    key: "_cancel",
                    value: function _cancel(event) {
                        this.cancel && this.cancel(event);
                        if (!event.defaultPrevented) {
                            this.promiseReject();
                            return this.overlayRef.close();
                        }
                    }
                }]);

                return _class2;
            })();

            StandardPopup = __decorate([Component({
                selector: "ion-popup-default"
            }), View({
                template: "<backdrop (click)=\"_cancel($event)\" tappable></backdrop>" + "<popup-wrapper>" + "<div class=\"popup-head\">" + "<h3 class=\"popup-title\" [inner-html]=\"title\"></h3>" + "<h5 class=\"popup-sub-title\" [inner-html]=\"subTitle\" *ng-if=\"subTitle\"></h5>" + "</div>" + "<div class=\"popup-body\">" + "<input type=\"text\" *ng-if=\"showPrompt\" placeholder=\"{{promptPlaceholder}}\">" + "</div>" + "<div class=\"popup-buttons\" *ng-if=\"buttons.length\">" + "<button *ng-for=\"#button of buttons\" (click)=\"buttonTapped(button, $event)\" class=\"button\" [class]=\"button.type || 'button-default'\" [inner-html]=\"button.text\"></button>" + "</div>" + "</popup-wrapper>",
                directives: [formDirectives, CSSClass, NgIf, NgFor]
            }), __metadata("design:paramtypes", [Popup])], StandardPopup);

            PopupAnimation = (function (_Animation) {
                function PopupAnimation(element) {
                    _classCallCheck(this, PopupAnimation);

                    _get(Object.getPrototypeOf(PopupAnimation.prototype), "constructor", this).call(this, element);
                    this.easing("ease-in-out").duration(200);
                    this.backdrop = new Animation(element.querySelector("backdrop"));
                    this.wrapper = new Animation(element.querySelector("popup-wrapper"));
                    this.add(this.backdrop, this.wrapper);
                }

                _inherits(PopupAnimation, _Animation);

                return PopupAnimation;
            })(Animation);

            /**
             * Animations for modals
             */

            PopupPopIn = (function (_PopupAnimation) {
                function PopupPopIn(element) {
                    _classCallCheck(this, PopupPopIn);

                    _get(Object.getPrototypeOf(PopupPopIn.prototype), "constructor", this).call(this, element);
                    this.wrapper.fromTo("opacity", "0", "1");
                    this.wrapper.fromTo("scale", "1.1", "1");
                    this.backdrop.fromTo("opacity", "0", "0.3");
                }

                _inherits(PopupPopIn, _PopupAnimation);

                return PopupPopIn;
            })(PopupAnimation);

            Animation.register("popup-pop-in", PopupPopIn);

            PopupPopOut = (function (_PopupAnimation2) {
                function PopupPopOut(element) {
                    _classCallCheck(this, PopupPopOut);

                    _get(Object.getPrototypeOf(PopupPopOut.prototype), "constructor", this).call(this, element);
                    this.wrapper.fromTo("opacity", "1", "0");
                    this.wrapper.fromTo("scale", "1", "0.9");
                    this.backdrop.fromTo("opacity", "0.3", "0");
                }

                _inherits(PopupPopOut, _PopupAnimation2);

                return PopupPopOut;
            })(PopupAnimation);

            Animation.register("popup-pop-out", PopupPopOut);
        }
    };
});

// Allow it to close
//resolve();

//reject();

// Allow it to close

// Allow it to close

// Allow it to close

// Allow it to close
System.register("ionic/components/radio/radio", ["angular2/angular2", "../../config/annotations", "../../config/config", "../ion", "../form/form"], function (_export) {
    "use strict";

    var ElementRef, Ancestor, NgControl, Renderer, IonicDirective, IonicComponent, IonicView, IonicConfig, Ion, IonInputItem, __decorate, __metadata, __param, groupName, RadioGroup, RadioButton;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Ancestor = _angular2Angular2.Ancestor;
            NgControl = _angular2Angular2.NgControl;
            Renderer = _angular2Angular2.Renderer;
        }, function (_configAnnotations) {
            IonicDirective = _configAnnotations.IonicDirective;
            IonicComponent = _configAnnotations.IonicComponent;
            IonicView = _configAnnotations.IonicView;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_formForm) {
            IonInputItem = _formForm.IonInputItem;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            groupName = -1;

            RadioGroup = (function (_Ion) {
                var _class = function RadioGroup(cd, renderer, elementRef, ionicConfig) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                    this._name = ++groupName;
                    this.buttons = [];
                    this.onChange = function (_) {};
                    this.onTouched = function (_) {};
                    this.renderer = renderer;
                    this.elementRef = elementRef;
                    cd.valueAccessor = this;
                    this.value = "";
                };

                _inherits(_class, _Ion);

                _createClass(_class, [{
                    key: "registerButton",
                    value: function registerButton(radioButton) {
                        this.buttons.push(radioButton);
                        var inputEl = radioButton.input.elementRef.nativeElement;
                        if (!inputEl.hasAttribute("name")) {
                            radioButton.input.name = this._name;
                        }
                    }
                }, {
                    key: "update",

                    //from clicking the label or switching inputs with keyboard
                    //view -> model (Control)
                    value: function update(input) {
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = this.buttons[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var button = _step.value;

                                button.input.checked = false;
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator["return"]) {
                                    _iterator["return"]();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        input.checked = true;
                        this.onChange(input.value);
                    }
                }, {
                    key: "writeValue",

                    // Called by the model (Control) to update the view
                    value: function writeValue(value) {
                        this.value = value;
                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;

                        try {
                            for (var _iterator2 = this.buttons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                var button = _step2.value;

                                button.input.checked = button.input.value == value;
                            }
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                                    _iterator2["return"]();
                                }
                            } finally {
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }
                    }
                }, {
                    key: "registerOnChange",

                    // Used by the view to update the model (Control)
                    // Up to us to call it in update()
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }
                }, {
                    key: "registerOnTouched",
                    value: function registerOnTouched(fn) {
                        this.onTouched = fn;
                    }
                }]);

                return _class;
            })(Ion);

            _export("RadioGroup", RadioGroup);

            _export("RadioGroup", RadioGroup = __decorate([IonicDirective({
                selector: "ion-radio-group",
                host: {
                    "class": "list"
                }
            }), __metadata("design:paramtypes", [typeof NgControl !== "undefined" && NgControl || Object, typeof Renderer !== "undefined" && Renderer || Object, typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], RadioGroup));

            RadioButton = (function (_IonInputItem) {
                var _class2 = function RadioButton(group, elementRef, config) {
                    _classCallCheck(this, _class2);

                    _get(Object.getPrototypeOf(_class2.prototype), "constructor", this).call(this, elementRef, config);
                    this.group = group;
                };

                _inherits(_class2, _IonInputItem);

                _createClass(_class2, [{
                    key: "registerInput",
                    value: function registerInput(input) {
                        this.input = input;
                        this.group.registerButton(this);
                    }
                }, {
                    key: "toggle",

                    //from clicking the label or switching inputs with keyboard
                    //view -> model (Control)
                    value: function toggle() {
                        this.group.update(this.input);
                    }
                }]);

                return _class2;
            })(IonInputItem);

            _export("RadioButton", RadioButton);

            _export("RadioButton", RadioButton = __decorate([IonicComponent({
                selector: "ion-radio",
                host: {
                    "class": "item",
                    "[attr.aria-checked]": "input.checked"
                }
            }), IonicView({
                template: "<div class=\"item-content\">" + "<ng-content></ng-content>" + "</div>" + "<div class=\"item-media media-radio\">" + "<div class=\"radio-icon\"></div>" + "</div>"
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [RadioGroup, typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], RadioButton));
        }
    };
});
System.register("ionic/components/scroll/pull-to-refresh", ["angular2/angular2", "../content/content", "ionic/util", "ionic/util/dom"], function (_export) {
    "use strict";

    var Component, View, NgIf, CSSClass, ElementRef, EventEmitter, Ancestor, onInit, Content, util, raf, CSS, __decorate, __metadata, __param, Refresher;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            NgIf = _angular2Angular2.NgIf;
            CSSClass = _angular2Angular2.CSSClass;
            ElementRef = _angular2Angular2.ElementRef;
            EventEmitter = _angular2Angular2.EventEmitter;
            Ancestor = _angular2Angular2.Ancestor;
            onInit = _angular2Angular2.onInit;
        }, function (_contentContent) {
            Content = _contentContent.Content;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_ionicUtilDom) {
            raf = _ionicUtilDom.raf;
            CSS = _ionicUtilDom.CSS;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Refresher = (function () {
                var _class = function Refresher(content, element) {
                    _classCallCheck(this, _class);

                    this.ele = element.nativeElement;
                    this.ele.classList.add("content");
                    this.content = content;
                    this.refresh = new EventEmitter("refresh");
                    this.starting = new EventEmitter("starting");
                    this.pulling = new EventEmitter("pulling");
                };

                _createClass(_class, [{
                    key: "onInit",
                    value: function onInit() {
                        this.initEvents();
                    }
                }, {
                    key: "initEvents",
                    value: function initEvents() {
                        var sp = this.content.getNativeElement();
                        var sc = this.content.scrollElement;
                        this.isDragging = false;
                        this.isOverscrolling = false;
                        this.dragOffset = 0;
                        this.lastOverscroll = 0;
                        this.ptrThreshold = 60;
                        this.activated = false;
                        this.scrollTime = 500;
                        this.startY = null;
                        this.deltaY = null;
                        this.canOverscroll = true;
                        this.scrollAncestor = sp;
                        this.scrollChild = sc;
                        util.defaults(this, {
                            pullingIcon: "ion-android-arrow-down",
                            refreshingIcon: "ion-ionic"
                        });
                        this.showSpinner = !util.isDefined(this.refreshingIcon) && this.spinner != "none";
                        this.showIcon = util.isDefined(this.refreshingIcon);
                        this._touchMoveListener = this._handleTouchMove.bind(this);
                        this._touchEndListener = this._handleTouchEnd.bind(this);
                        this._handleScrollListener = this._handleScroll.bind(this);
                        sc.addEventListener("touchmove", this._touchMoveListener);
                        sc.addEventListener("touchend", this._touchEndListener);
                        sc.addEventListener("scroll", this._handleScrollListener);
                    }
                }, {
                    key: "onDehydrate",
                    value: function onDehydrate() {
                        console.log("DEHYDRATION");
                        var sc = this.content.scrollElement;
                        sc.removeEventListener("touchmove", this._touchMoveListener);
                        sc.removeEventListener("touchend", this._touchEndListener);
                        sc.removeEventListener("scroll", this._handleScrollListener);
                    }
                }, {
                    key: "overscroll",
                    value: function overscroll(val) {
                        this.scrollChild.style[CSS.transform] = "translateY(" + val + "px)";
                        this.lastOverscroll = val;
                    }
                }, {
                    key: "nativescroll",
                    value: function nativescroll(target, newScrollTop) {
                        // creates a scroll event that bubbles, can be cancelled, and with its view
                        // and detail property initialized to window and 1, respectively
                        target.scrollTop = newScrollTop;
                        var e = document.createEvent("UIEvents");
                        e.initUIEvent("scroll", true, true, window, 1);
                        target.dispatchEvent(e);
                    }
                }, {
                    key: "setScrollLock",
                    value: function setScrollLock(enabled) {
                        var _this = this;

                        // set the scrollbar to be position:fixed in preparation to overscroll
                        // or remove it so the app can be natively scrolled
                        if (enabled) {
                            raf(function () {
                                _this.scrollChild.classList.add("overscroll");
                                _this.show();
                            });
                        } else {
                            raf(function () {
                                _this.scrollChild.classList.remove("overscroll");
                                _this.hide();
                                _this.deactivate();
                            });
                        }
                    }
                }, {
                    key: "activate",
                    value: function activate() {
                        //this.ele.classList.add('active');
                        this.isActive = true;
                        //this.starting.next();
                    }
                }, {
                    key: "deactivate",
                    value: function deactivate() {
                        var _this2 = this;

                        // give tail 150ms to finish
                        setTimeout(function () {
                            _this2.isActive = false;
                            _this2.isRefreshing = false;
                            _this2.isRefreshingTail = false;
                            // deactivateCallback
                            if (_this2.activated) _this2.activated = false;
                        }, 150);
                    }
                }, {
                    key: "start",
                    value: function start() {
                        // startCallback
                        this.isRefreshing = true;
                        this.refresh.next(this);
                        //$scope.$onRefresh();
                    }
                }, {
                    key: "show",
                    value: function show() {
                        // showCallback
                        this.ele.classList.remove("invisible");
                    }
                }, {
                    key: "hide",
                    value: function hide() {
                        // showCallback
                        this.ele.classList.add("invisible");
                    }
                }, {
                    key: "tail",
                    value: function tail() {
                        // tailCallback
                        this.ele.classList.add("refreshing-tail");
                    }
                }, {
                    key: "complete",
                    value: function complete() {
                        var _this3 = this;

                        setTimeout(function () {
                            raf(_this3.tail.bind(_this3));
                            // scroll back to home during tail animation
                            _this3.scrollTo(0, _this3.scrollTime, _this3.deactivate.bind(_this3));
                            // return to native scrolling after tail animation has time to finish
                            setTimeout(function () {
                                if (_this3.isOverscrolling) {
                                    _this3.isOverscrolling = false;
                                    _this3.setScrollLock(false);
                                }
                            }, _this3.scrollTime);
                        }, this.scrollTime);
                    }
                }, {
                    key: "scrollTo",
                    value: function scrollTo(Y, duration, callback) {
                        // scroll animation loop w/ easing
                        // credit https://gist.github.com/dezinezync/5487119
                        var start = Date.now(),
                            from = this.lastOverscroll;
                        if (from === Y) {
                            callback();
                            return; /* Prevent scrolling to the Y point if already there */
                        }
                        // decelerating to zero velocity
                        function easeOutCubic(t) {
                            return --t * t * t + 1;
                        }
                        // scroll loop
                        function scroll() {
                            var currentTime = Date.now(),
                                time = Math.min(1, (currentTime - start) / duration),

                            // where .5 would be 50% of time on a linear scale easedT gives a
                            // fraction based on the easing method
                            easedT = easeOutCubic(time);
                            this.overscroll(parseInt(easedT * (Y - from) + from, 10));
                            if (time < 1) {
                                raf(scroll.bind(this));
                            } else {
                                if (Y < 5 && Y > -5) {
                                    this.isOverscrolling = false;
                                    this.setScrollLock(false);
                                }
                                callback && callback();
                            }
                        }
                        // start scroll loop
                        raf(scroll.bind(this));
                    }
                }, {
                    key: "_handleTouchMove",
                    value: function _handleTouchMove(e) {
                        //console.log('TOUCHMOVE', e);
                        // if multitouch or regular scroll event, get out immediately
                        if (!this.canOverscroll || e.touches.length > 1) {
                            return;
                        }
                        //if this is a new drag, keep track of where we start
                        if (this.startY === null) {
                            this.startY = parseInt(e.touches[0].screenY, 10);
                        }
                        // kitkat fix for touchcancel events http://updates.html5rocks.com/2014/05/A-More-Compatible-Smoother-Touch
                        /*
                        if (ionic.Platform.isAndroid() && ionic.Platform.version() === 4.4 && scrollAncestor.scrollTop === 0) {
                          isDragging = true;
                          e.preventDefault();
                        }
                        */
                        // how far have we dragged so far?
                        this.deltaY = parseInt(e.touches[0].screenY, 10) - this.startY;
                        // if we've dragged up and back down in to native scroll territory
                        if (this.deltaY - this.dragOffset <= 0 || this.scrollAncestor.scrollTop !== 0) {
                            if (this.isOverscrolling) {
                                this.isOverscrolling = false;
                                this.setScrollLock(false);
                            }
                            if (this.isDragging) {
                                this.nativescroll(this.scrollAncestor, parseInt(this.deltaY - this.dragOffset, 10) * -1);
                            }
                            // if we're not at overscroll 0 yet, 0 out
                            if (this.lastOverscroll !== 0) {
                                this.overscroll(0);
                            }
                            return;
                        } else if (this.deltaY > 0 && this.scrollAncestor.scrollTop === 0 && !this.isOverscrolling) {
                            // starting overscroll, but drag started below scrollTop 0, so we need to offset the position
                            this.dragOffset = this.deltaY;
                        }
                        // prevent native scroll events while overscrolling
                        e.preventDefault();
                        // if not overscrolling yet, initiate overscrolling
                        if (!this.isOverscrolling) {
                            this.isOverscrolling = true;
                            this.setScrollLock(true);
                        }
                        this.isDragging = true;
                        // overscroll according to the user's drag so far
                        this.overscroll(parseInt((this.deltaY - this.dragOffset) / 3, 10));
                        // Pass an incremental pull amount to the EventEmitter
                        this.pulling.next(this.lastOverscroll);
                        // update the icon accordingly
                        if (!this.activated && this.lastOverscroll > this.ptrThreshold) {
                            this.activated = true;
                            raf(this.activate.bind(this));
                        } else if (this.activated && this.lastOverscroll < this.ptrThreshold) {
                            this.activated = false;
                            raf(this.deactivate.bind(this));
                        }
                    }
                }, {
                    key: "_handleTouchEnd",
                    value: function _handleTouchEnd(e) {
                        console.log("TOUCHEND", e);
                        // if this wasn't an overscroll, get out immediately
                        if (!this.canOverscroll && !this.isDragging) {
                            return;
                        }
                        // reset Y
                        this.startY = null;
                        // the user has overscrolled but went back to native scrolling
                        if (!this.isDragging) {
                            this.dragOffset = 0;
                            this.isOverscrolling = false;
                            this.setScrollLock(false);
                        } else {
                            this.isDragging = false;
                            this.dragOffset = 0;
                            // the user has scroll far enough to trigger a refresh
                            if (this.lastOverscroll > this.ptrThreshold) {
                                this.start();
                                this.scrollTo(this.ptrThreshold, this.scrollTime);
                            } else {
                                this.scrollTo(0, this.scrollTime, this.deactivate.bind(this));
                                this.isOverscrolling = false;
                            }
                        }
                    }
                }, {
                    key: "_handleScroll",
                    value: function _handleScroll(e) {
                        console.log("SCROLL", e.target.scrollTop);
                    }
                }]);

                return _class;
            })();

            _export("Refresher", Refresher);

            _export("Refresher", Refresher = __decorate([Component({
                selector: "ion-refresher",
                events: ["refresh", "starting", "pulling"],
                properties: ["pullingIcon", "pullingText", "refreshingIcon", "refreshingText", "spinner", "disablePullingRotation"],
                host: {
                    "[class.active]": "isActive",
                    "[class.refreshing]": "isRefreshing",
                    "[class.refreshingTail]": "isRefreshingTail"
                },
                lifecycle: [onInit]
            }), View({
                template: "<div class=\"refresher-content\" [class.refresher-with-text]=\"pullingText || refreshingText\">\n      <div class=\"icon-pulling\">\n        <i class=\"icon\" [class]=\"pullingIcon\"></i>\n      </div>\n      <div class=\"text-pulling\" [inner-html]=\"pullingText\" *ng-if=\"pullingText\"></div>\n      <div class=\"icon-refreshing\">\n        <!--<ion-spinner ng-if=\"showSpinner\" icon=\"{{spinner}}\"></ion-spinner>-->\n        <i class=\"icon\" [class]=\"refreshingIcon\"></i>\n      </div>\n      <div class=\"text-refreshing\" [inner-html]=\"refreshingText\" *ng-if=\"refreshingText\"></div>\n    </div>",
                directives: [NgIf, CSSClass]
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [typeof Content !== "undefined" && Content || Object, typeof ElementRef !== "undefined" && ElementRef || Object])], Refresher));
        }
    };
});
System.register("ionic/components/scroll/scroll", ["angular2/angular2", "../ion", "../../config/config", "../../config/annotations"], function (_export) {
    "use strict";

    var View, ElementRef, Ion, IonicConfig, IonicComponent, __decorate, __metadata, Scroll;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * ion-scroll is a non-flexboxed scroll area that can
             * scroll horizontally or vertically.
             */

            Scroll = (function (_Ion) {
                var _class = function Scroll(elementRef, ionicConfig) {
                    var _this = this;

                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                    setTimeout(function () {
                        _this.scrollElement = _this.getNativeElement().children[0];
                    });
                };

                _inherits(_class, _Ion);

                _createClass(_class, [{
                    key: "addScrollEventListener",
                    value: function addScrollEventListener(handler) {
                        var _this2 = this;

                        if (!this.scrollElement) {
                            return;
                        }
                        this.scrollElement.addEventListener("scroll", handler);
                        return function () {
                            _this2.scrollElement.removeEventListener("scroll", handler);
                        };
                    }
                }]);

                return _class;
            })(Ion);

            _export("Scroll", Scroll);

            _export("Scroll", Scroll = __decorate([IonicComponent({
                selector: "ion-scroll",
                properties: ["scrollX", "scrollY"],
                host: {
                    "[class.scroll-x]": "scrollX",
                    "[class.scroll-y]": "scrollY"
                }
            }), View({
                template: "<div class=\"scroll-content\"><ng-content></ng-content></div>"
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], Scroll));
        }
    };
});
System.register("ionic/components/search-bar/search-bar", ["angular2/angular2", "../ion", "../../config/config", "../../config/annotations"], function (_export) {
    "use strict";

    var ElementRef, Ion, IonicConfig, IonicComponent, IonicView, __decorate, __metadata, SearchBar;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
            IonicView = _configAnnotations.IonicView;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            SearchBar = (function (_Ion) {
                var _class = function SearchBar(elementRef, ionicConfig //,
                ) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                    // this.controlDirective = cd;
                    // cd.valueAccessor = this; //ControlDirective should inject CheckboxControlDirective
                    this.query = "";
                };

                _inherits(_class, _Ion);

                _createClass(_class, [{
                    key: "writeValue",

                    /**
                     * Much like ngModel, this is called from our valueAccessor for the attached
                     * ControlDirective to update the value internally.
                     */
                    value: function writeValue(value) {
                        this.value = value;
                    }
                }, {
                    key: "inputChanged",
                    value: function inputChanged(event) {
                        this.value = event.target.value;
                        console.log("Search changed", this.value);
                        // TODO: Better way to do this?
                        this.controlDirective._control().updateValue(event.target.value);
                    }
                }, {
                    key: "inputFocused",
                    value: function inputFocused() {
                        this.isFocused = true;
                        this.shouldLeftAlign = true;
                    }
                }, {
                    key: "inputBlurred",
                    value: function inputBlurred() {
                        this.isFocused = false;
                        this.shouldLeftAlign = this.value.trim() != "";
                    }
                }]);

                return _class;
            })(Ion);

            _export("SearchBar", SearchBar);

            _export("SearchBar", SearchBar = __decorate([IonicComponent({
                selector: "ion-search-bar",
                properties: ["list", "query"],
                defaultProperties: {
                    "cancelText": "Cancel",
                    "placeholder": "Search"
                }
            }), IonicView({
                template: "\n  <div class=\"search-bar-input-container\" [class.left-align]=\"shouldLeftAlign\">\n    <div class=\"search-bar-icon\"></div>\n    <input (focus)=\"inputFocused()\" (blur)=\"inputBlurred()\"\n    (input)=\"inputChanged($event)\" class=\"search-bar-input\" type=\"search\" [attr.placeholder]=\"placeholder\">\n  </div>\n  <button class=\"search-bar-cancel\">{{cancelText}}</button>"
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], SearchBar));
            /*
            export class SearchPipe extends Pipe {
              constructor() {
                super();
                this.state = 0;
              }
            
              supports(newValue) {
                return true;
              }
            
              transform(value, ...args) {
                console.log('Transforming', value, args);
                return value;
                //return `${value} state:${this.state ++}`;
              }
            
              create(cdRef) {
                console.log('REF', cdRef);
                return new SearchPipe(cdRef);
              }
            }
            */
        }
    };
});
System.register("ionic/components/segment/segment", ["angular2/angular2", "angular2/forms", "../ion", "../../config/config", "../../config/annotations"], function (_export) {
    "use strict";

    var View, Renderer, ElementRef, EventEmitter, Ancestor, forwardRef, NgControl, Ion, IonicConfig, IonicDirective, IonicComponent, __decorate, __metadata, __param, Segment, SegmentControlValueAccessor, SegmentButton;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            View = _angular2Angular2.View;
            Renderer = _angular2Angular2.Renderer;
            ElementRef = _angular2Angular2.ElementRef;
            EventEmitter = _angular2Angular2.EventEmitter;
            Ancestor = _angular2Angular2.Ancestor;
            forwardRef = _angular2Angular2.forwardRef;
        }, function (_angular2Forms) {
            NgControl = _angular2Forms.NgControl;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicDirective = _configAnnotations.IonicDirective;
            IonicComponent = _configAnnotations.IonicComponent;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Segment = (function (_Ion) {
                var _class = function Segment(cd, elementRef, ionicConfig, renderer) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                    this.ele = elementRef.nativeElement;
                    this.elementRef = elementRef;
                    this.renderer = renderer;
                    this.change = new EventEmitter("change");
                    this.input = new EventEmitter("input");
                    this.cd = cd;
                    this.buttons = [];
                };

                _inherits(_class, _Ion);

                _createClass(_class, [{
                    key: "register",

                    /**
                     * Called by child SegmentButtons to bind themselves to
                     * the Segment.
                     */
                    value: function register(segmentButton) {
                        this.buttons.push(segmentButton);
                        // If this button is registered and matches our value,
                        // make sure to select it
                        if (this.value == segmentButton.value) {
                            this.selected(segmentButton);
                        }
                    }
                }, {
                    key: "selectFromValue",

                    /**
                     * Select the button with the given value.
                     */
                    value: function selectFromValue(value) {
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = this.buttons[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var button = _step.value;

                                if (button.value === value) {
                                    button.isActive = true;
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator["return"]) {
                                    _iterator["return"]();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    }
                }, {
                    key: "selected",

                    /**
                     * Indicate a button should be selected.
                     */
                    value: function selected(segmentButton) {
                        var _this = this;

                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;

                        try {
                            for (var _iterator2 = this.buttons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                var button = _step2.value;

                                button.isActive = false;
                            }
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                                    _iterator2["return"]();
                                }
                            } finally {
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }

                        segmentButton.isActive = true;
                        //this.onChange();
                        setTimeout(function () {
                            _this.value = segmentButton.value;
                            _this.cd.valueAccessor.writeValue(segmentButton.value);
                            _this.selectFromValue(segmentButton.value);
                            _this.cd.control.updateValue(segmentButton.value);
                            // Trigger on change
                            _this.change.next();
                        });
                        //this.ngControl.control().updateValue(this.value);
                        // TODO: Better way to do this?
                        //this.controlDirective._control().updateValue(this.value);
                    }
                }]);

                return _class;
            })(Ion);

            _export("Segment", Segment);

            _export("Segment", Segment = __decorate([IonicComponent({
                selector: "ion-segment",
                appInjector: [NgControl],
                properties: ["value"],
                host: {
                    "(click)": "buttonClicked($event)",
                    "(change)": "onChange($event)"
                }
            }), View({
                template: "<div class=\"ion-segment\"><ng-content></ng-content></div>",
                directives: [forwardRef(function () {
                    return SegmentButton;
                })]
            }), __metadata("design:paramtypes", [typeof NgControl !== "undefined" && NgControl || Object, typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object, typeof Renderer !== "undefined" && Renderer || Object])], Segment));

            SegmentControlValueAccessor = (function () {
                var _class2 = function SegmentControlValueAccessor(cd, renderer, elementRef, segment) {
                    _classCallCheck(this, _class2);

                    this.onChange = function (_) {};
                    this.onTouched = function (_) {};
                    this.cd = cd;
                    this.renderer = renderer;
                    this.elementRef = elementRef;
                    this.segment = segment;
                    cd.valueAccessor = this;
                };

                _createClass(_class2, [{
                    key: "writeValue",
                    value: function writeValue(value) {
                        // both this.value and setProperty are required at the moment
                        // remove when a proper imperative API is provided
                        this.value = !value ? "" : value;
                        this.renderer.setElementProperty(this.elementRef, "value", this.value);
                        this.segment.value = this.value;
                        this.segment.selectFromValue(value);
                    }
                }, {
                    key: "registerOnChange",
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }
                }, {
                    key: "registerOnTouched",
                    value: function registerOnTouched(fn) {
                        this.onTouched = fn;
                    }
                }]);

                return _class2;
            })();

            _export("SegmentControlValueAccessor", SegmentControlValueAccessor);

            _export("SegmentControlValueAccessor", SegmentControlValueAccessor = __decorate([IonicDirective({
                selector: "ion-segment",
                //properties: ['value'],
                host: {
                    "(change)": "onChange($event.target.value)",
                    "(input)": "onChange($event.target.value)",
                    "(blur)": "onTouched()"
                }
            }), __metadata("design:paramtypes", [typeof NgControl !== "undefined" && NgControl || Object, typeof Renderer !== "undefined" && Renderer || Object, typeof ElementRef !== "undefined" && ElementRef || Object, Segment])], SegmentControlValueAccessor));

            SegmentButton = (function () {
                var _class3 = function SegmentButton(segment, elementRef) {
                    _classCallCheck(this, _class3);

                    this.ele = elementRef.ele;
                    this.segment = segment;
                };

                _createClass(_class3, [{
                    key: "onInit",
                    value: function onInit() {
                        this.segment.register(this);
                    }
                }, {
                    key: "buttonClicked",
                    value: function buttonClicked(event) {
                        this.segment.selected(this, event);
                        event.preventDefault();
                    }
                }]);

                return _class3;
            })();

            _export("SegmentButton", SegmentButton);

            _export("SegmentButton", SegmentButton = __decorate([IonicDirective({
                selector: "ion-segment-button",
                properties: ["value"],
                host: {
                    "(click)": "buttonClicked($event)",
                    "[class.active]": "isActive"
                }
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [Segment, typeof ElementRef !== "undefined" && ElementRef || Object])], SegmentButton));
        }
    };
});
System.register("ionic/components/show-hide-when/show-hide-when", ["angular2/angular2", "../../platform/platform"], function (_export) {
    "use strict";

    var Directive, Attribute, NgZone, Platform, __decorate, __metadata, __param, DisplayWhen, ShowWhen, HideWhen;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Attribute = _angular2Angular2.Attribute;
            NgZone = _angular2Angular2.NgZone;
        }, function (_platformPlatform) {
            Platform = _platformPlatform.Platform;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            DisplayWhen = (function () {
                function DisplayWhen(conditions, ngZone) {
                    var _this = this;

                    _classCallCheck(this, DisplayWhen);

                    this.isMatch = false;
                    if (!conditions) return;
                    this.conditions = conditions.split(",");
                    // check if its one of the matching platforms first
                    // a platform does not change during the life of an app
                    for (var i = 0; i < this.conditions.length; i++) {
                        if (this.conditions[i] && Platform.is(this.conditions[i])) {
                            this.isMatch = true;
                            return;
                        }
                    }
                    if (this.orientation()) {
                        // add window resize listener
                        Platform.onResize(function () {
                            ngZone.run(function () {
                                _this.orientation();
                            });
                        });
                        return;
                    }
                }

                _createClass(DisplayWhen, [{
                    key: "orientation",
                    value: function orientation() {
                        for (var i = 0; i < this.conditions.length; i++) {
                            var condition = this.conditions[i];
                            if (condition == "portrait") {
                                this.isMatch = Platform.isPortrait();
                                return true;
                            }
                            if (condition == "landscape") {
                                this.isMatch = Platform.isLandscape();
                                return true;
                            }
                        }
                    }
                }]);

                return DisplayWhen;
            })();

            ShowWhen = (function (_DisplayWhen) {
                var _class = function ShowWhen(showWhen, ngZone) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, showWhen, ngZone);
                };

                _inherits(_class, _DisplayWhen);

                _createClass(_class, [{
                    key: "hidden",
                    get: function get() {
                        return !this.isMatch;
                    }
                }]);

                return _class;
            })(DisplayWhen);

            _export("ShowWhen", ShowWhen);

            _export("ShowWhen", ShowWhen = __decorate([Directive({
                selector: "[show-when]",
                host: {
                    "[hidden]": "hidden"
                }
            }), __param(0, Attribute("show-when")), __metadata("design:paramtypes", [String, typeof NgZone !== "undefined" && NgZone || Object])], ShowWhen));

            HideWhen = (function (_DisplayWhen2) {
                var _class2 = function HideWhen(hideWhen, ngZone) {
                    _classCallCheck(this, _class2);

                    _get(Object.getPrototypeOf(_class2.prototype), "constructor", this).call(this, hideWhen, ngZone);
                };

                _inherits(_class2, _DisplayWhen2);

                _createClass(_class2, [{
                    key: "hidden",
                    get: function get() {
                        return this.isMatch;
                    }
                }]);

                return _class2;
            })(DisplayWhen);

            _export("HideWhen", HideWhen);

            _export("HideWhen", HideWhen = __decorate([Directive({
                selector: "[hide-when]",
                host: {
                    "[hidden]": "hidden"
                }
            }), __param(0, Attribute("hide-when")), __metadata("design:paramtypes", [String, typeof NgZone !== "undefined" && NgZone || Object])], HideWhen));
        }
    };
});
System.register("ionic/components/slides/slides", ["angular2/angular2", "ionic/gestures/drag-gesture", "../../config/annotations", "ionic/util"], function (_export) {
    "use strict";

    var Component, View, ElementRef, Ancestor, NgFor, DragGesture, IonicComponent, IonicDirective, dom, util, __decorate, __metadata, __param, Slides, Slide, SlidePager, SlidesGesture;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
            Ancestor = _angular2Angular2.Ancestor;
            NgFor = _angular2Angular2.NgFor;
        }, function (_ionicGesturesDragGesture) {
            DragGesture = _ionicGesturesDragGesture.DragGesture;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
            IonicDirective = _configAnnotations.IonicDirective;
        }, function (_ionicUtil) {
            dom = _ionicUtil.dom;
            util = _ionicUtil;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            /**
             * Slides is a slide box implementation based off of swipe.js
             * and the ionic1 implementation.
             *
             * May 21st, 2015
             * @maxlynch
             *
             * * TODO: Finish the slideshow, should continue on transition end or a
             *         similar event.
             * * TODO: Add support for 2 slide cloning
             * * TODO: Test support for N-slide sliding (like go 2 slides ahead)
             * * TODO: Analyze performance, add request animation frame if necessary
             * * TODO: Test mouse support
             * * TODO: Port over mouse handling
             */

            Slides = (function () {
                var _class = function Slides(elementRef) {
                    _classCallCheck(this, _class);

                    // Grab the main container, and the slides-view wrapper
                    this.ele = elementRef.nativeElement;
                    this.slides = [];
                    this.currentIndex = 0;
                    // How quickly to animate between slides
                    this.animateSpeed = 300;
                    // How often to switch slides automatically. Zero is no auto sliding
                    this.slideDelay = 0; //3000;
                    // Whether to bounce on the edges if not continuous (overscrolling)
                    this.bounce = false;
                    // Initialize our slides gesture handler
                    this.gesture = new SlidesGesture(this);
                    this.gesture.listen();
                };

                _createClass(_class, [{
                    key: "onInit",
                    value: function onInit() {
                        this.continuous = util.isDefined(this.loop) && (this.slides.length > 1 ? true : false);
                        // Grab the wrapper element that contains the slides
                        this.wrapperElement = this.ele.children[0];
                        this.resize();
                        if (this.slideDelay) {
                            this.startShow();
                        }
                        //special case if two slides
                        /*
                        if (this.continuous && this.slides.length < 3) {
                          this.element.appendChild(this.slides[0].clone())//cloneNode(true));
                          element.appendChild(element.children[1].cloneNode(true));
                          slides = element.children;
                        }
                        */
                    }
                }, {
                    key: "startShow",

                    /**
                     * Start the slideshow.
                     */
                    value: function startShow() {
                        this._showTimeout = setTimeout(this.next.bind(this), this.slideDelay);
                    }
                }, {
                    key: "stopShow",

                    /**
                     * End the slideshow.
                     */
                    value: function stopShow() {
                        clearTimeout(this._showTimout);
                    }
                }, {
                    key: "setPager",

                    /**
                     * Set the pager element for handling rendering of page icons and
                     * switching slides through clicks, etc.
                     */
                    value: function setPager(pager) {
                        this._pager = pager;
                    }
                }, {
                    key: "resize",
                    value: function resize() {
                        // Get the width of the container, which is the viewport
                        // that the user will actually see.
                        this.containerWidth = this.ele.offsetWidth || this.ele.getBoundingClientRect().width;
                        // Set the wrapper element to the total width of the child elements
                        this.wrapperElement.style.width = this.containerWidth * this.slides.length + "px";
                        // Position all the child slides
                        this._bump();
                    }
                }, {
                    key: "add",

                    /**
                     * Add a new slide to the slides.
                     */
                    value: function add(slide) {
                        this._append(slide);
                    }
                }, {
                    key: "slide",
                    value: function slide(to, slideSpeed) {
                        var index = this.currentIndex;
                        var width = this.containerWidth;
                        // do nothing if already on requested slide
                        if (index == to) return;
                        var direction = Math.abs(index - to) / (index - to); // 1: backward, -1: forward
                        // get the actual position of the slide
                        if (this.continuous) {
                            var natural_direction = direction;
                            direction = -this.slides[this._circle(to)].x / width;
                            // if going forward but to < index, use to = slides.length + to
                            // if going backward but to > index, use to = -slides.length + to
                            if (direction !== natural_direction) to = -direction * this.slides.length + to;
                        }
                        var diff = Math.abs(index - to) - 1;
                        // move all the slides between index and to in the right direction
                        while (diff--) this._move(this._circle((to > index ? to : index) - diff - 1), width * direction, 0);
                        to = this._circle(to);
                        this._move(index, width * direction, slideSpeed || this.animateSpeed);
                        this._move(to, 0, slideSpeed || this.animateSpeed);
                        if (this.continuous) this._move(this._circle(to - direction), -(width * direction), 0); // we need to get the next in place
                        this.currentIndex = to;
                        //offloadFn(options.callback && options.callback(index, slides[index]));
                    }
                }, {
                    key: "prev",

                    /**
                     * Slide left, possibly wrapping around in continuous mode.
                     */
                    value: function prev() {
                        if (this.continuous) {
                            // Always allow us to go back
                            this.slide(this.currentIndex - 1);
                        } else if (this.currentIndex > 0) {
                            // If we have one slide to the left
                            this.slide(this.currentIndex - 1);
                        }
                    }
                }, {
                    key: "next",

                    /**
                     * Slide right, possibly wrapping around in continuous mode.
                     */
                    value: function next() {
                        if (this.continuous) {
                            // Always allow us to go next
                            this.slide(this.currentIndex + 1);
                        } else if (this.currentIndex < this.slides.length - 1) {
                            // If not in continuous mode, only slide if we have a right slide
                            this.slide(this.currentIndex + 1);
                        }
                    }
                }, {
                    key: "_bump",

                    // Reposition all the existing slides so they are in the right position
                    value: function _bump() {
                        var slide = undefined;
                        var tx = undefined;
                        var i = this.slides.length;
                        while (i--) {
                            slide = this.slides[i];
                            // Set the slide's left position to a negative of the current index and its width
                            slide.left = i * -this.containerWidth;
                            slide.width = this.containerWidth;
                            // Check if this slide is before or after the currently active one,
                            // since we have to position it before or after it
                            tx = 0;
                            if (this.currentIndex > i) {
                                tx = -this.containerWidth;
                            } else if (this.currentIndex < i) {
                                tx = this.containerWidth;
                            }
                            this._move(i, tx);
                        }
                        if (this.continuous) {
                            // If we are in continuous mode, we need to wrap the previous and
                            // last element to get a complete "circle"
                            var index1 = this._circle(this.currentIndex - 1);
                            var index2 = this._circle(this.currentIndex + 1);
                            this._move(index1, -this.containerWidth); //, 0);
                            this._move(index2, this.containerWidth); //, 0);
                        }
                    }
                }, {
                    key: "_dragStart",
                    value: function _dragStart(event) {
                        this._isScrolling = undefined;
                    }
                }, {
                    key: "_dragPre",

                    /**
                     * Code to run before operating on a drag.
                     */
                    value: function _dragPre(event) {
                        var dx = event.gesture.deltaX;
                        var dy = event.gesture.deltaY;
                        if (this.disableScroll) {
                            event.preventDefault();
                        }
                        // determine if scrolling test has run - one time test
                        if (typeof this._isScrolling == "undefined") {
                            this._isScrolling = !!(this._isScrolling || Math.abs(dx) < Math.abs(dy));
                        }
                        // If we're scrolling, never run the drag
                        if (this._isScrolling) {
                            return false;
                        }
                    }
                }, {
                    key: "_drag",

                    // Process a drag, with a deltaX value
                    value: function _drag(event) {
                        var dx = event.gesture.deltaX;
                        var width = this.containerWidth;
                        var index = this.currentIndex;
                        // Check if we should run (scroll detection, etc)
                        var shouldRun = this._dragPre(event);
                        if (shouldRun === false) {
                            return;
                        }
                        // We're doing this
                        event.preventDefault();
                        var index1 = undefined,
                            index2 = undefined,
                            index3 = undefined;
                        if (this.continuous) {
                            // Grab the left/center/right slides
                            index1 = this._circle(this.currentIndex - 1);
                            index2 = this.currentIndex;
                            index3 = this._circle(this.currentIndex + 1);
                        } else {
                            index1 = this.currentIndex - 1;
                            index2 = this.currentIndex;
                            index3 = this.currentIndex + 1;
                            var isPastBounds = index == 0 && dx > 0 // if first slide and slide amt is greater than 0
                            || index == this.slides.length - 1 && dx < 0; // or if last slide and slide amt is less than 0
                            if (this.bounce) {
                                // If we have drag bouncing/overscroll enabled,
                                // let's slow down the drag on the edges
                                // if first slide and sliding left
                                // or if last slide and sliding right
                                // and if sliding at all,
                                // Adjust resistance
                                dx = dx / (!index && dx > 0 || index == this.slides.length - 1 && dx < 0 ? Math.abs(dx) / width + 1 : 1);
                            } else if (isPastBounds) {
                                // We aren't overscrolling (bouncing), and we're past the bounds
                                var slide = this.slides[index];
                                return;
                            }
                        }
                        var s1 = this.slides[index1];
                        var s2 = this.slides[index2];
                        var s3 = this.slides[index3];
                        // Translate the left/center/right slides based on the deltaX of the drag
                        if (s1) {
                            s1.translate(dx + s1.x);
                        }
                        if (s2) {
                            s2.translate(dx + s2.x);
                        }
                        if (s3) {
                            s3.translate(dx + s3.x);
                        }
                    }
                }, {
                    key: "_endDrag",
                    value: function _endDrag(event, drag) {
                        this._finish(event, drag);
                    }
                }, {
                    key: "_finish",
                    value: function _finish(event, drag) {
                        var delta = {
                            x: event.gesture.deltaX,
                            y: event.gesture.deltaY
                        };
                        var width = this.containerWidth;
                        var index = this.currentIndex;
                        var slides = this.slides;
                        var move = this._move.bind(this);
                        var circle = this._circle.bind(this);
                        var isScrolling = this._isScrolling;
                        var speed = this.animateSpeed;
                        // measure duration
                        var duration = +new Date() - drag.time;
                        // determine if slide attempt triggers next/prev slide
                        var isValidSlide = Number(duration) < 250 // if slide duration is less than 250ms
                        && Math.abs(delta.x) > 20 // and if slide amt is greater than 20px
                        || Math.abs(delta.x) > width / 3; // or if slide amt is greater than half the width
                        // determine if slide attempt is past start and end
                        var isPastBounds = !index && delta.x > 0 // if first slide and slide amt is greater than 0
                        || index == slides.length - 1 && delta.x < 0; // or if last slide and slide amt is less than 0
                        if (this.continuous) isPastBounds = false;
                        // determine direction of swipe (true:right, false:left)
                        var direction = delta.x < 0;
                        // if not scrolling vertically
                        if (!isScrolling) {
                            if (isValidSlide && !isPastBounds) {
                                if (direction) {
                                    if (this.continuous) {
                                        move(circle(index - 1), -width, 0);
                                        move(circle(index + 2), width, 0);
                                    } else {
                                        move(index - 1, -width, 0);
                                    }
                                    move(index, slides[index].x - width, speed);
                                    move(circle(index + 1), slides[circle(index + 1)].x - width, speed);
                                    this.currentIndex = circle(index + 1);
                                } else {
                                    if (this.continuous) {
                                        move(circle(index + 1), width, 0);
                                        move(circle(index - 2), -width, 0);
                                    } else {
                                        move(index + 1, width, 0);
                                    }
                                    move(index, slides[index].x + width, speed);
                                    move(circle(index - 1), slides[circle(index - 1)].x + width, speed);
                                    this.currentIndex = circle(index - 1);
                                }
                            } else {
                                if (this.continuous) {
                                    move(circle(index - 1), -width, speed);
                                    move(index, 0, speed);
                                    move(circle(index + 1), width, speed);
                                } else {
                                    move(index - 1, -width, speed);
                                    move(index, 0, speed);
                                    move(index + 1, width, speed);
                                }
                            }
                        }
                        // kill touchmove and touchend event listeners until touchstart called again
                        //element.removeEventListener('touchmove', events, false)
                        //element.removeEventListener('touchend', events, false)
                    }
                }, {
                    key: "_move",
                    value: function _move(pos, translateX, speed) {
                        // Should already be wrapped with circle
                        var slide = this.slides[pos];
                        if (!slide) {
                            return;
                        }
                        slide.translate(translateX, speed);
                        slide.x = translateX;
                    }
                }, {
                    key: "_circle",

                    // A modulo "circle" to stay in the bounds of the slide array
                    value: function _circle(i) {
                        return (this.slides.length + i % this.slides.length) % this.slides.length;
                    }
                }, {
                    key: "_append",
                    value: function _append(slide) {
                        this.slides.push(slide);
                    }
                }, {
                    key: "_prepend",
                    value: function _prepend(slide) {
                        this.slides.unshift(slide);
                    }
                }]);

                return _class;
            })();

            _export("Slides", Slides);

            _export("Slides", Slides = __decorate([IonicComponent({
                selector: "ion-slides",
                properties: ["loop", "index", "bounce"]
            }), View({
                template: "<div class=\"slides-view\"><ng-content></ng-content></div>"
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object])], Slides));

            Slide = (function () {
                var _class2 = function Slide(slides, elementRef) {
                    _classCallCheck(this, _class2);

                    this.ele = elementRef.nativeElement;
                    slides.add(this);
                };

                _createClass(_class2, [{
                    key: "translate",
                    value: function translate(x, duration) {
                        this._translateX = x;
                        duration = duration || 0;
                        this.ele.style[dom.CSS.transition + "Duration"] = duration + "ms";
                        this.ele.style[dom.CSS.transform] = "translate3d(" + x + "px, 0, 0)";
                    }
                }, {
                    key: "translateX",
                    get: function get() {
                        return this._translateX;
                    }
                }, {
                    key: "left",
                    set: function set(x) {
                        this._left = x;
                        this.ele.style.left = x + "px";
                    },
                    get: function get() {
                        return this._left;
                    }
                }, {
                    key: "width",
                    set: function set(width) {
                        this._width = width;
                        this.ele.style.width = width + "px";
                    },
                    get: function get() {
                        return this._width;
                    }
                }]);

                return _class2;
            })();

            _export("Slide", Slide);

            _export("Slide", Slide = __decorate([IonicDirective({
                selector: "ion-slide"
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [Slides, typeof ElementRef !== "undefined" && ElementRef || Object])], Slide));

            SlidePager = (function () {
                var _class3 = function SlidePager(slides, elementRef) {
                    _classCallCheck(this, _class3);

                    this.ele = elementRef.nativeElement;
                    this.slides = slides;
                    this.slides.setPager(this);
                };

                _createClass(_class3, [{
                    key: "getSlides",
                    value: function getSlides() {
                        return this.slides.slides;
                    }
                }]);

                return _class3;
            })();

            _export("SlidePager", SlidePager);

            _export("SlidePager", SlidePager = __decorate([Component({
                selector: "ion-pager"
            }), View({
                //[class.active]="$index == currentSlide}" ng-click="pagerClick($index)"><i class="icon ion-record"></i></span></div>',
                template: "<span class=\"slide-pager-page\" *ng-for=\"#page of getSlides()\">{{page.width}}<i class=\"icon ion-record\"></i>X</span>",
                directives: [NgFor]
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [Slides, typeof ElementRef !== "undefined" && ElementRef || Object])], SlidePager));

            SlidesGesture = (function (_DragGesture) {
                function SlidesGesture(slides) {
                    _classCallCheck(this, SlidesGesture);

                    _get(Object.getPrototypeOf(SlidesGesture.prototype), "constructor", this).call(this, slides.ele);
                    this.slides = slides;
                }

                _inherits(SlidesGesture, _DragGesture);

                _createClass(SlidesGesture, [{
                    key: "onDrag",
                    value: function onDrag(event) {
                        var x = event.gesture.center.x;
                        var y = event.gesture.center.y;
                        this._drag.x = x;
                        this._drag.y = y;
                        this.slides._drag(event);
                    }
                }, {
                    key: "onDragStart",
                    value: function onDragStart(event) {
                        this._drag = {
                            startX: event.gesture.center.x,
                            startY: event.gesture.center.y,
                            time: +new Date()
                        };
                        this.slides._dragStart(event, this._drag);
                    }
                }, {
                    key: "onDragEnd",
                    value: function onDragEnd(event) {
                        this.slides._endDrag(event, this._drag);
                    }
                }]);

                return SlidesGesture;
            })(DragGesture);

            _export("SlidesGesture", SlidesGesture);
        }
    };
});
// determine resistance level
System.register("ionic/components/switch/switch", ["angular2/angular2", "../form/input", "../../config/config", "../../config/annotations"], function (_export) {
    "use strict";

    var ElementRef, Renderer, Optional, NgControl, IonInputItem, IonicConfig, IonicComponent, IonicView, __decorate, __metadata, __param, Switch;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Renderer = _angular2Angular2.Renderer;
            Optional = _angular2Angular2.Optional;
            NgControl = _angular2Angular2.NgControl;
        }, function (_formInput) {
            IonInputItem = _formInput.IonInputItem;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
            IonicView = _configAnnotations.IonicView;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Switch = (function (_IonInputItem) {
                var _class = function Switch(cd, renderer, elementRef, config) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, config);
                    this.onChange = function (_) {};
                    this.onTouched = function (_) {};
                    this.renderer = renderer;
                    this.elementRef = elementRef;
                    this.cd = cd;
                    if (cd) cd.valueAccessor = this;
                };

                _inherits(_class, _IonInputItem);

                _createClass(_class, [{
                    key: "onInit",
                    value: function onInit() {
                        _get(Object.getPrototypeOf(_class.prototype), "onInit", this).call(this);
                        console.log("switch onInit");
                    }
                }, {
                    key: "onAllChangesDone",
                    value: function onAllChangesDone() {
                        return;
                        console.log("switch onAllChangesDone");
                        if (this._checked !== void 0 && this.input.checked != this._checked) {
                            if (this.input.checked !== void 0) {
                                console.warn("switch checked is set in view template and Control declaration.\n" + "Value: " + !!this._checked + " from Control takes precedence");
                            }
                            this.input.checked = !!this._checked;
                        }
                        if (this._value !== void 0 && this.input.value != this._value) {
                            if (this.input.value !== void 0) {
                                console.warn("switch value is set in view template and Control declaration.\n" + "Value: " + this._value + " from Control takes precedence");
                            }
                            this.input.value = this._value;
                        }
                        if (this.input.value === void 0) {
                            this.input.value = "on";
                        }
                        if (this.input.checked === void 0) {
                            this.input.checked = false;
                        }
                        //TODO check validity
                        this.cd.control._value = { "checked": !!this.input.checked, "value": this.input.value };
                        //TODO only want to call this once, we want to set input.checked directly on subsequent
                        // writeValue's
                        this.onAllChangesDone = function () {};
                        // this.onChange({"checked": this.input.checked, "value": this.input.value});
                    }
                }, {
                    key: "toggle",

                    //from clicking the label or selecting with keyboard
                    //view -> model (Control)
                    value: function toggle() {
                        this.input.checked = this._checked = !this.input.checked;
                        this.onChange({ "checked": this.input.checked, "value": this.input.value });
                    }
                }, {
                    key: "writeValue",

                    // Called by the model (Control) to update the view
                    value: function writeValue(modelValue) {
                        var type = typeof modelValue;
                        switch (type) {
                            case "boolean":
                                // don't set input.value here, do it in onAllChangesDone
                                // because they might have set it in the view
                                this._checked = modelValue;
                                break;
                            case "object":
                                if (modelValue.checked !== void 0) this._checked = !!modelValue.checked;
                                if (modelValue.value !== void 0) this._value = modelValue.value.toString();
                                break;
                            default:
                                // don't set input.checked here, do it in onAllChangesDone
                                // because they might have set it in the view
                                this._value = modelValue.toString();
                        }
                        //TODO we want to set input.checked directly after the first time
                        console.log("writeValue, " + this.input.id + " checked: " + this._checked);
                        console.log("writeValue " + this.input.id + " value: " + this._value);
                        // this.cd.control._value = {"checked": this.input.checked, "value": this.input.value};
                    }
                }, {
                    key: "registerOnChange",

                    // Used by the view to update the model (Control)
                    // Up to us to call it in update()
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }
                }, {
                    key: "registerOnTouched",
                    value: function registerOnTouched(fn) {
                        this.onTouched = fn;
                    }
                }]);

                return _class;
            })(IonInputItem);

            _export("Switch", Switch);

            _export("Switch", Switch = __decorate([IonicComponent({
                selector: "ion-switch",
                host: {
                    "class": "item"
                }
            }), IonicView({
                template: "<div class=\"item-content\">" + "<ng-content></ng-content>" + "</div>" + "<div class=\"item-media media-switch\">" + "<div class=\"switch-track\">" + "<div class=\"switch-handle\"></div>" + "</div>" + "</div>"
            }), __param(0, Optional()), __metadata("design:paramtypes", [typeof NgControl !== "undefined" && NgControl || Object, typeof Renderer !== "undefined" && Renderer || Object, typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], Switch));
        }
    };
});
System.register("ionic/components/tabs/tab", ["angular2/angular2", "../view/view-controller", "../view/view-item", "./tabs"], function (_export) {
    "use strict";

    var Directive, Component, View, Ancestor, ElementRef, forwardRef, Injector, ViewController, ViewItem, Tabs, __decorate, __metadata, __param, Tab, TabPaneAnchor;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            Ancestor = _angular2Angular2.Ancestor;
            ElementRef = _angular2Angular2.ElementRef;
            forwardRef = _angular2Angular2.forwardRef;
            Injector = _angular2Angular2.Injector;
        }, function (_viewViewController) {
            ViewController = _viewViewController.ViewController;
        }, function (_viewViewItem) {
            ViewItem = _viewViewItem.ViewItem;
        }, function (_tabs) {
            Tabs = _tabs.Tabs;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Tab = (function (_ViewController) {
                var _class = function Tab(tabs, elementRef, injector) {
                    var _this = this;

                    _classCallCheck(this, _class);

                    // A Tab is both a container of many views, and is a view itself.
                    // A Tab is one ViewItem within it's Ancestor Tabs (which extends ViewController)
                    // A Tab is a ViewController for its child ViewItems
                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, tabs, injector, elementRef);
                    this.tabs = tabs;
                    this.childNavbar(true);
                    var item = this.item = new ViewItem(tabs.Ancestor);
                    item.setInstance(this);
                    item.viewElementRef(elementRef);
                    tabs.addTab(this);
                    this.navbarView = item.navbarView = function () {
                        var activeItem = _this.getActive();
                        return activeItem && activeItem.navbarView();
                    };
                    item.enableBack = function () {
                        // override ViewItem's enableBack(), should use the
                        // active child nav item's enableBack() instead
                        var activeItem = _this.getActive();
                        return activeItem && activeItem.enableBack();
                    };
                    this.panelId = "tab-panel-" + item.id;
                    this.labeledBy = "tab-button-" + item.id;
                };

                _inherits(_class, _ViewController);

                _createClass(_class, [{
                    key: "onInit",
                    value: function onInit() {
                        var _this2 = this;

                        if (this._initialResolve) {
                            this.tabs.select(this).then(function () {
                                _this2._initialResolve();
                                _this2._initialResolve = null;
                            });
                        }
                    }
                }, {
                    key: "load",
                    value: function load(callback) {
                        if (!this._loaded && this.root) {
                            var opts = {
                                animate: false,
                                navbar: false
                            };
                            this.push(this.root, null, opts).then(function () {
                                callback && callback();
                            });
                            this._loaded = true;
                        } else {
                            callback && callback();
                        }
                    }
                }, {
                    key: "queueInitial",
                    value: function queueInitial() {
                        var _this3 = this;

                        // this Tab will be used as the initial one for the first load of Tabs
                        return new Promise(function (res) {
                            _this3._initialResolve = res;
                        });
                    }
                }, {
                    key: "isSelected",
                    get: function get() {
                        return this.tabs.isActive(this.item);
                    }
                }, {
                    key: "isNotSelected",
                    get: function get() {
                        return !this.tabs.isActive(this.item);
                    }
                }]);

                return _class;
            })(ViewController);

            _export("Tab", Tab);

            _export("Tab", Tab = __decorate([Component({
                selector: "ion-tab",
                properties: ["root", "tabTitle", "tabIcon"],
                host: {
                    "[attr.id]": "panelId",
                    "[attr.aria-labelledby]": "labeledBy",
                    "[attr.aria-hidden]": "isNotSelected",
                    "[class.tab-selected]": "isSelected",
                    "role": "tabpanel"
                }
            }), View({
                template: "<template pane-anchor></template><ng-content></ng-content>",
                directives: [forwardRef(function () {
                    return TabPaneAnchor;
                })]
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [typeof Tabs !== "undefined" && Tabs || Object, typeof ElementRef !== "undefined" && ElementRef || Object, typeof Injector !== "undefined" && Injector || Object])], Tab));

            TabPaneAnchor = (function () {
                var _class2 = function TabPaneAnchor(tab, elementRef) {
                    _classCallCheck(this, _class2);

                    tab.anchorElementRef(elementRef);
                };

                return _class2;
            })();

            TabPaneAnchor = __decorate([Directive({
                selector: "template[pane-anchor]"
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [Tab, typeof ElementRef !== "undefined" && ElementRef || Object])], TabPaneAnchor);
        }
    };
});
System.register("ionic/components/tabs/tabs", ["angular2/angular2", "../view/view-controller", "../view/view-item", "../../config/annotations"], function (_export) {
    "use strict";

    var Directive, Injector, ElementRef, Optional, Ancestor, forwardRef, ViewController, ViewItem, IonicComponent, IonicView, __decorate, __metadata, __param, Tabs, TabButton;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Injector = _angular2Angular2.Injector;
            ElementRef = _angular2Angular2.ElementRef;
            Optional = _angular2Angular2.Optional;
            Ancestor = _angular2Angular2.Ancestor;
            forwardRef = _angular2Angular2.forwardRef;
        }, function (_viewViewController) {
            ViewController = _viewViewController.ViewController;
        }, function (_viewViewItem) {
            ViewItem = _viewViewItem.ViewItem;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
            IonicView = _configAnnotations.IonicView;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Tabs = (function (_ViewController) {
                var _class = function Tabs(AncestorViewCtrl, viewItem, injector, elementRef) {
                    var _this = this;

                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, AncestorViewCtrl, injector, elementRef);
                    // Tabs may also be an actual ViewItem which was navigated to
                    // if Tabs is static and not navigated to within a ViewController
                    // then skip this and don't treat it as it's own ViewItem
                    if (viewItem) {
                        this.item = viewItem;
                        // special overrides for the Tabs ViewItem
                        // the Tabs ViewItem does not have it's own navbar
                        // so find the navbar it should use within it's active Tab
                        viewItem.navbarView = function () {
                            var activeTab = _this.getActive();
                            if (activeTab && activeTab.instance) {
                                return activeTab.instance.navbarView();
                            }
                        };
                        // a Tabs ViewItem should not have a back button
                        // enableBack back button will later be determined
                        // by the active ViewItem that has a navbar
                        viewItem.enableBack = function () {
                            return false;
                        };
                    }
                };

                _inherits(_class, _ViewController);

                _createClass(_class, [{
                    key: "addTab",
                    value: function addTab(tab) {
                        // tab.item refers to the ViewItem of the individual Tab being added to Tabs (ViewController)
                        // this.item refers to the ViewItem instsance on Tabs
                        this.add(tab.item);
                        if (this.length() === 1) {
                            // this was the first tab added, queue this one to be loaded and selected
                            var promise = tab.queueInitial();
                            this.item && this.item.addPromise(promise);
                        }
                    }
                }, {
                    key: "select",
                    value: function select(tab) {
                        var _this2 = this;

                        var enteringItem = null;
                        if (typeof tab === "number") {
                            enteringItem = this.getByIndex(tab);
                        } else {
                            enteringItem = this.getByInstance(tab);
                        }
                        if (!enteringItem || !enteringItem.instance || this.isTransitioning()) {
                            return Promise.reject();
                        }
                        return new Promise(function (resolve) {
                            enteringItem.instance.load(function () {
                                var opts = {
                                    animate: false
                                };
                                var leavingItem = _this2.getActive() || new ViewItem();
                                leavingItem.shouldDestroy = false;
                                leavingItem.shouldCache = true;
                                _this2.transition(enteringItem, leavingItem, opts, function () {
                                    resolve();
                                });
                            });
                        });
                    }
                }, {
                    key: "tabs",
                    get: function get() {
                        return this.instances();
                    }
                }]);

                return _class;
            })(ViewController);

            _export("Tabs", Tabs);

            _export("Tabs", Tabs = __decorate([IonicComponent({
                selector: "ion-tabs",
                defaultProperties: {
                    "tabBarPlacement": "bottom",
                    "tabBarIcons": "top"
                }
            }), IonicView({
                template: "" + "<nav class=\"tab-bar-container\">" + "<div class=\"tab-bar\" role=\"tablist\">" + "<button *ng-for=\"#t of tabs\" [tab]=\"t\" class=\"tab-button\" role=\"tab\">" + "<icon [name]=\"t.tabIcon\" class=\"tab-button-icon\"></icon>" + "<span class=\"tab-button-text\">{{t.tabTitle}}</span>" + "</button>" + "</div>" + "</nav>" + "<section class=\"content-container\">" + "<ng-content></ng-content>" + "</section>",
                directives: [forwardRef(function () {
                    return TabButton;
                })]
            }), __param(0, Optional()), __param(1, Optional()), __metadata("design:paramtypes", [typeof ViewController !== "undefined" && ViewController || Object, typeof ViewItem !== "undefined" && ViewItem || Object, typeof Injector !== "undefined" && Injector || Object, typeof ElementRef !== "undefined" && ElementRef || Object])], Tabs));

            TabButton = (function () {
                var _class2 = function TabButton(tabs) {
                    _classCallCheck(this, _class2);

                    this.tabs = tabs;
                };

                _createClass(_class2, [{
                    key: "onInit",
                    value: function onInit() {
                        var id = this.tab.item.id;
                        this.btnId = "tab-button-" + id;
                        this.panelId = "tab-panel-" + id;
                        this.hasTitle = !!this.tab.tabTitle;
                        this.hasIcon = !!this.tab.tabIcon;
                        this.hasTitleOnly = this.hasTitle && !this.hasIcon;
                        this.hasIconOnly = this.hasIcon && !this.hasTitle;
                    }
                }, {
                    key: "onClick",
                    value: function onClick(ev) {
                        ev.stopPropagation();
                        ev.preventDefault();
                        this.tabs.select(this.tab);
                    }
                }]);

                return _class2;
            })();

            TabButton = __decorate([Directive({
                selector: "button.tab-button",
                properties: ["tab"],
                host: {
                    "[attr.id]": "btnId",
                    "[attr.aria-controls]": "panelId",
                    "[attr.aria-selected]": "tab.isSelected",
                    "[class.has-title]": "hasTitle",
                    "[class.has-icon]": "hasIcon",
                    "[class.has-title-only]": "hasTitleOnly",
                    "[class.icon-only]": "hasIconOnly",
                    "(^click)": "onClick($event)"
                }
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [Tabs])], TabButton);
        }
    };
});
System.register("ionic/components/toolbar/toolbar", ["angular2/angular2", "../ion", "../../config/config", "../../config/annotations"], function (_export) {
    "use strict";

    var Directive, View, Ancestor, ElementRef, forwardRef, Ion, IonicConfig, IonicComponent, __decorate, __metadata, __param, ToolbarBase, Toolbar, ToolbarTitle, ToolbarItem;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            View = _angular2Angular2.View;
            Ancestor = _angular2Angular2.Ancestor;
            ElementRef = _angular2Angular2.ElementRef;
            forwardRef = _angular2Angular2.forwardRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            ToolbarBase = (function (_Ion) {
                function ToolbarBase(elementRef, config) {
                    _classCallCheck(this, ToolbarBase);

                    _get(Object.getPrototypeOf(ToolbarBase.prototype), "constructor", this).call(this, elementRef, config);
                    this.titleAlign = config.setting("navTitleAlign");
                    this.itemEles = [];
                }

                _inherits(ToolbarBase, _Ion);

                _createClass(ToolbarBase, [{
                    key: "titleElement",
                    value: function titleElement(eleRef) {
                        if (arguments.length) {
                            this._nbTlEle = eleRef;
                        }
                        return this._nbTlEle;
                    }
                }, {
                    key: "itemElements",
                    value: function itemElements(eleRef) {
                        if (arguments.length) {
                            this.itemEles.push(eleRef);
                        }
                        return this.itemEles;
                    }
                }, {
                    key: "titleText",
                    value: function titleText(eleRef) {
                        if (arguments.length) {
                            this._ttTxt.push(eleRef);
                        }
                        return this._ttTxt;
                    }
                }, {
                    key: "alignTitle",
                    value: function alignTitle() {
                        // don't bother if we're not trying to center align the title
                        if (this.titleAlign !== "center" || this.aligned) return;
                        // called after the navbar/title has had a moment to
                        // finish rendering in their correct locations
                        var toolbarEle = this.getNativeElement();
                        var titleEle = toolbarEle.querySelector("ion-title");
                        // don't bother if there's no title element
                        if (!titleEle) return;
                        // get all the dimensions
                        var titleOffsetLeft = titleEle.offsetLeft;
                        var titleOffsetRight = toolbarEle.offsetWidth - (titleOffsetLeft + titleEle.offsetWidth);
                        var marginLeft = 0;
                        var marginRight = 0;
                        if (titleOffsetLeft < titleOffsetRight) {
                            marginLeft = titleOffsetRight - titleOffsetLeft + 5;
                        } else if (titleOffsetLeft > titleOffsetRight) {
                            marginRight = titleOffsetLeft - titleOffsetRight - 5;
                        }
                        if (marginLeft || marginRight) {
                            // only do an update if it has to
                            var innerTitleEle = toolbarEle.querySelector(".toolbar-inner-title");
                            innerTitleEle.style.margin = "0 " + marginRight + "px 0 " + marginLeft + "px";
                        }
                        this.aligned = true;
                    }
                }]);

                return ToolbarBase;
            })(Ion);

            _export("ToolbarBase", ToolbarBase);

            Toolbar = (function (_ToolbarBase) {
                var _class = function Toolbar(elementRef, ionicConfig) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                    this.itemEles = [];
                };

                _inherits(_class, _ToolbarBase);

                _createClass(_class, [{
                    key: "onIonInit",
                    value: function onIonInit() {
                        var _this = this;

                        // TODO: THIS IS HORRIBLE, FIX
                        setTimeout(function () {
                            _this.alignTitle();
                            setTimeout(function () {
                                _this.alignTitle();
                            }, 64);
                        }, 32);
                    }
                }]);

                return _class;
            })(ToolbarBase);

            _export("Toolbar", Toolbar);

            _export("Toolbar", Toolbar = __decorate([IonicComponent({
                selector: "ion-toolbar"
            }), View({
                template: "\n    <div class=\"toolbar-inner\">\n      <div class=\"toolbar-title\">\n        <div class=\"toolbar-inner-title\">\n          <ng-content select=\"ion-title\"></ng-content>\n        </div>\n      </div>\n      <div class=\"toolbar-item toolbar-primary-item\">\n        <ng-content select=\"[primary]\"></ng-content>\n      </div>\n      <div class=\"toolbar-item toolbar-secondary-item\">\n        <ng-content select=\"[secondary]\"></ng-content>\n      </div>\n    </div>\n  ",
                directives: [forwardRef(function () {
                    return ToolbarTitle;
                }), forwardRef(function () {
                    return ToolbarItem;
                })]
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], Toolbar));

            ToolbarTitle = (function () {
                var _class2 = function ToolbarTitle(toolbar, elementRef) {
                    _classCallCheck(this, _class2);

                    toolbar.titleElement(elementRef);
                };

                return _class2;
            })();

            ToolbarTitle = __decorate([Directive({
                selector: ".toolbar-title"
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [Toolbar, typeof ElementRef !== "undefined" && ElementRef || Object])], ToolbarTitle);

            ToolbarItem = (function () {
                var _class3 = function ToolbarItem(toolbar, elementRef) {
                    _classCallCheck(this, _class3);

                    toolbar.itemElements(elementRef);
                };

                return _class3;
            })();

            ToolbarItem = __decorate([Directive({
                selector: ".toolbar-item"
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [Toolbar, typeof ElementRef !== "undefined" && ElementRef || Object])], ToolbarItem);
        }
    };
});
System.register('ionic/components/view/view-controller', ['angular2/angular2', 'angular2/src/core/compiler/dynamic_component_loader', 'angular2/src/core/compiler/view_manager', '../ion', '../../config/config', '../app/app', '../../routing/router', './view-item', '../nav/nav-controller', '../nav/pane', '../../transitions/transition', '../../util/click-block', 'ionic/util'], function (_export) {
    'use strict';

    var Compiler, Injector, bind, DynamicComponentLoader, AppViewManager, Ion, IonicConfig, IonicApp, IonicRouter, ViewItem, NavController, PaneController, Transition, ClickBlock, util, ViewController, ACTIVE_STATE, CACHED_STATE, STAGED_ENTERING_STATE, STAGED_LEAVING_STATE, ctrlIds;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x7, _x8, _x9) { var _again = true; _function: while (_again) { var object = _x7, property = _x8, receiver = _x9; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x7 = parent; _x8 = property; _x9 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Compiler = _angular2Angular2.Compiler;
            Injector = _angular2Angular2.Injector;
            bind = _angular2Angular2.bind;
        }, function (_angular2SrcCoreCompilerDynamic_component_loader) {
            DynamicComponentLoader = _angular2SrcCoreCompilerDynamic_component_loader.DynamicComponentLoader;
        }, function (_angular2SrcCoreCompilerView_manager) {
            AppViewManager = _angular2SrcCoreCompilerView_manager.AppViewManager;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_routingRouter) {
            IonicRouter = _routingRouter.IonicRouter;
        }, function (_viewItem) {
            ViewItem = _viewItem.ViewItem;
        }, function (_navNavController) {
            NavController = _navNavController.NavController;
        }, function (_navPane) {
            PaneController = _navPane.PaneController;
        }, function (_transitionsTransition) {
            Transition = _transitionsTransition.Transition;
        }, function (_utilClickBlock) {
            ClickBlock = _utilClickBlock.ClickBlock;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            ViewController = (function (_Ion) {
                function ViewController(parentViewCtrl, injector, elementRef) {
                    _classCallCheck(this, ViewController);

                    var config = injector.get(IonicConfig);
                    _get(Object.getPrototypeOf(ViewController.prototype), 'constructor', this).call(this, elementRef, config);
                    this.parent = parentViewCtrl;
                    this.compiler = injector.get(Compiler);
                    this.loader = injector.get(DynamicComponentLoader);
                    this.viewMngr = injector.get(AppViewManager);
                    this.router = injector.get(IonicRouter);
                    this.app = injector.get(IonicApp);
                    this.config = config;
                    this.router.addViewController(this);
                    this.items = [];
                    this.panes = new PaneController(this);
                    this.sbTransition = null;
                    this.sbActive = false;
                    this.sbEnabled = true;
                    this.id = ++ctrlIds;
                    this._ids = -1;
                    // build a new injector for child ViewItems to use
                    this.bindings = Injector.resolve([bind(ViewController).toValue(this), bind(NavController).toValue(new NavController(this))]);
                }

                _inherits(ViewController, _Ion);

                _createClass(ViewController, [{
                    key: 'push',
                    value: function push(component) {
                        var params = arguments[1] === undefined ? {} : arguments[1];
                        var opts = arguments[2] === undefined ? {} : arguments[2];

                        if (!component || this.isTransitioning()) {
                            return Promise.reject();
                        }
                        var resolve = undefined;
                        var promise = new Promise(function (res) {
                            resolve = res;
                        });
                        // do not animate if this is the first in the stack
                        if (!this.items.length) {
                            opts.animation = 'none';
                        }
                        // default the direction to "forward"
                        opts.direction = opts.direction || 'forward';
                        // the active item is going to be the leaving one (if one exists)
                        var leavingItem = this.getActive() || new ViewItem();
                        leavingItem.shouldCache = util.isBoolean(opts.cacheLeavingItem) ? opts.cacheLeavingItem : true;
                        leavingItem.shouldDestroy = !leavingItem.shouldCache;
                        if (leavingItem.shouldDestroy) {
                            leavingItem.willUnload();
                        }
                        // create a new ViewItem
                        var enteringItem = new ViewItem(this, component, params);
                        // add the item to the stack
                        this.add(enteringItem);
                        // notify app of the state change
                        this.app.stateChange('push', enteringItem);
                        // start the transition
                        this.transition(enteringItem, leavingItem, opts, function () {
                            resolve();
                        });
                        return promise;
                    }
                }, {
                    key: 'pop',
                    value: function pop() {
                        var opts = arguments[0] === undefined ? {} : arguments[0];

                        if (this.isTransitioning() || this.items.length < 2) {
                            return Promise.reject();
                        }
                        var resolve = undefined;
                        var promise = new Promise(function (res) {
                            resolve = res;
                        });
                        // default the direction to "back"
                        opts.direction = opts.direction || 'back';
                        // get the active item and set that it is staged to be leaving
                        // was probably the one popped from the stack
                        var leavingItem = this.getActive() || new ViewItem();
                        leavingItem.shouldCache = util.isBoolean(opts.cacheLeavingItem) ? opts.cacheLeavingItem : false;
                        leavingItem.shouldDestroy = !leavingItem.shouldCache;
                        if (leavingItem.shouldDestroy) {
                            leavingItem.willUnload();
                        }
                        // the entering item is now the new last item
                        // Note: we might not have an entering item if this is the
                        // only item on the history stack.
                        var enteringItem = this.getPrevious(leavingItem);
                        if (enteringItem) {
                            // notify app of the state change
                            this.app.stateChange('pop', enteringItem);
                            // start the transition
                            this.transition(enteringItem, leavingItem, opts, function () {
                                // transition completed, destroy the leaving item
                                resolve();
                            });
                        } else {
                            this.transitionComplete();
                            resolve();
                        }
                        return promise;
                    }
                }, {
                    key: 'setItems',

                    /**
                     * Set the item stack to reflect the given component classes.
                     */
                    value: function setItems(components) {
                        var opts = arguments[1] === undefined ? {} : arguments[1];

                        if (!components || !components.length) {
                            return Promise.resolve();
                        }
                        this.app.stateClear();
                        // if animate has not been set then default to false
                        opts.animate = opts.animate || false;
                        // ensure leaving items are not cached, and should be destroyed
                        opts.cacheLeavingItem = false;
                        // get the items to auto remove without having to do a transiton for each
                        // the last item (the currently active one) will do a normal transition out
                        if (this.items.length > 1) {
                            var autoRemoveItems = this.items.slice(0, this.items.length - 1);
                            for (var i = 0; i < autoRemoveItems.length; i++) {
                                autoRemoveItems[i].shouldDestroy = true;
                                autoRemoveItems[i].shouldCache = false;
                                autoRemoveItems[i].willUnload();
                            }
                        }
                        var component = null;
                        var viewItem = null;
                        // create the ViewItems that go before the new active ViewItem in the stack
                        // but the previous views won't should render yet
                        if (components.length > 1) {
                            var newBeforeItems = components.slice(0, components.length - 1);
                            for (var j = 0; j < newBeforeItems.length; j++) {
                                component = newBeforeItems[j];
                                if (component) {
                                    viewItem = new ViewItem(this, component.component || component, component.params);
                                    viewItem.state = CACHED_STATE;
                                    viewItem.shouldDestroy = false;
                                    viewItem.shouldCache = false;
                                    // add the item to the stack
                                    this.add(viewItem);
                                }
                            }
                        }
                        // get the component that will become the active item
                        // it'll be the last one in the given components array
                        component = components[components.length - 1];
                        // transition the leaving and entering
                        return this.push(component && component.component || component, component && component.params, opts);
                    }
                }, {
                    key: 'setRoot',
                    value: function setRoot(component) {
                        var params = arguments[1] === undefined ? {} : arguments[1];
                        var opts = arguments[2] === undefined ? {} : arguments[2];

                        return this.setItems([{
                            component: component,
                            params: params
                        }], opts);
                    }
                }, {
                    key: 'transition',
                    value: function transition(enteringItem, leavingItem, opts, callback) {
                        var _this = this;

                        if (!enteringItem || enteringItem === leavingItem) {
                            return callback();
                        }
                        if (opts.animate === false) {
                            opts.animation = 'none';
                        } else if (!opts.animation) {
                            opts.animation = this.config.setting('viewTransition');
                        }
                        opts.animate = opts.animation !== 'none';
                        // wait for the new item to complete setup
                        enteringItem.stage(function () {
                            enteringItem.shouldDestroy = false;
                            enteringItem.shouldCache = false;
                            enteringItem.willEnter();
                            leavingItem.willLeave();
                            // set that the new item pushed on the stack is staged to be entering/leaving
                            // staged state is important for the transition to find the correct item
                            enteringItem.state = STAGED_ENTERING_STATE;
                            leavingItem.state = STAGED_LEAVING_STATE;
                            // init the transition animation
                            var transAnimation = Transition.create(_this, opts);
                            if (!opts.animate) {
                                // force it to not animate the elements, just apply the "to" styles
                                transAnimation.duration(0);
                            }
                            var duration = transAnimation.duration();
                            if (duration > 64) {
                                // block any clicks during the transition and provide a
                                // fallback to remove the clickblock if something goes wrong
                                ClickBlock(true, duration + 200);
                            }
                            // start the transition
                            transAnimation.play().then(function () {
                                // transition has completed, update each item's state
                                enteringItem.state = ACTIVE_STATE;
                                leavingItem.state = CACHED_STATE;
                                // dispose any items that shouldn't stay around
                                transAnimation.dispose();
                                enteringItem.didEnter();
                                leavingItem.didLeave();
                                // all done!
                                _this.transitionComplete();
                                callback();
                            });
                        });
                    }
                }, {
                    key: 'swipeBackStart',
                    value: function swipeBackStart() {
                        var _this2 = this;

                        if (this.isTransitioning() || this.items.length < 2) {
                            return;
                        }
                        this.sbActive = true;
                        this.sbResolve = null;
                        // default the direction to "back"
                        var opts = {
                            direction: 'back'
                        };
                        // get the active item and set that it is staged to be leaving
                        // was probably the one popped from the stack
                        var leavingItem = this.getActive() || new ViewItem();
                        leavingItem.shouldDestroy = true;
                        leavingItem.shouldCache = false;
                        leavingItem.willLeave();
                        leavingItem.willUnload();
                        // the entering item is now the new last item
                        var enteringItem = this.getPrevious(leavingItem);
                        enteringItem.shouldDestroy = false;
                        enteringItem.shouldCache = false;
                        enteringItem.willEnter();
                        // wait for the new item to complete setup
                        enteringItem.stage(function () {
                            // set that the new item pushed on the stack is staged to be entering/leaving
                            // staged state is important for the transition to find the correct item
                            enteringItem.state = STAGED_ENTERING_STATE;
                            leavingItem.state = STAGED_LEAVING_STATE;
                            // init the transition animation
                            _this2.sbTransition = Transition.create(_this2, opts);
                            _this2.sbTransition.easing('linear');
                            _this2.sbTransition.stage();
                            var swipeBackPromise = new Promise(function (res) {
                                _this2.sbResolve = res;
                            });
                            swipeBackPromise.then(function (completeSwipeBack) {
                                if (completeSwipeBack) {
                                    // swipe back has completed, update each item's state
                                    enteringItem.state = ACTIVE_STATE;
                                    leavingItem.state = CACHED_STATE;
                                    enteringItem.didEnter();
                                    leavingItem.didLeave();
                                    // notify app of the state change
                                    _this2.app.stateChange('pop', enteringItem);
                                } else {
                                    // cancelled the swipe back, return items to original state
                                    leavingItem.state = ACTIVE_STATE;
                                    enteringItem.state = CACHED_STATE;
                                    leavingItem.willEnter();
                                    leavingItem.didEnter();
                                    enteringItem.didLeave();
                                    leavingItem.shouldDestroy = false;
                                    enteringItem.shouldDestroy = false;
                                }
                                // all done!
                                _this2.transitionComplete();
                            });
                        });
                    }
                }, {
                    key: 'swipeBackProgress',
                    value: function swipeBackProgress(progress) {
                        if (this.sbTransition) {
                            ClickBlock(true, 4000);
                            this.sbTransition.progress(Math.min(1, Math.max(0, progress)));
                        }
                    }
                }, {
                    key: 'swipeBackEnd',
                    value: function swipeBackEnd(completeSwipeBack, progress, playbackRate) {
                        var _this3 = this;

                        // to reverse the animation use a negative playbackRate
                        if (this.sbTransition && this.sbActive) {
                            this.sbActive = false;
                            if (progress <= 0) {
                                this.swipeBackProgress(0.0001);
                            } else if (progress >= 1) {
                                this.swipeBackProgress(0.9999);
                            }
                            if (!completeSwipeBack) {
                                playbackRate = playbackRate * -1;
                            }
                            this.sbTransition.playbackRate(playbackRate);
                            this.sbTransition.play().then(function () {
                                _this3.sbResolve && _this3.sbResolve(completeSwipeBack);
                                _this3.sbTransition && _this3.sbTransition.dispose();
                                _this3.sbResolve = _this3.sbTransition = null;
                            });
                        }
                    }
                }, {
                    key: 'isSwipeBackEnabled',
                    value: function isSwipeBackEnabled(val) {
                        if (arguments.length) {
                            this.sbEnabled = !!val;
                        }
                        return this.sbEnabled;
                    }
                }, {
                    key: 'canSwipeBack',
                    value: function canSwipeBack() {
                        if (this.sbEnabled) {
                            var activeItem = this.getActive();
                            if (activeItem) {
                                return activeItem.enableBack();
                            }
                        }
                        return false;
                    }
                }, {
                    key: 'transitionComplete',
                    value: function transitionComplete() {
                        var _this4 = this;

                        var destroys = [];
                        this.items.forEach(function (item) {
                            if (item) {
                                if (item.shouldDestroy) {
                                    destroys.push(item);
                                } else if (item.state === CACHED_STATE && item.shouldCache) {
                                    item.shouldCache = false;
                                }
                            }
                        });
                        destroys.forEach(function (item) {
                            _this4.remove(item);
                            item.destroy();
                        });
                        // allow clicks again
                        ClickBlock(false);
                    }
                }, {
                    key: 'isTransitioning',
                    value: function isTransitioning() {
                        var state = undefined;
                        for (var i = 0, ii = this.items.length; i < ii; i++) {
                            state = this.items[i].state;
                            if (state === STAGED_ENTERING_STATE || state === STAGED_LEAVING_STATE) {
                                return true;
                            }
                        }
                        return false;
                    }
                }, {
                    key: 'getActive',
                    value: function getActive() {
                        for (var i = 0, ii = this.items.length; i < ii; i++) {
                            if (this.items[i].state === ACTIVE_STATE) {
                                return this.items[i];
                            }
                        }
                        return null;
                    }
                }, {
                    key: 'getByInstance',
                    value: function getByInstance(instance) {
                        if (instance) {
                            for (var i = 0, ii = this.items.length; i < ii; i++) {
                                if (this.items[i].instance === instance) {
                                    return this.items[i];
                                }
                            }
                        }
                        return null;
                    }
                }, {
                    key: 'getByIndex',
                    value: function getByIndex(index) {
                        if (index < this.items.length && index > -1) {
                            return this.items[index];
                        }
                        return null;
                    }
                }, {
                    key: 'getPrevious',
                    value: function getPrevious(item) {
                        if (item) {
                            return this.items[this.items.indexOf(item) - 1];
                        }
                        return null;
                    }
                }, {
                    key: 'getStagedEnteringItem',
                    value: function getStagedEnteringItem() {
                        for (var i = 0, ii = this.items.length; i < ii; i++) {
                            if (this.items[i].state === STAGED_ENTERING_STATE) {
                                return this.items[i];
                            }
                        }
                        return null;
                    }
                }, {
                    key: 'getStagedLeavingItem',
                    value: function getStagedLeavingItem() {
                        for (var i = 0, ii = this.items.length; i < ii; i++) {
                            if (this.items[i].state === STAGED_LEAVING_STATE) {
                                return this.items[i];
                            }
                        }
                        return null;
                    }
                }, {
                    key: 'navbarViewContainer',
                    value: function navbarViewContainer(nbContainer) {
                        if (nbContainer) {
                            this._nbContainer = nbContainer;
                        }
                        if (this._nbContainer) {
                            return this._nbContainer;
                        }
                        if (this.parent) {
                            return this.parent.navbarViewContainer();
                        }
                    }
                }, {
                    key: 'anchorElementRef',
                    value: function anchorElementRef() {
                        if (arguments.length) {
                            this._anchorER = arguments[0];
                        }
                        return this._anchorER;
                    }
                }, {
                    key: 'anchorViewContainerRef',
                    value: function anchorViewContainerRef() {
                        if (arguments.length) {
                            this._anchorVC = arguments[0];
                        }
                        return this._anchorVC;
                    }
                }, {
                    key: 'childNavbar',
                    value: function childNavbar() {
                        if (arguments.length) {
                            this._childNavbar = arguments[0];
                        }
                        return this._childNavbar;
                    }
                }, {
                    key: 'add',
                    value: function add(item) {
                        item.id = this.id + '-' + ++this._ids;
                        this.items.push(item);
                    }
                }, {
                    key: 'remove',
                    value: function remove(itemOrIndex) {
                        util.array.remove(this.items, itemOrIndex);
                    }
                }, {
                    key: 'indexOf',
                    value: function indexOf(item) {
                        return this.items.indexOf(item);
                    }
                }, {
                    key: 'length',
                    value: function length() {
                        return this.items.length;
                    }
                }, {
                    key: 'instances',
                    value: function instances() {
                        var instances = [];
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = this.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var item = _step.value;

                                if (item.instance) {
                                    instances.push(item.instance);
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator['return']) {
                                    _iterator['return']();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        return instances;
                    }
                }, {
                    key: 'isActive',
                    value: function isActive(item) {
                        return item && item.state === ACTIVE_STATE;
                    }
                }, {
                    key: 'isStagedEntering',
                    value: function isStagedEntering(item) {
                        return item && item.state === STAGED_ENTERING_STATE;
                    }
                }]);

                return ViewController;
            })(Ion);

            _export('ViewController', ViewController);

            ACTIVE_STATE = 1;
            CACHED_STATE = 2;
            STAGED_ENTERING_STATE = 3;
            STAGED_LEAVING_STATE = 4;
            ctrlIds = -1;
        }
    };
});
System.register('ionic/components/view/view-item', ['angular2/angular2', 'angular2/src/core/compiler/element_injector', '../nav/nav-controller'], function (_export) {
    'use strict';

    var Component, bind, Injector, ComponentRef, DirectiveBinding, NavParams, ViewItem;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function isComponent(elementBinder, id) {
        return elementBinder && elementBinder.componentDirective && elementBinder.componentDirective.metadata.id == id;
    }
    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            bind = _angular2Angular2.bind;
            Injector = _angular2Angular2.Injector;
            ComponentRef = _angular2Angular2.ComponentRef;
        }, function (_angular2SrcCoreCompilerElement_injector) {
            DirectiveBinding = _angular2SrcCoreCompilerElement_injector.DirectiveBinding;
        }, function (_navNavController) {
            NavParams = _navNavController.NavParams;
        }],
        execute: function () {
            ViewItem = (function () {
                function ViewItem(viewCtrl, componentType) {
                    var params = arguments[2] === undefined ? {} : arguments[2];

                    _classCallCheck(this, ViewItem);

                    this.viewCtrl = viewCtrl;
                    this.componentType = componentType;
                    this.params = new NavParams(params);
                    this.instance = null;
                    this.state = 0;
                    this.disposals = [];
                    this.protos = {};
                    this._nbItms = [];
                    this._promises = [];
                    this.templateRefs = {};
                }

                _createClass(ViewItem, [{
                    key: 'addProtoViewRef',
                    value: function addProtoViewRef(name, protoViewRef) {
                        this.protos[name] = protoViewRef;
                    }
                }, {
                    key: 'addTemplateRef',
                    value: function addTemplateRef(name, templateRef) {
                        this.templateRefs[name] = templateRef;
                    }
                }, {
                    key: 'stage',
                    value: function stage(callback) {
                        var _this = this;

                        var viewCtrl = this.viewCtrl;
                        if (this.instance || !viewCtrl) {
                            // already compiled this view
                            return callback();
                        }
                        var annotation = new Component({
                            selector: 'ion-view',
                            host: {
                                'class': 'nav-item'
                            }
                        });
                        var ionViewComponentType = DirectiveBinding.createFromType(this.componentType, annotation);
                        // create a unique token that works as a cache key
                        ionViewComponentType.token = 'ionView' + this.componentType.name;
                        // compile the Component
                        viewCtrl.compiler.compileInHost(ionViewComponentType).then(function (hostProtoViewRef) {
                            // figure out the sturcture of this Component
                            // does it have a navbar? Is it tabs? Should it not have a navbar or any toolbars?
                            var itemStructure = _this.sturcture = _this.inspectStructure(hostProtoViewRef);
                            // get the appropriate Pane which this ViewItem will fit into
                            viewCtrl.panes.get(itemStructure, function (pane) {
                                _this.pane = pane;
                                var bindings = viewCtrl.bindings.concat(Injector.resolve([bind(NavParams).toValue(_this.params), bind(ViewItem).toValue(_this)]));
                                // add the content of the view to the content area
                                // it will already have the correct context
                                var contentContainer = pane.contentContainerRef;
                                // the same guts as DynamicComponentLoader.loadNextToLocation
                                var hostViewRef = contentContainer.createHostView(hostProtoViewRef, -1, bindings);
                                var newLocation = viewCtrl.viewMngr.getHostElement(hostViewRef);
                                var newComponent = viewCtrl.viewMngr.getComponent(newLocation);
                                var dispose = function dispose() {
                                    var index = contentContainer.indexOf(hostViewRef);
                                    if (index !== -1) {
                                        contentContainer.remove(index);
                                    }
                                };
                                _this.disposals.push(dispose);
                                var viewComponetRef = new ComponentRef(newLocation, newComponent, dispose);
                                // get the component's instance, and set it to the this ViewItem
                                _this.setInstance(viewComponetRef.instance);
                                _this.viewElementRef(viewComponetRef.location);
                                // // get the item container's nav bar
                                var navbarViewContainer = viewCtrl.navbarViewContainer();
                                // // get the item's navbar protoview
                                var navbarTemplateRef = _this.templateRefs.navbar;
                                // add a navbar view if the pane has a navbar container, and the
                                // item's instance has a navbar protoview to go to inside of it
                                if (navbarViewContainer && navbarTemplateRef) {
                                    (function () {
                                        var navbarView = navbarViewContainer.createEmbeddedView(navbarTemplateRef, -1);
                                        _this.disposals.push(function () {
                                            navbarViewContainer.remove(navbarViewContainer.indexOf(navbarView));
                                        });
                                    })();
                                }
                                // this item has finished loading
                                try {
                                    _this.loaded();
                                } catch (e) {
                                    console.error(e);
                                }
                                // fire callback when all child promises have been resolved
                                Promise.all(_this._promises).then(function () {
                                    callback();
                                    _this._promises = [];
                                });
                            }, function (panesErr) {
                                console.error(panesErr);
                            });
                        }, function (compileInHostErr) {
                            console.error(compileInHostErr);
                        });
                    }
                }, {
                    key: 'addPromise',
                    value: function addPromise(childPromise) {
                        this._promises.push(childPromise);
                    }
                }, {
                    key: 'inspectStructure',
                    value: function inspectStructure(componentProtoViewRef) {
                        var navbar = false;
                        var key = '_';
                        componentProtoViewRef._protoView.elementBinders.forEach(function (rootElementBinder) {
                            if (!rootElementBinder.componentDirective || !rootElementBinder.nestedProtoView) return;
                            rootElementBinder.nestedProtoView.elementBinders.forEach(function (nestedElementBinder) {
                                if (isComponent(nestedElementBinder, 'Tabs')) {
                                    navbar = true;
                                }
                                if (!nestedElementBinder.componentDirective && nestedElementBinder.nestedProtoView) {
                                    nestedElementBinder.nestedProtoView.elementBinders.forEach(function (templatedElementBinder) {
                                        if (isComponent(templatedElementBinder, 'Navbar')) {
                                            navbar = true;
                                        }
                                    });
                                }
                            });
                        });
                        if (this.viewCtrl.childNavbar()) {
                            navbar = false;
                        }
                        if (navbar) key += 'n';
                        return {
                            navbar: navbar,
                            key: key
                        };
                    }
                }, {
                    key: 'enableBack',
                    value: function enableBack() {
                        // update if it's possible to go back from this nav item
                        if (this.viewCtrl) {
                            var previousItem = this.viewCtrl.getPrevious(this);
                            // the previous view may exist, but if it's about to be destroyed
                            // it shouldn't be able to go back to
                            return !!(previousItem && !previousItem.shouldDestroy);
                        }
                        return false;
                    }
                }, {
                    key: 'setInstance',
                    value: function setInstance(instance) {
                        this.instance = instance;
                        this.instance._viewItem = this;
                    }
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        for (var i = 0; i < this.disposals.length; i++) {
                            this.disposals[i]();
                        }
                        this.didUnload();
                        // just to help prevent any possible memory leaks
                        for (var _name in this) {
                            if (this.hasOwnProperty(_name)) {
                                this[_name] = null;
                            }
                        }
                    }
                }, {
                    key: 'viewElementRef',
                    value: function viewElementRef(val) {
                        if (arguments.length) {
                            this._vwEle = val;
                        }
                        return this._vwEle;
                    }
                }, {
                    key: 'navbarView',
                    value: function navbarView() {
                        if (arguments.length) {
                            this._nbView = arguments[0];
                        }
                        return this._nbView;
                    }
                }, {
                    key: 'navbarElement',
                    value: function navbarElement() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.getElementRef();
                        }
                    }
                }, {
                    key: 'titleElement',
                    value: function titleElement() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.titleElement();
                        }
                    }
                }, {
                    key: 'backButtonElement',
                    value: function backButtonElement() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.backButtonElement();
                        }
                    }
                }, {
                    key: 'backButtonTextElement',
                    value: function backButtonTextElement() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.backButtonTextElement();
                        }
                    }
                }, {
                    key: 'navbarItemElements',
                    value: function navbarItemElements() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.itemElements();
                        }
                    }
                }, {
                    key: 'postRender',
                    value: function postRender() {
                        // the elements are in the DOM and the browser
                        // has rendered them in their correct locations
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            navbarView.alignTitle();
                        }
                    }
                }, {
                    key: 'loaded',

                    /*
                      The view has loaded. This event only happens once per view being
                      created. If a view leaves but is cached, then this will not
                      fire again on a subsequent viewing. This method is a good place
                      to put your setup code for the view; however, it is not the
                      recommended method to use when a view becomes active.
                    */
                    value: function loaded() {
                        this.instance && this.instance.viewLoaded && this.instance.viewLoaded();
                    }
                }, {
                    key: 'willEnter',

                    /*
                      The view is about to enter and become the active view.
                    */
                    value: function willEnter() {
                        this.instance && this.instance.viewWillEnter && this.instance.viewWillEnter();
                    }
                }, {
                    key: 'didEnter',

                    /*
                      The view has fully entered and is now the active view. This
                      will fire, whether it was the first load or loaded from the cache.
                    */
                    value: function didEnter() {
                        if (this.pane) {
                            this.pane.showPane = true;
                        }
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            navbarView.didEnter();
                        }
                        this.instance && this.instance.viewDidEnter && this.instance.viewDidEnter();
                    }
                }, {
                    key: 'willLeave',

                    /*
                      The view has is about to leave and no longer be the active view.
                    */
                    value: function willLeave() {
                        this.instance && this.instance.viewWillLeave && this.instance.viewWillLeave();
                    }
                }, {
                    key: 'didLeave',

                    /*
                      The view has finished leaving and is no longer the active view. This
                      will fire, whether it is cached or unloaded.
                    */
                    value: function didLeave() {
                        this.instance && this.instance.viewDidLeave && this.instance.viewDidLeave();
                    }
                }, {
                    key: 'willUnload',

                    /*
                      The view is about to be destroyed and have its elements removed.
                    */
                    value: function willUnload() {
                        this.instance && this.instance.viewWillUnload && this.instance.viewWillUnload();
                    }
                }, {
                    key: 'didUnload',

                    /*
                      The view has been destroyed and its elements have been removed.
                    */
                    value: function didUnload() {
                        this.instance && this.instance.viewDidUnload && this.instance.viewDidUnload();
                    }
                }, {
                    key: 'index',
                    get: function get() {
                        return this.viewCtrl ? this.viewCtrl.indexOf(this) : -1;
                    }
                }]);

                return ViewItem;
            })();

            _export('ViewItem', ViewItem);
        }
    };
});
System.register('ionic/components/aside/extensions/gestures', ['ionic/gestures/slide-edge-gesture'], function (_export) {
    'use strict';

    var SlideEdgeGesture, AsideTargetGesture, AsideGesture, LeftAsideGesture, RightAsideGesture, TopAsideGesture, BottomAsideGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_ionicGesturesSlideEdgeGesture) {
            SlideEdgeGesture = _ionicGesturesSlideEdgeGesture.SlideEdgeGesture;
        }],
        execute: function () {
            AsideTargetGesture = (function (_SlideEdgeGesture) {
                function AsideTargetGesture(aside) {
                    _classCallCheck(this, AsideTargetGesture);

                    var asideElement = aside.getNativeElement();
                    _get(Object.getPrototypeOf(AsideTargetGesture.prototype), 'constructor', this).call(this, asideElement, {
                        direction: aside.side === 'left' || aside.side === 'right' ? 'x' : 'y',
                        edge: aside.side,
                        threshold: 0
                    });
                    this.aside = aside;
                }

                _inherits(AsideTargetGesture, _SlideEdgeGesture);

                _createClass(AsideTargetGesture, [{
                    key: 'canStart',
                    value: function canStart(ev) {
                        return this.aside.isOpen;
                    }
                }, {
                    key: 'onSlideBeforeStart',

                    // Set CSS, then wait one frame for it to apply before sliding starts
                    value: function onSlideBeforeStart(slide, ev) {
                        this.aside.setSliding(true);
                        this.aside.setChanging(true);
                        return new Promise(function (resolve) {
                            requestAnimationFrame(resolve);
                        });
                    }
                }, {
                    key: 'onSlide',
                    value: function onSlide(slide, ev) {
                        this.aside.setOpenAmt(slide.distance / slide.max);
                        this.aside.setTransform('translate3d(' + slide.distance + 'px,0,0)');
                    }
                }, {
                    key: 'onSlideEnd',
                    value: function onSlideEnd(slide, ev) {
                        this.aside.setTransform('');
                        this.aside.setSliding(false);
                        if (Math.abs(ev.gesture.velocityX) > 0.2 || Math.abs(slide.delta) > Math.abs(slide.max) * 0.5) {
                            this.aside.setOpen(!this.aside.isOpen);
                        }
                    }
                }, {
                    key: 'getElementStartPos',
                    value: function getElementStartPos(slide, ev) {
                        return this.aside.isOpen ? slide.max : slide.min;
                    }
                }, {
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries() {
                        return {
                            min: 0,
                            max: this.aside.width()
                        };
                    }
                }]);

                return AsideTargetGesture;
            })(SlideEdgeGesture);

            AsideGesture = (function (_SlideEdgeGesture2) {
                function AsideGesture(aside) {
                    _classCallCheck(this, AsideGesture);

                    // TODO figure out the sliding element, dont just use the parent
                    var contentElement = aside.getContentElement();
                    _get(Object.getPrototypeOf(AsideGesture.prototype), 'constructor', this).call(this, contentElement, {
                        direction: aside.side === 'left' || aside.side === 'right' ? 'x' : 'y',
                        edge: aside.side,
                        threshold: 75
                    });
                    this.aside = aside;
                    this.slideElement = contentElement;
                    this.listen();
                    var contentGesture = new AsideTargetGesture(aside);
                    contentGesture.listen();
                }

                _inherits(AsideGesture, _SlideEdgeGesture2);

                _createClass(AsideGesture, [{
                    key: 'canStart',
                    value: function canStart(ev) {
                        // Only restrict edges if the aside is closed
                        return this.aside.isOpen ? true : _get(Object.getPrototypeOf(AsideGesture.prototype), 'canStart', this).call(this, ev);
                    }
                }, {
                    key: 'onSlideBeforeStart',

                    // Set CSS, then wait one frame for it to apply before sliding starts
                    value: function onSlideBeforeStart(slide, ev) {
                        this.aside.setSliding(true);
                        this.aside.setChanging(true);
                        return new Promise(function (resolve) {
                            requestAnimationFrame(resolve);
                        });
                    }
                }, {
                    key: 'onSlide',
                    value: function onSlide(slide, ev) {
                        this.aside.setOpenAmt(slide.distance / slide.max);
                        this.aside.setTransform('translate3d(' + slide.distance + 'px,0,0)');
                    }
                }, {
                    key: 'onSlideEnd',
                    value: function onSlideEnd(slide, ev) {
                        this.aside.setTransform('');
                        this.aside.setSliding(false);
                        if (Math.abs(ev.gesture.velocityX) > 0.2 || Math.abs(slide.delta) > Math.abs(slide.max) * 0.5) {
                            this.aside.setOpen(!this.aside.isOpen);
                        }
                    }
                }, {
                    key: 'getElementStartPos',
                    value: function getElementStartPos(slide, ev) {
                        return this.aside.isOpen ? slide.max : slide.min;
                    }
                }, {
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries() {
                        return {
                            min: 0,
                            max: this.aside.width()
                        };
                    }
                }]);

                return AsideGesture;
            })(SlideEdgeGesture);

            LeftAsideGesture = (function (_AsideGesture) {
                function LeftAsideGesture() {
                    _classCallCheck(this, LeftAsideGesture);

                    _get(Object.getPrototypeOf(LeftAsideGesture.prototype), 'constructor', this).apply(this, arguments);
                }

                _inherits(LeftAsideGesture, _AsideGesture);

                return LeftAsideGesture;
            })(AsideGesture);

            _export('LeftAsideGesture', LeftAsideGesture);

            RightAsideGesture = (function (_LeftAsideGesture) {
                function RightAsideGesture() {
                    _classCallCheck(this, RightAsideGesture);

                    _get(Object.getPrototypeOf(RightAsideGesture.prototype), 'constructor', this).apply(this, arguments);
                }

                _inherits(RightAsideGesture, _LeftAsideGesture);

                _createClass(RightAsideGesture, [{
                    key: 'getElementStartPos',
                    value: function getElementStartPos(slide, ev) {
                        return this.aside.isOpen ? slide.min : slide.max;
                    }
                }, {
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries() {
                        return {
                            min: -this.aside.width(),
                            max: 0
                        };
                    }
                }]);

                return RightAsideGesture;
            })(LeftAsideGesture);

            _export('RightAsideGesture', RightAsideGesture);

            TopAsideGesture = (function (_AsideGesture2) {
                function TopAsideGesture() {
                    _classCallCheck(this, TopAsideGesture);

                    _get(Object.getPrototypeOf(TopAsideGesture.prototype), 'constructor', this).apply(this, arguments);
                }

                _inherits(TopAsideGesture, _AsideGesture2);

                _createClass(TopAsideGesture, [{
                    key: 'onSlide',
                    value: function onSlide(slide, ev) {
                        this.aside.setTransform('translate3d(0,' + slide.distance + 'px,0)');
                    }
                }, {
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries() {
                        return {
                            min: 0,
                            max: this.aside.height()
                        };
                    }
                }]);

                return TopAsideGesture;
            })(AsideGesture);

            _export('TopAsideGesture', TopAsideGesture);

            BottomAsideGesture = (function (_TopAsideGesture) {
                function BottomAsideGesture() {
                    _classCallCheck(this, BottomAsideGesture);

                    _get(Object.getPrototypeOf(BottomAsideGesture.prototype), 'constructor', this).apply(this, arguments);
                }

                _inherits(BottomAsideGesture, _TopAsideGesture);

                _createClass(BottomAsideGesture, [{
                    key: 'getElementStartPos',
                    value: function getElementStartPos(slide, ev) {
                        return this.aside.isOpen ? slide.min : slide.max;
                    }
                }, {
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries() {
                        return {
                            min: -this.aside.height(),
                            max: 0
                        };
                    }
                }]);

                return BottomAsideGesture;
            })(TopAsideGesture);

            _export('BottomAsideGesture', BottomAsideGesture);
        }
    };
});
System.register('ionic/components/aside/extensions/types', ['ionic/util/dom'], function (_export) {
    'use strict';

    var CSS, asideManipulator, contentManipulator, AsideType, AsideTypeOverlay, AsideTypePush, AsideTypeReveal;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_ionicUtilDom) {
            CSS = _ionicUtilDom.CSS;
        }],
        execute: function () {
            // TODO use setters instead of direct dom manipulation
            asideManipulator = {
                setSliding: function setSliding(sliding) {
                    this.aside.getNativeElement().classList[sliding ? 'add' : 'remove']('no-transition');
                },
                setOpen: function setOpen(open) {
                    this.aside.getNativeElement().classList[open ? 'add' : 'remove']('open');
                },
                setTransform: function setTransform(t) {
                    this.aside.getNativeElement().style[CSS.transform] = t;
                }
            };
            contentManipulator = {
                setSliding: function setSliding(sliding) {
                    this.aside.contentElement.classList[sliding ? 'add' : 'remove']('no-transition');
                },
                setOpen: function setOpen(open) {
                    this.aside.contentElement.classList[open ? 'add' : 'remove']('aside-open-' + this.aside.side);
                },
                setTransform: function setTransform(t) {
                    this.aside.contentElement.style[CSS.transform] = t;
                }
            };

            AsideType = function AsideType(aside) {
                _classCallCheck(this, AsideType);

                this.aside = aside;
                //FIXME(ajoslin): have to wait for for bindings to apply in a component
                setTimeout(function () {
                    aside.contentElement.classList.add('aside-content');
                });
            };

            _export('AsideType', AsideType);

            AsideTypeOverlay = (function (_AsideType) {
                function AsideTypeOverlay() {
                    _classCallCheck(this, AsideTypeOverlay);

                    _get(Object.getPrototypeOf(AsideTypeOverlay.prototype), 'constructor', this).apply(this, arguments);
                }

                _inherits(AsideTypeOverlay, _AsideType);

                _createClass(AsideTypeOverlay, [{
                    key: 'setSliding',
                    value: function setSliding(sliding) {
                        asideManipulator.setSliding.call(this, sliding);
                    }
                }, {
                    key: 'setOpen',
                    value: function setOpen(open) {
                        asideManipulator.setOpen.call(this, open);
                    }
                }, {
                    key: 'setTransform',
                    value: function setTransform(t) {
                        asideManipulator.setTransform.call(this, t);
                    }
                }]);

                return AsideTypeOverlay;
            })(AsideType);

            _export('AsideTypeOverlay', AsideTypeOverlay);

            AsideTypePush = (function (_AsideType2) {
                function AsideTypePush() {
                    _classCallCheck(this, AsideTypePush);

                    _get(Object.getPrototypeOf(AsideTypePush.prototype), 'constructor', this).apply(this, arguments);
                }

                _inherits(AsideTypePush, _AsideType2);

                _createClass(AsideTypePush, [{
                    key: 'setSliding',
                    value: function setSliding(sliding) {
                        asideManipulator.setSliding.call(this, sliding);
                        contentManipulator.setSliding.call(this, sliding);
                    }
                }, {
                    key: 'setOpen',
                    value: function setOpen(open) {
                        asideManipulator.setOpen.call(this, open);
                        contentManipulator.setOpen.call(this, open);
                    }
                }, {
                    key: 'setTransform',
                    value: function setTransform(t) {
                        asideManipulator.setTransform.call(this, t);
                        contentManipulator.setTransform.call(this, t);
                    }
                }]);

                return AsideTypePush;
            })(AsideType);

            _export('AsideTypePush', AsideTypePush);

            AsideTypeReveal = (function (_AsideType3) {
                function AsideTypeReveal() {
                    _classCallCheck(this, AsideTypeReveal);

                    _get(Object.getPrototypeOf(AsideTypeReveal.prototype), 'constructor', this).apply(this, arguments);
                }

                _inherits(AsideTypeReveal, _AsideType3);

                _createClass(AsideTypeReveal, [{
                    key: 'setSliding',
                    value: function setSliding(sliding) {
                        contentManipulator.setSliding.call(this, sliding);
                    }
                }, {
                    key: 'setOpen',
                    value: function setOpen(sliding) {
                        contentManipulator.setOpen.call(this, sliding);
                    }
                }, {
                    key: 'setTransform',
                    value: function setTransform(t) {
                        contentManipulator.setTransform.call(this, t);
                    }
                }]);

                return AsideTypeReveal;
            })(AsideType);

            _export('AsideTypeReveal', AsideTypeReveal);
        }
    };
});

/**
 * Hairline Shim
 * Add the "hairline" CSS class name to the body tag
 * if the browser supports subpixels.
 */

(function(document){

  if (window.devicePixelRatio >= 2) {
    var hairlineEle = document.createElement('div');
    hairlineEle.style.border = '.5px solid transparent';
    document.body.appendChild(hairlineEle);

    if (hairlineEle.offsetHeight === 1) {
      document.body.classList.add('hairlines');
    }
    document.body.removeChild(hairlineEle);
  }

})(document);


(function(document){

  var ionicImport = System.import('ionic/components/app/app');

  function importApp(module) {
    if (module) {
      System.import(module);
    }
  }

  var ele = document.querySelectorAll('[module]');
  for (var i = 0; i < ele.length; i++) {
    importApp(ele[i].getAttribute('module'));
  }

})(document);
System.config({ "paths":{ "ionic/*": "ionic/*" }});
